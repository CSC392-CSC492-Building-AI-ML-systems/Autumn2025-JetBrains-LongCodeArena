```rst
Generate documentation for this module
=======================================

Support for collections of mapped entities.
-------------------------------------------

The collections package supplies the machinery used to inform the ORM of collection membership changes. An instrumentation via decoration approach is used, allowing arbitrary types (including built-ins) to be used as entity collections without requiring inheritance from a base class.

Instrumentation decoration relays membership change events to the :class:`.CollectionAttributeImpl` that is currently managing the collection. The decorators observe function call arguments and return values, tracking entities entering or leaving the collection. Two decorator approaches are provided. One is a bundle of generic decorators that map function arguments and return values to events:

```python
from sqlalchemy.orm.collections import collection

class MyClass:
    @collection.adds(1)
    def store(self, item):
        self.data.append(item)

    @collection.removes_return()
    def pop(self):
        return self.data.pop()
```

The second approach is a bundle of targeted decorators that wrap appropriate append and remove notifiers around the mutation methods present in the standard Python `list`, `set`, and `dict` interfaces. These decorators are used internally for automatic instrumentation of entity collection classes.

Collection classes can be specified in `relationship(collection_class=)` as types or a function that returns an instance. Collection classes are inspected and instrumented during the mapper compilation phase. The `collection_class` callable will be executed once to produce a specimen instance, and the type of that specimen will be instrumented.

Tight control over bulk operation and the firing of events is also possible by implementing the instrumentation internally in your methods. The basic instrumentation package works under the general assumption that collection mutation will not raise unusual exceptions. If you want to closely orchestrate append and remove events with exception management, internal instrumentation may be the answer.

The owning object and :class:`.CollectionAttributeImpl` are also reachable through the adapter, allowing for some very sophisticated behavior.
```