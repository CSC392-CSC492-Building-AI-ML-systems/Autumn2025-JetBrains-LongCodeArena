# Alchemical Transformations Documentation

The `HybridTopologyFactory` class generates a hybrid topology based on a perses topology proposal. This class categorizes atoms in the resulting hybrid system into four classes:

- `unique_old_atom`: Atoms that are not mapped and only present in the old system. Their interactions are on for lambda=0 and off for lambda=1.
- `unique_new_atom`: Atoms that are not mapped and only present in the new system. Their interactions are off for lambda=0 and on for lambda=1.
- `core_atom`: Atoms that are mapped and are part of a residue that is changing. Their interactions correspond to the old system at lambda=0 and to the new system at lambda=1.
- `environment_atom`: Atoms that are mapped and are not part of a changing residue. Their interactions are always on and remain unmodified alchemically.

### Properties
- `hybrid_system`: openmm.System - The hybrid system for simulation
- `new_to_hybrid_atom_map`: dict of int : int - Mapping of new system atoms to hybrid atoms
- `old_to_hybrid_atom_map`: dict of int : int - Mapping of old system atoms to hybrid atoms
- `hybrid_positions`: [n, 3] np.ndarray - Positions of the hybrid system
- `hybrid_topology`: mdtraj.Topology - Topology of the hybrid system
- `omm_hybrid_topology`: openmm.app.Topology - OpenMM topology object corresponding to the hybrid system

**Warning:** This API is experimental and subject to change.

### Initialization Parameters
- `topology_proposal`: perses.rjmc.topology_proposal.TopologyProposal object - TopologyProposal object rendered by the ProposalEngine
- `current_positions`: [n,3] np.ndarray of float - Positions of the "old system"
- `new_positions`: [m,3] np.ndarray of float - Positions of the "new system"
- `use_dispersion_correction`: bool, default False - Whether to use the long-range correction in the custom sterics force (expensive for NCMC)
- `functions`: dict, default None - Alchemical functions that determine how each force is scaled with lambda
- `softcore_alpha`: float, default None - "alpha" parameter of softcore sterics
- `bond_softening_constant`: float - Softening factor for bonds between unique atoms and unique-core atoms
- `angle_softening_constant`: float - Softening factor for angles between unique atoms and unique-core atoms
- `soften_only_new`: bool - Whether to soften only new atoms
- `neglected_new_angle_terms`: list - Indices of HarmonicAngleForce terms in the new system that were neglected
- `neglected_old_angle_terms`: list - Indices of HarmonicAngleForce terms in the old system that were neglected
- `softcore_LJ_v2`: bool, default True - Implement a new softcore LJ potential function
- `softcore_electrostatics`: bool, default True - Implement softcore electrostatics
- `softcore_LJ_v2_alpha`: float, default 0.85 - Softcore alpha parameter for LJ v2
- `softcore_electrostatics_alpha`: float, default 0.3 - Softcore alpha parameter for electrostatics
- `softcore_sigma_Q`: float, default 1.0 - Softcore sigma parameter for electrostatics
- `interpolate_old_and_new_14s`: bool, default False - Whether to turn off interactions for new exceptions at lambda=0 and old exceptions at lambda=1
- `omitted_terms`: dict - Terms that must be annealed in over a lambda protocol
- `rmsd_restraint`: bool, default False - Impose an RMSD restraint between core heavy atoms and protein CA atoms
- `flatten_torsions`: bool, default False - Scale torsion terms involving unique atoms based on lambda values
- `endstate`: int - Lambda endstate to parameterize (should be None for `HybridTopologyFactory`)

**TODO:**
- Document how positions for the hybrid system are constructed
- Allow support for annealing in omitted terms

**Note:** The code snippet provided is incomplete and requires further completion for proper functionality.