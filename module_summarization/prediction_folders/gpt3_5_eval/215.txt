An asynchronous producer/consumer pattern for coroutines is provided by the classes in the `tornado.queues` module. These classes offer functionality similar to the queues in Python's `asyncio` package.

**Important Note:** The classes in this module are not thread-safe, unlike those in the standard library's `queue` module. If you intend to use these queues from another thread, ensure to transfer control to the `.IOLoop` thread using `.IOLoop.add_callback` before invoking any queue methods.

The main classes available in the `tornado.queues` module are:
- `Queue`
- `PriorityQueue`
- `LifoQueue`
- `QueueFull`
- `QueueEmpty`

The `Queue` class allows for coordination between producer and consumer coroutines. It supports an unbounded queue size by default, but you can specify a maximum size if needed. The class provides methods for putting items into the queue, getting items from the queue, and checking the queue's status.

Here is an example of using the `Queue` class for asynchronous producer/consumer operations:

```python
import asyncio
from tornado.ioloop import IOLoop
from tornado.queues import Queue

q = Queue(maxsize=2)

async def consumer():
    async for item in q:
        try:
            print('Doing work on %s' % item)
            await asyncio.sleep(0.01)
        finally:
            q.task_done()

async def producer():
    for item in range(5):
        await q.put(item)
        print('Put %s' % item)

async def main():
    IOLoop.current().spawn_callback(consumer)
    await producer()
    await q.join()
    print('Done')

asyncio.run(main())
```

In Python versions without native coroutines (pre-3.5), the `consumer()` function can be implemented using `@gen.coroutine` decorator and `yield` statements.

The `Queue` class supports asynchronous iteration using `async for` in Python 3.5 and later versions, allowing for efficient handling of producer/consumer tasks in coroutine-based applications.