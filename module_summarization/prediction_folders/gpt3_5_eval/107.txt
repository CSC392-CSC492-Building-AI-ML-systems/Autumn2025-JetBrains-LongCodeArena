# Documentation for iterables module

The `iterables` module provides various functions for working with iterable objects in Python. Below is a summary of the functions available in this module:

## flatten(iterable, levels=None, cls=None)

Recursively denests iterable containers. It flattens nested containers to a single level. The function takes an iterable object as input and returns a flattened list.

Example:
```python
flatten([1, [2, 3], [4, 5]])  # Output: [1, 2, 3, 4, 5]
```

## unflatten(iter, n=2)

Groups the input iterable `iter` into tuples of length `n`. It raises an error if the length of `iter` is not a multiple of `n`.

Example:
```python
unflatten([1, 2, 3, 4, 5, 6], 2)  # Output: [(1, 2), (3, 4), (5, 6)]
```

## group(seq, multiple=True)

Splits a sequence into a list of lists of equal, adjacent elements. It groups adjacent elements that are equal into sublists.

Example:
```python
group([1, 1, 1, 2, 2, 3])  # Output: [[1, 1, 1], [2, 2], [3]]
```

## multiset(seq)

Returns the hashable sequence in multiset form with values being the multiplicity of each item in the sequence.

Example:
```python
multiset('mississippi')  # Output: {'i': 4, 'm': 1, 'p': 2, 's': 4}
```

## postorder_traversal(node, keys=None)

Performs a postorder traversal of a tree-like structure represented by the input `node`. It yields nodes in a postorder fashion, visiting all children before the parent node.

Example:
```python
from diofant.abc import w
list(postorder_traversal(w + (x + y)*z, keys=True))  # Output: [w, z, x, y, x + y, z*(x + y), w + z*(x + y)]
```

## subsets(seq, k=None, repetition=False)

Generates all k-subsets (combinations) from an n-element set represented by the input `seq`. It returns combinations of length `k` from the set.

Example:
```python
list(subsets([1, 2, 3], 2))  # Output: [(1, 2), (1, 3), (2, 3)]
```

These functions provide useful utilities for working with iterable objects in Python.