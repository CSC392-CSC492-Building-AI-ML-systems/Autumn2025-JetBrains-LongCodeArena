To generate documentation for the provided code, you can follow these steps:

1. **count(detectors, num=1, delay=None, *, per_shot=None, md=None):**
   - This function takes one or more readings from detectors.
   - Parameters:
     - detectors: list of 'readable' objects.
     - num: integer, optional, default is 1.
     - delay: iterable or scalar, optional, default is 0.
     - per_shot: callable, optional.
     - md: dict, optional.
   - Notes:
     - If delay is an iterable, it must have at least num - 1 entries.
   - Returns a generator.

2. **list_scan(detectors, *args, per_step=None, md=None):**
   - Scan over one or more variables in steps simultaneously (inner product).
   - Parameters:
     - detectors: list of 'readable' objects.
     - *args: For one dimension, motor, [point1, point2, ...].
     - per_step: callable, optional.
     - md: dict, optional.
   - Raises ValueError if the list of arguments does not contain a list of points for each defined motor.
   - Returns a generator.

3. **rel_list_scan(detectors, *args, per_step=None, md=None):**
   - Scan over one variable in steps relative to the current position.
   - Parameters:
     - detectors: list of 'readable' objects.
     - *args: For one dimension, motor, [point1, point2, ...].
     - per_step: callable, optional.
     - md: dict, optional.
   - See Also: bluesky.plans.list_scan, bluesky.plans.list_grid_scan, bluesky.plans.rel_list_grid_scan.

These functions provide functionality for counting readings from detectors, scanning over variables, and scanning over variables relative to the current position. Each function has specific parameters and behaviors documented for ease of use.