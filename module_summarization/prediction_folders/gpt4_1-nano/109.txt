async
====

This documentation provides an overview of the asynchronous plans implemented in this module, focusing on data acquisition and scanning strategies.

Functions
---------

count
~~~~~
Performs a specified number of readings from one or more detectors, optionally with delays and custom per-shot actions.

Parameters:
- detectors (list): List of 'readable' detector objects.
- num (int, optional): Number of readings to take; defaults to 1. If None, continues until canceled.
- delay (iterable or scalar, optional): Time delay in seconds between successive readings; defaults to 0.
- per_shot (callable, optional): Hook for customizing actions at each shot. Signature: `def f(detectors) -> Generator[Msg]`.
- md (dict, optional): Metadata dictionary to include with the plan.

Notes:
- If `delay` is an iterable, it must have at least `num - 1` entries.
- Uses decorators for staging detectors and attaching metadata.

Returns:
- An asynchronous generator yielding plan execution steps.

Examples:
.. code-block:: python

    plan = count(detectors=[det1, det2], num=5, delay=0.1)
    async for step in plan:
        process(step)

---

list_scan
~~~~~~~~~
Performs a multi-dimensional scan over specified motors and points, executing actions at each combination.

Parameters:
- detectors (list): List of detector objects.
- *args: Pairs of motor objects and their corresponding list of points.
- per_step (callable, optional): Hook for customizing actions at each step. Signature: `f(detectors, motor, step)`.
- md (dict, optional): Metadata dictionary.

Notes:
- All point lists must be of equal length.
- Constructs a Cartesian product of motor positions.
- Uses plan patterns for nested iteration.

Returns:
- An asynchronous generator executing the scan sequence.

Examples:
.. code-block:: python

    plan = list_scan(
        detectors=[det1],
        motor1, [0, 1, 2],
        motor2, [10, 20, 30],
        per_step=custom_action
    )
    async for step in plan:
        handle(step)

---

rel_list_scan
~~~~~~~~~~~~~
Performs a scan over one or more motors with positions relative to their current positions.

Parameters:
- detectors (list): List of detector objects.
- *args: Pairs of motor objects and lists of relative steps.
- per_step (callable, optional): Hook for customizing actions at each step.
- md (dict, optional): Metadata dictionary.

Notes:
- The implementation is a placeholder (`TODO`) and should be completed to support relative positioning.

Usage:
- Similar to `list_scan`, but positions are relative to current motor positions.

Examples:
.. code-block:: python

    plan = rel_list_scan(
        detectors=[det1],
        motor1, [1, 2, 3],
        motor2, [-1, 0, 1],
        per_step=custom_action
    )
    async for step in plan:
        handle(step)

Additional Information
----------------------
- The plans utilize decorators for staging detectors and attaching metadata.
- They integrate with plan patterns for complex iteration schemes.
- Designed to be used within an asynchronous event loop for efficient data acquisition.

This module enables flexible, asynchronous data collection and scanning strategies suitable for experimental workflows requiring concurrency and responsiveness.