autowrap
========

Overview
--------
The `autowrap` module provides a high-level interface for compiling mathematical expressions into efficient binary functions that can be used within Python. It supports multiple backend code generators, such as f2py and Cython, enabling users to generate, compile, and invoke optimized code with minimal effort.

Key Features
------------
- Generate binary Python functions from symbolic expressions.
- Support for multiple external backends (f2py, Cython, and potentially others).
- Easy integration with Diofant for symbolic computation.
- Facilitate the creation of custom ufuncs for NumPy arrays.
- Simplify testing and deployment of computationally intensive code.

Main Components
---------------
### CodeWrapper
A base class for handling code generation, file management, and compilation. It manages the creation of source files, compilation commands, and module imports. Subclasses implement specific backend logic.

### DummyWrapper
A mock wrapper used for testing purposes. It generates dummy Python modules that simulate compiled code without actual compilation.

### CythonCodeWrapper
A wrapper that utilizes Cython for code generation and compilation, providing optimized Cython modules.

Usage
-----
To generate a binary function from a symbolic expression, use:

```python
from autowrap import autowrap, binary_function

# Define a symbolic expression
expr = ((x - y)**25).expand()

# Generate a binary callable
binary_callable = autowrap(expr)

# Use the generated function
result = binary_callable(1, 2)
```

For integration with symbolic expressions and to maintain symbolic capabilities, use `binary_function()`:

```python
f = binary_function('f', expr)
value = 2 * f(x, y) + y
evaluated = value.evalf(2, subs={x: 1, y: 2}, strict=False)
```

Advantages
----------
- **Performance:** Compiled binaries execute faster than symbolic evaluations, especially for large or repeatedly called expressions.
- **Convenience:** Automates code generation, compilation, and import, reducing manual effort.
- **Flexibility:** Supports multiple backends and can be extended to include new code generators.
- **Integration:** Seamlessly works with Diofant symbolic expressions and NumPy arrays.

Limitations
-----------
- Not suitable for scenarios requiring fine-grained memory or speed optimizations beyond what the generated binaries provide.
- Requires external tools like compilers and dependencies (e.g., numpy, f2py, gfortran, gcc).
- Temporary files are managed automatically but can be preserved for debugging by specifying a `tempdir`.

See Also
--------
- `autowrap()`: Main function to generate and compile code.
- `binary_function()`: Creates symbolic functions linked to compiled binaries.
- `CodeWrapper` subclasses: Implement specific backend logic (e.g., Cython, Dummy).

This module simplifies the process of turning symbolic mathematical expressions into high-performance, reusable binary functions, facilitating advanced numerical computations within Python.