Queues for Asynchronous Producer/Consumer Pattern
==================================================

Introduction
------------
The `tornado.queues` module provides asynchronous queue classes designed for coordinating producer and consumer coroutines in an event-driven environment. These queues facilitate safe and efficient communication between coroutines, allowing producers to add items and consumers to retrieve them asynchronously.

Key Classes
-----------
- `Queue`: A general-purpose FIFO queue supporting asynchronous put and get operations.
- `PriorityQueue`: A queue where items are retrieved in priority order.
- `LifoQueue`: A last-in, first-out queue similar to a stack.

Usage Pattern
-------------
The producer/consumer pattern involves one or more producer coroutines generating data and placing it into the queue, while one or more consumer coroutines retrieve and process the data. This pattern decouples data production from consumption, enabling scalable and responsive applications.

Example
-------
```python
import asyncio
from tornado.ioloop import IOLoop
from tornado.queues import Queue

q = Queue(maxsize=2)

async def consumer():
    async for item in q:
        try:
            print('Processing %s' % item)
            await asyncio.sleep(0.01)
        finally:
            q.task_done()

async def producer():
    for item in range(5):
        await q.put(item)
        print('Produced %s' % item)

async def main():
    IOLoop.current().spawn_callback(consumer)
    await producer()
    await q.join()
    print('All tasks completed')

asyncio.run(main())
```

Behavior and Features
---------------------
- **Asynchronous Operations**: `put()` and `get()` are awaitable, allowing coroutines to yield control until the operation completes.
- **Bounded and Unbounded Queues**: The `maxsize` parameter controls the maximum number of items. A `maxsize` of 0 indicates an unbounded queue.
- **Timeout Support**: Both `put()` and `get()` support optional timeout parameters, raising `TimeoutError` if the operation exceeds the specified duration.
- **Task Tracking**: The queue tracks unfinished tasks, enabling consumers to signal task completion with `task_done()`. The `join()` method waits until all tasks are processed.
- **Non-Thread-Safe**: These queues are designed for use within the Tornado IOLoop and are not thread-safe. To interact from other threads, use `IOLoop.add_callback()`.

Exception Handling
------------------
- `QueueEmpty`: Raised when attempting to retrieve an item from an empty queue using `get_nowait()`.
- `QueueFull`: Raised when attempting to add an item to a full queue using `put_nowait()`.

Advanced Usage
--------------
The queues support iteration with `async for`, enabling idiomatic consumption of items as they become available. They also support priority and LIFO behaviors through specialized subclasses.

Summary
-------
The asynchronous queues in Tornado facilitate the implementation of producer/consumer patterns in coroutine-based applications, providing a flexible, efficient, and easy-to-use mechanism for inter-coroutine communication within an event-driven architecture.
