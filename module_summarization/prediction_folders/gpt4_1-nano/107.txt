iterables Module
==================

This module provides a collection of utility functions for working with iterables, sequences, and tree structures. These functions facilitate common operations such as flattening nested iterables, grouping elements, generating subsets, traversing trees, and more. The functions are designed to be flexible and efficient, supporting various use cases in data manipulation and combinatorial algorithms.

Functions
---------

### flatten(iterable, levels=None, cls=None)

Recursively denest iterable containers into a flat list. Supports limiting the number of levels to flatten and flattening only instances of a specified class.

**Parameters:**
- `iterable`: The iterable to flatten.
- `levels` (optional): Number of nested levels to flatten. If `None`, flatten all levels.
- `cls` (optional): Class type to flatten. Only instances of this class are flattened.

**Returns:**
A list containing the flattened elements.

**Examples:**
- Flatten a nested list:
  ```python
  flatten([1, [2, [3]]])  # Output: [1, 2, 3]
  ```
- Flatten only one level:
  ```python
  flatten([[1, 2], [3, 4]], levels=1)  # Output: [1, 2, 3, 4]
  ```
- Flatten instances of a specific class:
  ```python
  class MyOp:
      def __init__(self, args):
          self.args = args
  flatten([MyOp(1), MyOp([2, 3])]], cls=MyOp)  # Output: [1, 2, 3]
  ```

### unflatten(iter, n=2)

Groups a flat iterable into tuples of length `n`. Raises an error if the length of the iterable is not a multiple of `n`.

**Parameters:**
- `iter`: The iterable to unflatten.
- `n`: The size of each group (default is 2).

**Returns:**
A list of tuples, each of length `n`.

**Raises:**
`ValueError` if the length of `iter` is not divisible by `n`.

**Examples:**
```python
unflatten([1, 2, 3, 4], n=2)  # Output: [(1, 2), (3, 4)]
```

### group(seq, multiple=True)

Splits a sequence into a list of lists of adjacent, equal elements. If `multiple` is `False`, returns tuples of the element and its count.

**Parameters:**
- `seq`: The sequence to group.
- `multiple`: Whether to group into lists (`True`) or tuples of element and count (`False`).

**Returns:**
A list of groups or tuples, depending on `multiple`.

**Examples:**
- Group consecutive identical elements:
  ```python
  group([1, 1, 2, 2, 2, 3])  # Output: [[1, 1], [2, 2, 2], [3]]
  ```
- Group with counts:
  ```python
  group([1, 1, 2, 2, 2], multiple=False)  # Output: [(1, 2), (2, 3)]
  ```

### multiset(seq)

Returns a multiset representation of a sequence as a dictionary with elements as keys and their multiplicities as values.

**Parameters:**
- `seq`: The sequence to convert.

**Returns:**
A dictionary representing the multiset.

**Examples:**
```python
multiset('mississippi')  # Output: {'m': 1, 'i': 4, 's': 4, 'p': 2}
```

### postorder_traversal(node, keys=None)

Performs a postorder traversal of a tree structure, yielding nodes after their children have been visited.

**Parameters:**
- `node`: The root node of the tree (expected to be a diofant expression or similar structure).
- `keys`: Optional sorting keys for node arguments.

**Yields:**
Nodes in postorder sequence.

**Examples:**
```python
from diofant.abc import w, x, y, z
list(postorder_traversal(w + (x + y)*z, keys=True))
# Output: [w, z, x, y, x + y, z*(x + y), w + z*(x + y)]
```

### subsets(seq, k=None, repetition=False)

Generates all subsets (combinations) of the sequence `seq`. If `k` is specified, generates subsets of size `k`. Supports repetition.

**Parameters:**
- `seq`: The input sequence.
- `k` (optional): Size of subsets to generate.
- `repetition`: Whether to allow repeated elements in subsets.

**Returns:**
An iterator over subsets, each as a tuple.

**Examples:**
```python
list(subsets([1, 2, 3], k=2))
# Output: [(1, 2), (1, 3), (2, 3)]
```

Summary
-------

This module offers versatile tools for iterable manipulation, including flattening nested structures, grouping elements, generating combinations, traversing trees, and analyzing multisets. These functions are essential for complex data processing, combinatorial algorithms, and tree-based computations in mathematical and computational applications.