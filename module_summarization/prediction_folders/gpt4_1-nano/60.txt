Collection API Documentation
============================

Overview
--------
The `collections` module provides support for managing collections of mapped entities within SQLAlchemy ORM. It offers mechanisms to instrument collection classes, enabling automatic tracking of membership changes, which are essential for ORM synchronization and event handling.

Key Features
------------
- Decorators for annotating collection methods to indicate their roles (appender, remover, iterator, converter).
- Automatic instrumentation of collection classes, including built-in types like `list`, `set`, and `dict`.
- Support for custom collection classes via `collection_class` parameter in relationships.
- Internal and external decoration strategies to efficiently track collection mutations.
- Integration with SQLAlchemy's event system for collection change notifications.

Main Components
---------------
- `collection`: Decorator class providing various decorators to annotate collection methods.
- `collection_adapter`: Utility for internal control over collection mutation events.
- `keyfunc_mapping`, `column_keyed_dict`, `attribute_keyed_dict`: Utilities for keyed collection implementations.
- `MappedCollection`, `KeyFuncDict`: Types supporting custom collection behaviors.

Decorators
----------
### `collection.appender`
Marks a method as the collection's appender, which is called with a single argument to add an item to the collection.

### `collection.remover`
Marks a method as the collection's remover, which is called with a single argument to remove an item from the collection.

### `collection.adds`
Decorator for methods that add entities, specifying the argument name representing the entity to add.

### `collection.removes_return`
Decorator for methods that remove entities and return the removed item(s).

### `collection.internal_instrumented`
Indicates methods that are internally instrumented for collection change tracking.

Usage
-----
Collection classes can be specified in ORM relationships via the `collection_class` parameter. These classes are automatically instrumented during mapper compilation, allowing ORM to monitor and respond to collection mutations.

Example
-------
```python
from sqlalchemy.orm.collections import collection

class MyCollection:
    @collection.adds('entity')
    def add_entity(self, entity):
        self.entities.append(entity)

    @collection.removes_return()
    def remove_entity(self):
        return self.entities.pop()
```

Instrumentation Process
-----------------------
1. If the class is a built-in, a trivial subclass is created.
2. Checks if the class is already instrumented.
3. Adds generic decorators.
4. Uses duck-typing to identify collection interface.
5. Adds targeted decoration to uninstrumented methods.

Thread Safety
-----------
The module employs a threading lock (`__instrumentation_mutex`) to ensure thread-safe instrumentation processes.

Type Support
------------
The module uses Python's `typing` module extensively to define protocols, type variables, and type hints, facilitating static type checking and IDE support.

Additional Utilities
--------------------
- `collection_adapter`: Provides explicit control over collection mutation events, useful for custom mutation logic with exception handling.
- `NO_KEY`, `NO_ARG`: Constants used internally for collection management.

Integration
-----------
Designed to work seamlessly with SQLAlchemy ORM, enabling automatic and manual instrumentation of collection attributes, and supporting complex collection behaviors and custom collection classes.

For more detailed usage and advanced features, refer to the full documentation and source code.