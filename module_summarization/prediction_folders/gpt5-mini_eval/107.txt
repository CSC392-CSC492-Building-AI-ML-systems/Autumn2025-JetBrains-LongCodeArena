Iterables
=========

Collection of utility routines for working with iterables, sequences and
tree-like structures.

Functions
---------

.. function:: flatten(iterable, levels=None, cls=None)

    Recursively denest iterable containers.

    Parameters
    ----------
    iterable : iterable
        The object to be flattened. Sequences (lists, tuples, etc.) and
        objects with an ``args`` attribute are considered for flattening by
        default.
    levels : int or None, optional
        Maximum number of levels to flatten. If None, flatten completely.
        If 0, the input is returned unchanged. Must be non-negative.
    cls : type or None, optional
        If given, only instances of this class are flattened; otherwise any
        sequence-like object is flattened.

    Returns
    -------
    list
        A new list with nested containers expanded according to the rules
        above.

    Raises
    ------
    ValueError
        If ``levels`` is negative.

    Examples
    --------
    >>> flatten([1, 2, 3])
    [1, 2, 3]
    >>> flatten([1, 2, [3]])
    [1, 2, 3]
    >>> flatten([1, [2, 3], [4, 5]])
    [1, 2, 3, 4, 5]
    >>> flatten([1.0, 2, (1, None)])
    [1.0, 2, 1, None]

    Partial flattening:
    >>> ls = [[(-2, -1), (1, 2)], [(0, 0)]]
    >>> flatten(ls, levels=1)
    [(-2, -1), (1, 2), (0, 0)]

    Flatten only instances of a given class:
    >>> class MyOp: ...
    >>> # Example assumes MyOp instances expose .args in the environment where
    >>> # they are used; shown here for illustration only.
    >>> # flatten([MyOp(1, MyOp(2, 3))], cls=MyOp)
    [1, 2, 3]


.. function:: unflatten(iter, n=2)

    Group ``iter`` into tuples of length ``n``.

    Parameters
    ----------
    iter : sequence
        Sequence to group into n-tuples.
    n : int, optional
        Size of each group (default 2).

    Returns
    -------
    list of tuples
        A list of tuples obtained by grouping the input.

    Raises
    ------
    ValueError
        If ``n < 1`` or the length of ``iter`` is not a multiple of ``n``.

    Examples
    --------
    >>> unflatten([1,2,3,4], 2)
    [(1, 2), (3, 4)]
    >>> unflatten([1,2,3,4,5,6], 3)
    [(1, 2, 3), (4, 5, 6)]


.. function:: group(seq, multiple=True)

    Split a sequence into a list of lists where each sublist contains
    equal adjacent elements.

    Parameters
    ----------
    seq : sequence
        The sequence to group.
    multiple : bool, optional
        If True (default) return lists of repeated elements. If False,
        return pairs (element, multiplicity) for each run.

    Returns
    -------
    list
        Grouped runs as lists (when ``multiple=True``) or as (element, count)
        tuples (when ``multiple=False``). Returns an empty list for empty
        input.

    Examples
    --------
    >>> group([1, 1, 1, 2, 2, 3])
    [[1, 1, 1], [2, 2], [3]]
    >>> group([1, 1, 1, 2, 2, 3], multiple=False)
    [(1, 3), (2, 2), (3, 1)]
    >>> group([1, 1, 3, 2, 2, 1], multiple=False)
    [(1, 2), (3, 1), (2, 2), (1, 1)]

    See also
    --------
    multiset


.. function:: multiset(seq)

    Return a mapping representing the multiset (multiplicities) of the
    items of ``seq``.

    Parameters
    ----------
    seq : iterable
        Input sequence whose multiplicities will be counted.

    Returns
    -------
    dict
        A dictionary mapping each unique item to its count (an int).

    Examples
    --------
    >>> multiset('mississippi')
    {'m': 1, 'i': 4, 's': 4, 'p': 2}

    See also
    --------
    group


.. function:: postorder_traversal(node, keys=None)

    Generator for a postorder (depth-first) traversal of a tree-like object.

    The traversal yields each subtree after its children have been yielded.

    Parameters
    ----------
    node : object
        The root node to traverse. In the typical use with expression trees
        (objects deriving from Basic), the traversal will recurse into
        ``.args``. If ``node`` is any iterable, its elements are traversed.
    keys : object or None, optional
        Sorting key(s) passed to the ordering routine used when visiting the
        children of objects that have ordered arguments. If ``None``, no
        particular order is enforced. If ``keys`` is True the default ordering
        keys are used. Otherwise custom key(s) can be supplied.

    Yields
    ------
    object
        Every encountered subtree, produced after its children.

    Notes
    -----
    This function expects the Basic-like class used in the environment to
    behave like typical expression nodes with an ``args`` attribute. When
    used with such objects, children can be optionally ordered for a
    deterministic traversal.

    Examples
    --------
    >>> from diofant.abc import w, x, y, z
    >>> list(postorder_traversal(w + (x + y)*z, keys=True))
    [w, z, x, y, x + y, z*(x + y), w + z*(x + y)]


.. function:: subsets(seq, k=None, repetition=False)

    Generate all k-subsets (combinations) from an n-element sequence ``seq``.

    A k-subset is a subset of length exactly k. If ``k`` is None, all
    2**n subsets are returned in order from shortest to longest.

    Parameters
    ----------
    seq : sequence
        Input sequence from which subsets are drawn.
    k : int or None, optional
        Size of each subset; when None, all subsets are generated.
    repetition : bool, optional
        If True, combinations with repeated elements are allowed
        (combinations with replacement). If False (default), no repetition.

    Returns
    -------
    iterator
        An iterator over tuples representing subsets (combinations).

    Examples
    --------
    >>> from diofant.utilities.iterables import subsets
    >>> list(subsets([1, 2], 2))
    [(1, 2)]
    >>> list(subsets([1, 2]))
    [(), (1,), (2,), (1, 2)]
    >>> list(subsets([1, 2, 3], 2))
    [(1, 2), (1, 3), (2, 3)]

See also
--------
- itertools (Python standard library)
- diofant core utilities used for ordering and Basic nodes where applicable

Notes
-----
These utilities are small, self-contained helpers for working with nested
containers, grouping and combinatorial iteration and are intended to be used
within a symbolic-expression framework (e.g. where nodes may expose ``.args``)
but are general-purpose enough for standard Python sequences.