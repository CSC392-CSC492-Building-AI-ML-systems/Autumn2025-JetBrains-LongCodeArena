GAM — Examples
==============

This document provides examples showing how to generate and use B‑spline bases and smoothers included in this module. The examples cover:
- generating knots for B‑splines,
- evaluating B‑spline bases and derivatives,
- assembling a design matrix using the generated basis,
- a minimal example fitting a (penalized) GAM-like model,
- a short note on using BSplines / GLMGam and MultivariateGAMCVPath.

Requirements
------------
The code examples below require:
- numpy
- scipy (for spline evaluation)
- patsy (optional, but useful)
- statsmodels (for modeling utilities)

Generating knots and B‑spline basis
----------------------------------
Functions provided in the module let you compute knot placements, evaluate B‑spline bases and derivatives, and produce complete bases suitable as regressors.

Key functions
- _equally_spaced_knots(x, df)
  - returns equally spaced knot locations between min(x) and max(x).
- _R_compat_quantile(x, probs)
  - R-compatible quantile computation used for knot placement.
- compute_all_knots(x, df, degree)
  - returns (all_knots, lower_bound, upper_bound, inner_knots).
- _eval_bspline_basis(x, knots, degree, deriv='all', include_intercept=True)
  - evaluate the B‑spline basis (and optionally first/second derivatives) at points x.
  - requires scipy.interpolate.splev.
- make_bsplines_basis(x, df, degree)
  - convenience wrapper: computes knots and returns (basis, der_basis, der2_basis).
- get_knots_bsplines(..., spacing='quantile' | 'equal', ...)
  - helper to obtain knot sequences in different spacing modes.

Minimal working example: build basis and fit a linear model
----------------------------------------------------------
The following shows how to generate a cubic B‑spline basis for a single predictor, assemble a design matrix and fit a simple OLS model using the basis functions as regressors.

.. code-block:: python

    import numpy as np
    import statsmodels.api as sm

    # synthetic data
    rng = np.random.default_rng(12345)
    n = 200
    x = np.linspace(0, 10, n)
    y = np.sin(x) + 0.3 * rng.standard_normal(n)

    # make a B-spline basis (cubic)
    df = 12          # number of basis functions (roughly)
    degree = 3       # cubic splines
    basis, der1, der2 = make_bsplines_basis(x, df, degree)
    # basis has shape (n, n_bases)

    # assemble design matrix and fit OLS
    X = sm.add_constant(basis)   # include intercept
    ols_model = sm.OLS(y, X).fit()
    print(ols_model.summary())

Notes:
- The example above uses ordinary least squares on the spline basis (no smoothing penalty). For penalized smoothing, see the next section.

Using BSplines, GLMGam and MultivariateGAMCVPath
-----------------------------------------------
This module exposes BSplines and higher-level classes (GLMGam, MultivariateGAMCVPath) intended to support penalized GAM fitting and smoothing-parameter selection. The exact API depends on the rest of the package; the outline below illustrates typical usage patterns.

1) Create a BSplines object that describes the smoothers (multivariate support):
.. code-block:: python

    # x can be 2D array: n_obs x n_predictors
    X_predictors = x.reshape(-1, 1)  # single predictor as 2D array
    # Example BSplines constructor (typical signature):
    bs = BSplines(X_predictors, df=[12], degree=[3], include_intercept=False)

2) Fit a penalized GAM with GLMGam by passing the smoother description:
.. code-block:: python

    # Hypothetical usage; adapt parameters to your GLMGam API
    gam = GLMGam(endog=y, exog=None, smoother=bs, family=None)
    res = gam.fit()
    print(res.summary())

3) Use MultivariateGAMCVPath to select smoothing penalties via CV:
.. code-block:: python

    # This is illustrative. Typical workflow:
    cv = MultivariateGAMCVPath(gam_model=GLMGam, smoother=bs,
                               alphas=[1e-6, 1e-4, 1e-2, 1.0])
    cv_result = cv.fit(X_predictors, y)
    best_alpha = cv_result.best_alpha_
    # Refit final model with best_alpha

Caveats and hints
-----------------
- _eval_bspline_basis will raise an error if evaluation points lie outside the outermost knots; make sure knots cover your data range or extend bounds appropriately.
- The helpers implement two primary knot spacing strategies:
  - 'quantile' (data-adaptive; similar to patsy)
  - 'equal' (regular spacing; useful for P‑splines)
- When using derivatives (deriv=1 or 2), the function returns derivative bases useful for constructing penalty matrices or computing gradient/curvature.
- For fully penalized GAM fitting and automated smoothing-parameter selection, prefer using the higher-level BSplines / GLMGam / MultivariateGAMCVPath utilities rather than manually fitting OLS on bases.

Reference example: inspect knots and basis
-----------------------------------------
Use compute_all_knots to inspect computed boundary and inner knots:

.. code-block:: python

    all_knots, lower, upper, inner = compute_all_knots(x, df=12, degree=3)
    print("lower, upper:", lower, upper)
    print("inner knots:", inner)
    print("all knots length:", len(all_knots))

Summary
-------
This module supplies the building blocks to construct B‑spline bases, evaluate their derivatives, and plug these bases into regression or penalized GAM workflows. Start by generating an appropriate basis with make_bsplines_basis or BSplines, then choose plain regression (OLS) for quick checks or GLMGam + MultivariateGAMCVPath for full penalized GAM estimation and smoothing-parameter selection.