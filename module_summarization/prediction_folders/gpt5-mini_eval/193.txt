Metadata Routing API
====================

The Metadata Routing API provides utilities for meta-estimators to route "metadata"
(call-time keyword arguments such as sample_weight, fit/partial_fit params, or
custom per-output arguments) from the public meta-estimator API to the appropriate
underlying single-output estimators.

This is commonly needed for meta-estimators that internally manage multiple
sub-estimators (for example MultiOutputRegressor, MultiOutputClassifier, or
chains of estimators) where a user may want to specify metadata either once
for all sub-estimators or separately for each target.

Key components
--------------

MetadataRouter
  High-level helper used by meta-estimators to define how metadata parameters
  of public methods (e.g. fit, partial_fit, predict, score) should be mapped
  and dispatched to the underlying estimators.

  Conceptually, a MetadataRouter is constructed with a mapping that describes,
  for each public method, which keyword arguments are considered metadata and
  how they should be routed. The router is used at call time to transform the
  public method call into per-estimator calls with the correctly selected
  metadata for each sub-estimator.

  Typical responsibilities:
  - validate that provided metadata keys are expected for the method;
  - support broadcast semantics (single value applied to all sub-estimators);
  - support per-estimator values supplied as sequences or mapping keyed by
    output index or output name;
  - handle missing metadata (None) by not passing it to underlying estimators;
  - produce per-estimator keyword arguments dictionaries to be passed to each
    clone/fit/partial_fit call.

MethodMapping
  A small description object used in the router configuration to declare how a
  particular public keyword argument should be treated for a specific method.
  A MethodMapping typically includes:
  - the public parameter name (e.g. "sample_weight");
  - the target name to use when calling the underlying estimator (often the
    same as the public name but can differ);
  - optional validation rules or transformation rules (for example: cast to
    ndarray, check length matches n_samples or n_outputs);
  - whether the parameter is expected to be provided per-output, per-sample,
    or global.

  MethodMapping instances are the building blocks of the MetadataRouter's
  mapping configuration.

process_routing
  Convenience function used inside a meta-estimator method implementation. Given
  the router instance, the name of the public method (e.g. "fit") and the call
  keyword arguments, process_routing validates and transforms the metadata
  arguments and returns:
  - a cleaned set of public kwargs (with routed metadata removed or replaced),
  - an iterable of per-estimator kwargs (one dict per sub-estimator) ready to be
    passed when fitting/calling the sub-estimators.

  A typical meta-estimator implementation uses process_routing to obtain the
  per-estimator kwargs and then iterates over sub-estimators applying each
  corresponding kwargs.

_routing_enabled
  Small helper predicate that indicates whether routing is active for a given
  method or router configuration. This is useful to short-circuit routing logic
  when no routing is configured for a method or when the provided kwargs do not
  contain any routed keys.

_raise_for_params
  Utility used internally to raise clear, consistent errors when unexpected or
  incompatible metadata parameters are provided. For example, it reports:
  - unknown parameter names for a given method;
  - parameter values with invalid shape or dtype for the expected routing
    semantics;
  - mixed incompatible specifications (e.g. mapping keyed both by output name
    and by output index in a way that cannot be reconciled).

Design and semantics
--------------------

- Broadcast and per-estimator values
  - A metadata argument can be passed as a single value (applies to all
    sub-estimators), a sequence (one value per sub-estimator), or a mapping
    (keys may be integer indices or output names). The router will normalize
    these forms into a sequence of values aligned with the internal ordering
    of sub-estimators.

- Missing or None values
  - If a metadata value is omitted or explicitly set to None, it is treated as
    "no metadata" and is not forwarded to the underlying estimator call
    unless that estimator requires it.

- Validation
  - The router performs shape/length validation where appropriate. For example,
    if a metadata argument is specified as a per-sample weight, the router
    will check the length matches the number of samples in X or raise a clear
    error via _raise_for_params.

- Target renaming
  - The router can rename public parameter names to the expected parameter
    names of the underlying estimator method. This is useful when the meta-
    estimator exposes a unified API but delegates to heterogeneous sub-
    estimators that expect different keyword argument names.

Examples
--------

1) Simple broadcast of sample_weight to all sub-estimators in fit

  # pseudocode inside meta-estimator.fit
  router = MetadataRouter({
      "fit": [ MethodMapping(public_name="sample_weight",
                             target_name="sample_weight",
                             per_output=False) ]
  })
  public_kwargs = {"sample_weight": sample_weight}
  public_kwargs, per_estimator_kwargs = process_routing(
      router, method="fit", n_sub_estimators=len(estimators), **public_kwargs
  )
  for est, est_kwargs in zip(estimators, per_estimator_kwargs):
      est.fit(X, y_i, **est_kwargs)

2) Per-output metadata using a sequence

  # user provides a list of per-target sample weights
  sample_weight = [w0, w1, w2]  # one element per output
  # router normalizes into per_estimator_kwargs such that est 0 gets w0, etc.

3) Per-output metadata using a mapping by name

  # If outputs are named ("height", "weight", "age"), user can pass:
  sample_weight = {"height": wh, "weight": ww, "age": wa}
  # router maps names to the internal ordering and produces the same result as
  # a sequence.

Errors and messages
-------------------

- Unknown metadata key:
  Raised when a public keyword argument is provided that is not declared in the
  router mapping for the current method.

- Shape mismatch:
  Raised when a per-sample or per-output metadata value does not match the
  expected number of samples or outputs.

- Ambiguous specification:
  Raised when the provided metadata mapping is ambiguous or mixes incompatible
  indexing schemes.

Best practices
--------------

- Declare routing explicitly for each public method your meta-estimator exposes
  (fit, partial_fit, predict, score, etc.). Only declare keys that your inner
  estimators can accept.

- Prefer broadcasting when the same metadata should apply to all sub-
  estimators. Use sequences or mappings when per-output control is required.

- Rely on MethodMapping's validation features to produce helpful error messages,
  rather than duplicating validation logic in your meta-estimator.

Notes
-----

This API is intentionally lightweight and focused on call-time metadata
dispatching. It is not a replacement for careful design of estimator APIs, but
helps meta-estimators expose a convenient and consistent interface while
correctly forwarding metadata to their internal components.