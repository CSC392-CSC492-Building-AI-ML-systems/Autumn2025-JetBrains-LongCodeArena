basics.indexing
===============

.. module:: basics.indexing
   :synopsis: Utilities to inspect, manipulate and combine NumPy structured and
      record arrays, including helpers for nested (record) dtypes.

Overview
--------
This module provides a collection of helper functions to work with NumPy
structured dtypes and record arrays (including nested fields and subarray
dtypes). The utilities include inspection routines (to obtain field names and
flatten nested descriptions), routines to merge/append/rename/drop fields, and
helpers to convert between structured and unstructured representations.
Several routines support nested record dtypes recursively.

Common use cases
----------------
- Inspect the structure of a structured dtype to obtain flat or nested names.
- Flatten nested dtype descriptions for conversion or dtype reconstruction.
- Fill an output structured array using fields from an input array (supports
  nested records).
- Convert between structured and unstructured arrays.
- Combine, join or stack multiple structured arrays with compatible dtypes.

Public API (high level summary)
-------------------------------
The module exposes the following public helpers (listed in __all__):

- append_fields
  - Append new fields to an existing structured/record array.
- apply_along_fields
  - Apply a function independently to each field (or each flattened field).
- assign_fields_by_name
  - Assign values to fields selected by name(s).
- drop_fields / rec_drop_fields
  - Remove fields from a dtype/record array (supports nested fields in the
    record-oriented helpers).
- find_duplicates
  - Find duplicate rows based on one or more fields.
- flatten_descr
  - Flatten a nested dtype description into a sequence of (name, dtype)
    pairs (subdtypes are expanded).
- get_fieldstructure
  - Return a nested description of fields (structure representation).
- get_names / get_names_flat
  - Retrieve field names: nested tuple form (get_names) or flattened tuple
    (get_names_flat).
- join_by / rec_join
  - Join two record arrays by one or more key fields (record-oriented join).
- merge_arrays
  - Merge several arrays (with possibly different dtypes) into one structured
    array.
- rec_append_fields / rec_join / rec_drop_fields
  - Record-oriented variants of append/join/drop that maintain recarray-like
    behavior and handle nested types.
- recursive_fill_fields
  - Fill the fields of one structured array from another, recursively
    traversing nested record fields.
- rename_fields
  - Rename one or more fields in a structured dtype or record array.
- repack_fields
  - Repack fields to eliminate padding and unnecessary offsets.
- require_fields
  - Ensure specific fields (possibly creating them) are present on an array.
- stack_arrays
  - Stack record arrays along the first axis, producing a single array with
    a unified dtype.
- structured_to_unstructured / unstructured_to_structured
  - Convert between structured arrays and a regular (unstructured) ndarray.

Selected function details
-------------------------

recursive_fill_fields(input, output)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Fill fields in ``output`` from the corresponding fields in ``input``.
Supports nested record dtypes: when a field itself is a structured dtype,
the function recurses into that substructure.

Signature
: recursive_fill_fields(input: ndarray, output: ndarray) -> ndarray

Notes
- ``output`` must be at least as long as ``input`` along the first axis.
- When a field is nested, fields are filled recursively. Non-existing fields
  in ``input`` are skipped.

Example
.. code-block:: python

   import numpy as np
   from basics.indexing import recursive_fill_fields

   a = np.array([(1, 10.), (2, 20.)],
                dtype=[('A', np.int64), ('B', np.float64)])
   b = np.zeros((3,), dtype=a.dtype)
   recursive_fill_fields(a, b)
   # result: array([(1, 10.), (2, 20.), (0,  0.)], dtype=[('A','<i8'),('B','<f8')])

get_names(adtype)
~~~~~~~~~~~~~~~~~~
Return a nested tuple of field names for the provided dtype. Nested structured
sub-dtypes are represented as nested tuples (field-name, (subfield-names,...)).

Signature
: get_names(adtype: dtype) -> tuple

Example
.. code-block:: python

   import numpy as np
   from basics.indexing import get_names

   dt = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])
   get_names(dt)  # -> ('a', ('b', ('ba', 'bb')))

get_names_flat(adtype)
~~~~~~~~~~~~~~~~~~~~~~~
Return a flattened tuple of field names for the provided dtype. Nested subfields
are expanded into the single flat sequence.

Signature
: get_names_flat(adtype: dtype) -> tuple

Example
.. code-block:: python

   import numpy as np
   from basics.indexing import get_names_flat

   dt = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])
   get_names_flat(dt)  # -> ('a', 'b', 'ba', 'bb')

flatten_descr(ndtype)
~~~~~~~~~~~~~~~~~~~~~~
Flatten a structured dtype description into an ordered sequence of (name, dtype)
pairs where nested structured fields are expanded into their constituent fields.

Signature
: flatten_descr(ndtype: dtype) -> tuple

Example
.. code-block:: python

   import numpy as np
   from basics.indexing import flatten_descr

   nd = np.dtype([('a', '<i4'), ('b', [('ba', '<f8'), ('bb', '<i4')])])
   flatten_descr(nd)
   # -> (('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))

_get_fieldspec(dtype)
~~~~~~~~~~~~~~~~~~~~~
Internal utility to produce a list of (name, dtype) pairs corresponding to the
fields of a dtype. Unlike ``dtype.descr`` the second element of each pair is a
dtype object (not a string), and titles (if present) are preserved.

_zip_dtype(seqarrays, flatten=False)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Internal helper that begins construction of a combined dtype for a sequence of
arrays. When ``flatten=True`` the helper uses flattened field descriptions so
that nested single-field sub-dtypes are expanded appropriately.

Notes on behavior and compatibility
-----------------------------------
- Many helpers in this module handle nested/record dtypes; where relevant,
  behavior is documented per-function.
- Some helpers have both "record-oriented" variants (prefixed with ``rec_``)
  and plain structured-array variants. The rec-variants tend to preserve
  recarray behaviors and are convenient when working with NumPy recarrays.
- Several functions make use of masked-array helpers for handling missing data
  and fill values.

Examples
--------
Basic usage patterns:

- Inspecting/flattening a dtype:
.. code-block:: python

   import numpy as np
   from basics.indexing import get_names, get_names_flat, flatten_descr

   dt = np.dtype([('x', int), ('y', [('y1', float), ('y2', int)])])
   get_names(dt)        # -> ('x', ('y', ('y1', 'y2')))
   get_names_flat(dt)   # -> ('x', 'y', 'y1', 'y2')
   flatten_descr(dt)    # -> (('x', dtype('int64')), ('y1', dtype('float64')), ('y2', dtype('int64')))

- Filling output from input with nested fields:
.. code-block:: python

   import numpy as np
   from basics.indexing import recursive_fill_fields

   src = np.array([(1, (2, 3))], dtype=[('a', 'i4'), ('b', [('b1','i4'), ('b2','i4')])])
   dst = np.zeros(2, dtype=src.dtype)
   recursive_fill_fields(src, dst)
   # dst now contains the copied row in its beginning positions

Module-level notes
------------------
- Private helper names (leading underscore) are used for internal dtype
  construction and dispatch; public APIs are stable entry points for common
  structured-array operations.
- The module relies on NumPy dtypes and masked-array utilities for a consistent
  treatment of composite types and missing/fill values.

See also
--------
NumPy structured array and dtype documentation for details on dtype creation,
field offsets and subarray shapes: NumPy user guide and dtype API.