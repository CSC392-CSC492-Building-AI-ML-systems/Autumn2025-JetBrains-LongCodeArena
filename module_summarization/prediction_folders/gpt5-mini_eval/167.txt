Library Conventions
====================

This document describes the coding and documentation conventions used in the library.  These conventions are illustrated by examples taken from the codebase (modules such as dtime.py and optimal.py) and should be followed for all new code.

Module layout and metadata
--------------------------
- Each module begins with a short module-level docstring describing purpose and public routines.
- Modules typically include copyright, license, author and date metadata in the header.
- Modules declare public exports via an __all__ list containing symbol names exported by the module.
- Top-level module state for internal defaults or configuration is defined as module-level variables, often with a leading underscore (e.g., _optimal_defaults).

Imports and dependencies
------------------------
- Prefer explicit relative imports for intrapackage references (e.g., from .statesp import StateSpace).
- Third-party imports (numpy, scipy, control, etc.) are placed near the top of the module.
- Use module aliases where appropriate (import numpy as np, import scipy as sp).

Naming conventions
------------------
- Functions and module-level variables: snake_case (sample_system, c2d, _optimal_defaults).
- Classes: CamelCase (OptimalControlProblem, StateSpace).
- Private/internal names: start with a single leading underscore.
- Constants: module-level UPPER_SNAKE or descriptive names; small dictionaries of default parameters often use leading underscore.

Public API and exports
----------------------
- A module's public API is explicit: include exported names in __all__.
- Public functions and classes should have comprehensive docstrings describing behavior, parameters and return values.
- Keep internal helpers unexported (not listed in __all__) and prefixed with underscore.

Docstring and documentation style
--------------------------------
- Use NumPy/SciPy-style docstrings with the following sections as appropriate:
  - Short one-line summary.
  - Parameters: name, type, brief constraints/units and description.
  - Returns: name and type and description.
  - Notes: implementation notes and cross-references.
  - Examples: interactive >>> examples that demonstrate typical usage.
- Use Sphinx-friendly cross-references/roles where appropriate:
  - :class:`StateSpace`, :meth:`StateSpace.sample`, :mod:`~control.optimal`.
- Document valid ranges/units for numeric arguments (e.g., Ts : float > 0, prewarp_frequency : float within [0, infinity)).
- Keep examples concise and realistic.

Error handling and exceptions
-----------------------------
- Validate function inputs and raise ValueError or appropriate custom exceptions if preconditions are not met (e.g., if not isctime(sysc): raise ValueError(...)).
- Define and raise library-specific exceptions for domain-specific errors (e.g., ControlNotImplemented).
- Use clear, user-oriented error messages.

Configuration and defaults
--------------------------
- Central configuration/state may be provided via a config module.
- Module-level defaults are grouped in dictionaries when convenient (e.g., _optimal_defaults).
- Keys in configuration dictionaries are descriptive strings (e.g., 'optimal.minimize_method').

Logging and warnings
--------------------
- Use the standard logging module for informational, debug and error messages.
- Use the warnings module for user-facing deprecation or usage warnings.
- Do not print directly to stdout/stderr for operational messages.

Testing and examples
--------------------
- Provide small runnable examples in docstrings illustrating typical usage via >>> prompts.
- Prefer examples that can be executed in interactive sessions or doctest-based tests when helpful.

API behavior and compatibility
------------------------------
- Public functions and classes should be stable; breaking changes must be documented and versioned.
- Use explicit sampling/time semantics for control systems (e.g., continuous vs discrete time). Validate time-domain assumptions and report errors when misuse is detected.

Style and formatting
--------------------
- Follow PEP 8 for general Python style (indentation, line length, imports).
- Prefer clear, descriptive names for variables, functions and parameters.
- Keep functions focused and reasonably short; delegate complex behavior to well-documented methods on classes (e.g., StateSpace.sample).

Interfacing with SciPy and other libraries
------------------------------------------
- When wrapping or delegating to SciPy functions, document any parameter mapping or restrictions (e.g., methods accepted: 'zoh', 'bilinear', 'gbt'; parameters like alpha only valid with method='gbt').
- Where possible, mirror SciPy and control library conventions for argument names and units.

Contributing and authorship
---------------------------
- Add author and date metadata in the module header as shown in existing modules.
- Preserve license and copyright headers when copying or modifying code.

Copyright and license
---------------------
- Include the project's license header in source files and retain attribution and license text in redistributed source distributions.