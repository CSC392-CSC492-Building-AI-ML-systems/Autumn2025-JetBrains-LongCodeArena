Using metadata
==============

Overview
--------
Metadata provides a flexible key/value store attached to entities in ftrack. Use metadata to record custom, non-schema information such as external IDs, tool-specific settings, or workflow state that doesn't belong on the formal domain model.

Metadata is stored per-entity and may be treated as namespaced JSON values. Read and write operations are recorded on the session and persisted to the server when operations are committed.

Accessing metadata
------------------
Obtain an entity through the session, then use the entity metadata helpers to read, write and remove metadata. Typical steps:

- Retrieve the entity via the session.
- Read or update metadata using the entity metadata API.
- Commit the session to persist changes to the server.

Examples
--------
Minimal usage pattern:

.. code-block:: python

    import ftrack_api

    session = ftrack_api.Session(
        server_url='https://ftrack.example',
        api_key='MY_API_KEY',
        api_user='my_user'
    )

    # Retrieve an entity (example: Task)
    task = session.query('Task where id is "task-id"').first()

    # Read metadata (returns stored value or a default)
    value = task.get_meta('my_tool.some_key', default=None)

    # Set metadata (store JSON-serialisable data)
    task.set_meta('my_tool.some_key', {'version': 1, 'path': '/tmp'})

    # Remove metadata key
    task.remove_meta('my_tool.some_key')

    # Persist changes to the server
    session.commit()

Note: The exact helper names above represent common metadata operations. Use your installed ftrack_api package documentation for the precise method names available in your version.

Storing structured data
-----------------------
Metadata values should be JSON-serialisable (strings, numbers, booleans, lists, dictionaries). When storing structured data, prefer a clear namespacing convention for keys (for example, prefix keys with the tool or integration name) to avoid collisions with other users and integrations.

Namespacing example:

- my_tool.config
- pipeline.exporter.settings

Caching and performance
-----------------------
Metadata operations occur through the session and may involve network requests. To reduce round-trips:

- Group multiple metadata changes and call session.commit() once.
- Use entity-level helpers that operate on a batch of keys when available.
- Where possible, fetch entities with only required attributes to reduce payload size.

Concurrency and consistency
---------------------------
Multiple clients can modify metadata concurrently. To avoid overwriting changes unintentionally:

- Read-modify-write in a single logical flow and persist changes quickly.
- When reading metadata that will be updated by multiple clients, consider implementing optimistic checks (for example, include a version or timestamp field inside the metadata value).
- Be prepared to handle conflicts and retries at the application layer.

Best practices
--------------
- Use a consistent, human-readable key naming convention and namespace keys by tool or integration name.
- Keep metadata values compact; large blobs are harder to manage and transmit.
- Store only non-critical or non-relational information in metadata; core data should use the ftrack schema.
- Include a small schema or version tag inside complex metadata values to allow for migrations by your tooling.

Troubleshooting
---------------
- If changes do not appear on the server, ensure session.commit() has been called and that the session had sufficient permissions.
- For unexpected missing keys, confirm the namespace and key spelling, and verify that another client has not removed or overwritten the metadata.

Further reading
---------------
Refer to your installed ftrack_api package reference for the exact metadata API available in your version and for server-specific considerations (permissions, schema-driven alternatives, and API rate limits).