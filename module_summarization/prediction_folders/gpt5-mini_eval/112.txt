Metadata for plans module
=========================

Module summary
--------------
This module provides high-level scan plans for data acquisition: count, list_scan,
and a placeholder for rel_list_scan. Each plan builds and annotates a metadata
dictionary (_md) describing detectors, motors, plan arguments, and hints, then
yields messages using preprocessing and plan stub utilities (bpp and bps).
The plans expect "readable" detector objects and "settable" motor-like objects
with .name and optional .hints/fields attributes.

Common behavior
---------------
- Plans construct a metadata dict `_md` with keys such as:
  - detectors: list of detector names
  - motors: list of motor names (when applicable)
  - num_points: number of planned points
  - num_intervals: num_points - 1 or None
  - plan_args: repr-style serialization of inputs
  - plan_name: string identifying the plan (e.g., 'count', 'list_scan')
  - plan_pattern / plan_pattern_module / plan_pattern_args: for pattern-based scans
  - hints: mapping used by downstream consumers; includes dimensions when available

- Plans use:
  - preprocessors (bpp) decorators: stage_decorator and run_decorator
  - plan stubs (bps) such as one_shot and repeat for core message generation
  - plan_patterns to construct cyclers for N-D scans (inner list product pattern)

Functions
---------

count
~~~~~
Signature:
    count(detectors, num=1, delay=None, *, per_shot=None, md=None)

Description:
    Take one or more readings from detectors.

Parameters:
- detectors: iterable of readable objects (each must expose .name)
- num: int or None, number of readings to take (None => capture until canceled). Default 1.
- delay: scalar or iterable, time delay(s) between successive readings.
- per_shot: optional callable hook customizing the inner loop behavior.
            Expected to be compatible with bps.one_shot: callable(detectors) -> generator of Msg.
- md: optional dict of metadata to merge into the automatically constructed metadata.

Returns:
    Generator-based plan (yield-from) that stages devices, runs, and repeats per_shot
    num times with the given delay.

Notes:
- If `delay` is an iterable, it must provide at least `num - 1` entries or iteration
  will raise ValueError.
- Default per_shot is bps.one_shot.
- Constructed _md example keys:
  - 'detectors', 'num_points', 'num_intervals', 'plan_args', 'plan_name', 'hints'.
- The run decorator receives md=_md.

list_scan
~~~~~~~~~
Signature:
    list_scan(detectors, *args, per_step=None, md=None)

Description:
    Scan over one or more variables in steps simultaneously (inner product).
    Accepts pairs of (motor, positions_iterable) for each dimension.

Parameters:
- detectors: iterable of readable objects
- *args: sequence of motor, positions_list pairs:
    motor1, [p1, p2, ...], motor2, [q1, q2, ...], ...
  All position lists must have the same length.
- per_step: optional callable hook used for each step:
    Expected signature: f(detectors, motor, step) -> plan (generator)
- md: optional dict of metadata to merge into the automatically constructed metadata.

Behavior and validations:
- Raises ValueError if the number of args is odd (must be pairs) or if the lengths
  of position lists differ.
- Internally:
  - Validates and collects motor names and position lists.
  - Constructs md_args (repr of motors and their position lists).
  - Builds a full_cycler via plan_patterns.inner_list_product(args).
  - Sets default hints based on motor .hints.fields if available and populates
    _md['hints']['dimensions'] accordingly.
  - Delegates final execution to scan_nd(detectors, full_cycler, per_step=per_step, md=_md).

Constructed _md fields (examples):
- 'detectors', 'motors', 'num_points', 'num_intervals',
  'plan_args' (contains repr of detectors, args, per_step),
  'plan_name': 'list_scan',
  'plan_pattern': 'inner_list_product',
  'plan_pattern_module': plan_patterns.__name__,
  'plan_pattern_args': dict(args=md_args),
  'hints' (may include dimensions derived from motor fields).

rel_list_scan
~~~~~~~~~~~~~
Signature:
    rel_list_scan(detectors, *args, per_step=None, md=None)

Description:
    Intended to scan over one or more variables in steps relative to current positions.
    API mirrors list_scan but position lists are interpreted as offsets relative to
    current motor position.

Status:
    Placeholder / TODO â€” not implemented in this source. Behavior and metadata
    construction are expected to be similar to list_scan, but operating on
    relative position offsets.

Errors and exceptions
---------------------
- ValueError: raised by list_scan if args length is odd or if position lists differ in length.
- ValueError: count may raise ValueError during iteration if `delay` is an iterable shorter
  than `num - 1`.

Dependencies and integration notes
---------------------------------
- Relies on bpp (preprocessors) and bps (plan stubs) to produce properly staged and
  instrumented plan message sequences.
- Uses plan_patterns to build N-D cyclers for list_scan.
- Plans return generators suitable for execution by a RunEngine-like driver that
  understands the generated Msg stream and the supplied metadata.

Examples
--------
- Count once from detectors A and B:
  - plan: count([A, B])

- List scan two motors with three points each:
  - plan: list_scan([D], motor1, [0, 1, 2], motor2, [10, 20, 30])

(End of metadata.rst)