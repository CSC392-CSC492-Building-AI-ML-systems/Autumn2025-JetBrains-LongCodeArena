QuerySet — Building Queries
==========================

Overview
--------
A QuerySet is the primary API for constructing and executing database queries. It is built on top of a SQL query builder and composes filters, joins, annotations, ordering and other modifiers into a single SQL statement. QuerySets are lazy — the SQL is built only when the QuerySet is evaluated (e.g. awaited, iterated, or cast to list).

Awaiting for single results
---------------------------
Some QuerySet-like objects are awaitable to return a single model instance. Awaiting a QuerySetSingle resolves one model instance:

- Awaitable behavior: ``__await__`` resolves to a single model object.
- Available on single-result helpers (e.g. ``get()``, ``first()``-like single-instance wrappers).
- QuerySetSingle supports the same common query-building methods: ``prefetch_related``, ``annotate``, ``only``, ``values_list``, ``values``.

Filtering and Q objects
-----------------------
Filters are built from expression objects (``Q``) and pre-resolved custom filters. The QuerySet combines multiple ``Q`` objects using a QueryModifier which produces:

- WHERE criteria
- JOINs required for related-field filters
- HAVING criteria for aggregate filters

Joins inferred for related-field filters are appended to the query and tracked to avoid duplicate joins. All inferred joins use left-outer semantics.

Annotations and Aggregates
--------------------------
You can add computed/aggregated values with ``annotate``. Annotated functions are stored and resolved when building the query.

Important effects of annotations:
- Aggregates can introduce HAVING clauses.
- If there are aggregates and the query has any joins, HAVING clauses, or ORDER BYs, the QuerySet will automatically add a GROUP BY on the model primary key to produce correct SQL grouping.

Annotations that should be usable for ordering must expose the field/expression used for ordering when resolved.

Ordering
--------
Ordering supports:

- Simple fields: ``"field"`` (ascending) or ``"-field"`` (descending).
- Related fields by nesting with double-underscore notation: ``"related__nested_field"``.
- Annotation names: you can order by an annotated value.

Rules and behaviors:
- A leading ``-`` indicates descending order; otherwise ascending is used.
- Ordering by a relation name (a fetch field) alone is not allowed — order by a nested field on the related model instead. Attempting to order by a relation will raise a FieldError.
- When ordering by a nested related field, the QuerySet will join the related table(s) as needed and apply the ordering to the related column/expression.
- If no explicit ordering is provided on a QuerySet and annotations are not present, the model's default ``Meta.ordering`` is applied automatically.

Joining related fields
----------------------
When filters or ordering reference related fields, QuerySet will:

- Resolve the chain of required joins for the related field.
- Add left-outer joins to the query builder for each required table, tracking added joins to avoid duplicates.
- Continue resolving filters or ordering on the related model/table recursively.

Query builder details
---------------------
The QuerySet uses an underlying SQL builder object (``QueryBuilder``) and ``pypika.Table`` instances to represent virtual SQL tables. Internal state tracked during query building includes:

- ``_joined_tables``: list of tables already joined into the query
- ``_wheres`` / ``_havings``: WHERE and HAVING criteria produced by the QueryModifier
- ``_orderbys``: ORDER BY expressions appended to the builder

Prefetching and selecting
-------------------------
Common methods available on QuerySets and QuerySetSingle:

- ``prefetch_related(*args)`` — fetch related objects in separate queries and attach them to the parent instances (useful for many-to-many and many-to-one relationships).
- ``only(*fields)`` — restricts selected columns to the given fields.
- ``values(*fields)`` — returns dictionaries of specified fields (and annotated fields).
- ``values_list(*fields, flat=False)`` — returns tuples (or flat values for a single field with ``flat=True``).

Errors and validation
---------------------
- FieldError is raised for attempts to filter or order by an unsupported or unknown field name, or for trying to order by a relation name directly.
- Other query-time exceptions (e.g. integrity/params errors) are raised when executing the SQL.

Examples
--------
Basic filtering and ordering:
```
users = User.filter(is_active=True).order_by("-created_at")
```

Filtering and ordering on related fields:
```
# Order users by their profile's score (profile is a related model)
users = User.order_by("profile__score")
```

Annotate and order by aggregate:
```
from pypika.functions import Count

qs = Blog.annotate(comment_count=Count("comments__id")).order_by("-comment_count")
# When annotation introduces aggregate semantics, a GROUP BY on Blog PK will be added if needed.
```

Selecting fields and values:
```
qs = User.filter(is_active=True).only("id", "username")
values = await qs.values("id", "username")
ids = await qs.values_list("id", flat=True)
```

Notes
-----
- QuerySets are lazy; building operations return a new QuerySet-like object until evaluation.
- Related-field references use double-underscore ``__`` to traverse relations.
- Annotated fields must provide resolvable expressions so they can be used in ORDER BY or HAVING clauses.