Alchemical transformations
=========================

Overview
--------
This document describes the alchemical transformation model and options used to construct hybrid systems for relative alchemical calculations. The framework partitions atoms and interactions into classes that are scaled with a coupling parameter (``lambda``) to turn interactions on or off and to morph between two chemical endstates.

Atom classes and lambda behavior
-------------------------------
Atoms in the hybrid system belong to one of four classes:

- ``unique_old``  
  Atoms present only in the old (disappearing) topology. Their interactions are fully present at ``lambda=0`` and are turned off at ``lambda=1``.
- ``unique_new``  
  Atoms present only in the new (appearing) topology. Their interactions are off at ``lambda=0`` and become fully present at ``lambda=1``.
- ``core``  
  Mapped atoms that belong to residues undergoing chemical transformation. Core atoms interpolate between old and new interactions: old at ``lambda=0`` and new at ``lambda=1``.
- ``environment``  
  Mapped atoms outside the transforming region. Their interactions are unaffected by alchemical scaling and remain fully present for all ``lambda``.

Primary hybrid-system objects
-----------------------------
The hybrid representation exposes the usual artifacts required for simulation and analysis:

- ``hybrid_system`` — an OpenMM ``System`` describing forces and parameters for the hybrid topology.
- ``hybrid_topology`` / ``omm_hybrid_topology`` — topology representations (mdtraj/OpenMM).
- ``hybrid_positions`` — positions array for the hybrid system.
- ``new_to_hybrid_atom_map`` / ``old_to_hybrid_atom_map`` — integer maps from original-system atom indices to hybrid-system atom indices.

Lambda functions and parameterization
-------------------------------------
Scaling of each interaction type is controlled by a set of lambda-dependent functions. These functions are provided as a dictionary keyed by strings beginning with ``lambda_`` and ending with the interaction name (for example ``lambda_bonds``, ``lambda_angles``, ``lambda_torsions``, ``lambda_sterics``, ``lambda_electrostatics``). If the functions dictionary is not provided, the integrator is expected to supply/drive the lambdas; in that case parameter derivatives are not available.

Softcore potentials and electrostatics
-------------------------------------
Softcore potentials are used to avoid singularities during creation/destruction of nonbonded sites:

- ``softcore_LJ_v2`` (default True) implements the LJ v2 softcore functional form (Gapsys et al., JCTC 2012) and uses parameter ``softcore_LJ_v2_alpha`` (default 0.85).
- ``softcore_electrostatics`` (default True) enables softening of electrostatics with parameter ``softcore_electrostatics_alpha`` (default 0.3) and a ``softcore_sigma_Q`` parameter (default 1.0).
- If ``softcore_alpha`` is not provided, an internal default (e.g., 0.5) is used for steric softening.

Bond, angle and torsion handling
--------------------------------
- Bonds and angles involving unique (appearing/disappearing) atoms are often softened at the dummy endpoint. Softening constants are exposed via ``bond_softening_constant`` and ``angle_softening_constant`` (default 1.0 means no softening).
- ``neglected_new_angle_terms`` / ``neglected_old_angle_terms``: lists of angle indices that geometry generation neglected and therefore must be annealed in/out explicitly over lambda.
- ``flatten_torsions``: when True, torsion terms involving ``unique_new`` atoms are scaled so that they are effectively off at the appropriate endstate (and vice versa for ``unique_old``).

Exceptions and 1–4 interactions
------------------------------
- The framework can optionally interpolate (turn off/on) exceptions (including 1–4 interactions) between old and new states using ``interpolate_old_and_new_14s``. If False, these exceptions remain in the nonbonded force and are not separately turned on/off.

Omitted / annealed terms
------------------------
- ``omitted_terms`` is a mapping (by new topology index) of terms which must be explicitly annealed in or out during the alchemical protocol. These terms are treated as alchemical degrees of freedom and are scheduled by lambda.

Other options
-------------
- ``use_dispersion_correction``: include long-range dispersion correction in sterics (expensive for NCMC).
- ``soften_only_new``: apply softening only to new atoms (forward direction).
- ``rmsd_restraint``: if True, impose an RMSD restraint between core heavy atoms and protein Cα atoms.
- ``endstate``: for this hybrid topology factory this must be ``None``. (A partitioned/repartitioned factory may accept a fixed endstate of 0 or 1.)

Supported force types
---------------------
The implementation recognizes and handles a set of common OpenMM force classes, including (but not necessarily limited to):

- HarmonicBondForce
- HarmonicAngleForce
- PeriodicTorsionForce
- NonbondedForce
- MonteCarloBarostat

Implementation notes and caveats
-------------------------------
- Atom-class assignments determine how each force and parameter set is scaled with lambda; interactions involving environment atoms are not alchemically modified.
- When the user does not provide explicit lambda functions, an external integrator which defines the lambda schedule must supply them. In that case per-parameter derivatives may not be available.
- Some geometry terms may be omitted by the geometry engine and must be explicitly provided via the neglected/omitted lists to avoid structural instability during alchemical switching.
- The API and behavior are experimental and may change.

References
----------
- Gapsys, V., Seeliger, D., & de Groot, B. L. (2012). New soft-core potential function for molecular dynamics based alchemical free energy calculations. Journal of Chemical Theory and Computation, 8(7), 2373–2382.

Warning
-------
This alchemical topology construction API is experimental and subject to change.