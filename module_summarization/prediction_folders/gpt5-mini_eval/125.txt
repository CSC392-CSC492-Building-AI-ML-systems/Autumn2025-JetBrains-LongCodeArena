Headers
=======

This document describes FITS header verification and notification behavior used
by the header-related classes.

Overview
--------

FITS header objects perform checks on the contents of header cards and can
optionally attempt to fix issues. Verification produces structured messages
about problems found; fixable issues can be corrected automatically depending
on the selected verification option.

Verification exceptions and warnings
-----------------------------------

Two helper classes are used to report verification outcomes:

- VerifyError
  - Exception raised when verification finds (and is configured to report)
    errors that are not handled by a warning/reporting option.
- VerifyWarning
  - Warning class (subclass of astropy.utils.exceptions.AstropyUserWarning)
    used to emit non-exception verification messages.

VERIFY_OPTIONS
--------------

The valid verification option strings are:

- "ignore", "warn", "exception", "fix", "silentfix"
- Composite forms that combine fixing with a reporting action:
  "fix+ignore", "fix+warn", "fix+exception",
  "silentfix+ignore", "silentfix+warn", "silentfix+exception"

These options control two independent behaviors:
- whether fixable issues should be fixed ("fix" or "silentfix"),
- how remaining or unfixable issues are reported ("ignore", "warn",
  "exception").

Behavior of Header.verify
-------------------------

The verification machinery implements the above semantics:

- An option string is normalized to lowercase and must be one of VERIFY_OPTIONS.
- If the option is "ignore" verification returns immediately with no output.
- The option is split (where appropriate) into a "fix" portion and a
  "report" portion. For historical compatibility:
  - "fix" and "silentfix" alone behave as if they were "fix+exception" and
    "silentfix+exception" respectively (i.e. unfixable errors raise).
- "silentfix+ignore" fixes fixable issues and returns without reporting.
- "silentfix" suppresses reporting of fixed issues; only unfixable issues are
  considered for reporting.
- The routine collects verification messages and then:
  - Emits warnings via VerifyWarning when configured to "warn" (or when
    "fix" fixed all issues and reporting is configured as "warn").
  - Raises VerifyError with a combined message when reporting is "exception"
    (or when an unfixable issue should be escalated).

Note: verification messages include a top-line "Verification reported errors:"
and a trailing note that astropy.io.fits uses zero-based indexing.

Running and customizing verification
------------------------------------

Verification is performed by calling a verify(option="warn")-style method on
the header (or a header-containing object). The underlying implementation
provides a helper method run_option(option, err_text, fix_text, fix, fixable)
which:

- Accepts:
  - option: the normalized verify option,
  - err_text: the base error text for this particular check,
  - fix_text: appended text when the value is fixed,
  - fix: an optional callable to apply a fix,
  - fixable: a boolean indicating whether the issue is fixable.
- Respects the requested option and either:
  - does nothing (for "ignore" or "warn"/"exception" where no fix is attempted),
  - attempts the fix callable and appends fix_text for fixable cases when
    a fixing option is in effect,
  - or marks the issue as unfixable.

The helper returns a tuple (fixable, message) used by the overall verification
collector.

Verification message structure: _ErrList
---------------------------------------

Verification messages are collected in instances of the internal _ErrList
class. Key points:

- _ErrList subclasses list and stores a hierarchical (nested) structure of
  messages produced by verification steps at different class/element levels.
- Each non-_ErrList entry typically is a tuple (fixable, message).
- The unit attribute (default "Element") describes the header element label
  used when printing nested groups.
- iter_lines(filter=None, shift=0) yields (fixable, indented_message) tuples
  flattening the nested structure. The shift parameter controls indentation
  level for nested items.
- __str__() concatenates the iter_lines() messages into a single string.
- The nested-iteration logic prints top-level messages first, then iterates
  into nested items and prints a header like "Element N:" for each nested
  element that contains messages.

NotifierMixin: header change notifications
-----------------------------------------

Header-containing objects may mix in NotifierMixin to allow listeners to be
registered and notified when the object changes:

- _add_listener(listener): register a listener (stored as a weak reference).
  If the listener object is garbage-collected, it is automatically dropped.
- _notify(change_type, *args, **kwargs): call update methods on listeners.
  For change_type "foo" this attempts to call listener._update_foo(*args,
  **kwargs) on each registered listener. Listeners that do not implement the
  specific update method are ignored.

This mechanism is intended for internal communication between objects where
headers or header-like containers need to inform other objects of updates.

Examples
--------

Basic verification usage:

.. code-block:: python

   # Verify with warnings (default)
   header.verify("warn")

   # Attempt to fix fixable issues and warn about results
   header.verify("fix+warn")

   # Fix silently and ignore any reporting
   header.verify("silentfix+ignore")

Handling verification programmatically:

.. code-block:: python

   try:
       header.verify("fix")
   except VerifyError as e:
       # inspect or log the combined verification message
       print(str(e))

   # Inspect a collected ErrList (hypothetical API)
   errs = header._collect_verification_errors()
   print(str(errs))  # multiline, indented text of messages

Notes
-----

- Verification routines report positions and indices using zero-based indexing.
- The VerifyWarning class groups verification messages as warnings; depending
  on the chosen verification option these may instead become exceptions.
- The notification API uses weak references for listeners so no manual removal
  is required in most cases.