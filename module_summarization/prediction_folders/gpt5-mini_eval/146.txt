Quick start
===========

Overview
--------
Topological and time-optimal path-parameterization algorithms in toppra operate on geometric paths â€” objects that provide position, first- and second-order derivatives along a 1D path variable. toppra provides a small helper API for creating and sampling such paths and for proposing a discretization (gridpoints) suitable for downstream algorithms.

This quick start covers:
- the AbstractGeometricPath interface you must implement for custom paths,
- the propose_gridpoints utility to generate a discretization that respects curvature,
- the RaveTrajectoryWrapper for wrapping OpenRAVE trajectories (if OpenRAVE is available).

AbstractGeometricPath
---------------------
A geometric path must implement the AbstractGeometricPath interface:

- __call__(path_positions, order=0) -> np.ndarray
  - path_positions: float or np.ndarray of path parameter(s) s.
  - order: 0 for position, 1 for first derivative, 2 for second derivative.
  - returns joint positions/derivatives. For vector-valued paths, shape is (n_points, dof) for array inputs.

- dof (property): integer degrees of freedom of the path.

- path_interval (property): length-2 array-like giving the start and end path parameter, e.g. [s0, s1].

- waypoints (optional property): either (s_values, q_values) or None.

Minimal example of a custom geometric path
::
    import numpy as np
    from toppra.interpolator import AbstractGeometricPath  # (illustrative import)

    class LinearPath(AbstractGeometricPath):
        def __init__(self, q0, q1, s0=0.0, s1=1.0):
            self._q0 = np.asarray(q0)
            self._q1 = np.asarray(q1)
            self._s0 = s0
            self._s1 = s1
            self._dof = self._q0.size

        def __call__(self, s, order=0):
            s = np.asarray(s)
            t = (s - self._s0) / (self._s1 - self._s0)
            if order == 0:
                return (1 - t)[..., None] * self._q0 + t[..., None] * self._q1
            elif order == 1:
                return ((self._q1 - self._q0) / (self._s1 - self._s0))[None, :]
            elif order == 2:
                return np.zeros((1, self._dof))
            raise ValueError("Unsupported order")

        @property
        def dof(self):
            return self._dof

        @property
        def path_interval(self):
            return np.array([self._s0, self._s1])

Proposing gridpoints
--------------------
propose_gridpoints(path, max_err_threshold=1e-4, max_iteration=100, max_seg_length=0.05)

This helper builds a set of path parameter gridpoints that sufficiently approximate the path by adaptively subdividing segments. The worst-case estimated interpolation error on a segment is computed as

.. math::
    err_{est} = 0.5 \\times \\max( | p''(s_{mid}) | \\times d_{segment}^2 )

where p'' is the second derivative (w.r.t. the path parameter) and d_segment is the length of the segment in s. Segments are split until the estimated error is below max_err_threshold or max_seg_length is satisfied. If the routine cannot converge within max_iteration it raises ValueError.

Parameters
- path: an AbstractGeometricPath instance
- max_err_threshold: maximum allowed worst-case interpolation error (float)
- max_iteration: maximum refinement iterations
- max_seg_length: maximum allowed segment length in the path parameter

Returns
- gridpoints_ept: 1D np.ndarray of proposed s gridpoints (ascending)

Usage example
::
    from toppra.utils import propose_gridpoints
    path = LinearPath([0,0], [1,1])
    grid = propose_gridpoints(path, max_err_threshold=1e-5, max_seg_length=0.01)

OpenRAVE trajectories: RaveTrajectoryWrapper
-------------------------------------------
If OpenRAVE is available, toppra includes a wrapper that converts an OpenRAVE GenericTrajectory into an AbstractGeometricPath:

- class: RaveTrajectoryWrapper(traj, robot)
  - traj: an OpenRAVE trajectory object
  - robot: the OpenRAVE robot that trajectory applies to

Supported interpolation types: "quadratic" and "cubic" only. The wrapper exposes:
- __call__(s, order): evaluate position/derivatives on the trajectory parameterized over [0, duration].
- dof: number of active DOFs.
- path_interval: [0, duration] of the input trajectory.
- ss_waypoints: array of cumulative times (s) for the trajectory waypoints.

Example (when OpenRAVE is installed)
::
    # traj: an openravepy.RaveTrajectory
    # robot: an openravepy.Robot
    wrapper = RaveTrajectoryWrapper(traj, robot)
    grid = propose_gridpoints(wrapper, max_err_threshold=1e-6)

Notes and tips
--------------
- The propose_gridpoints heuristic uses the path's second derivative; ensure your path correctly implements order=2 evaluations.
- Choose max_err_threshold and max_seg_length based on the acceptable discretization error for downstream algorithms (smaller thresholds produce finer grids).
- RaveTrajectoryWrapper will raise if the trajectory interpolation is not quadratic or cubic.