diophantine module
==================

Overview
--------
The diophantine module provides a single user-facing routine diophantine(eq, param=None, syms=None)
for finding parametric integer solutions of polynomial Diophantine equations. The routine accepts
either a SymPy relational (Eq) or an expression and returns a set of solution tuples. Each tuple
contains expressions for the variables ordered alphabetically (unless a custom ordering is given
via the syms parameter). The module relies on internal helpers and on external routines such as
classify_diop and diop_solve to classify and solve specific Diophantine types.

Public API
----------
diophantine(eq, param=symbols('t', integer=True), syms=None)
    Solve the polynomial Diophantine equation `eq` and return a set of solution tuples.

    Parameters
    - eq : Expr or Eq
        The equation to be solved. If an Eq is provided it is converted to lhs - rhs.
        The expression must represent a polynomial with rational coefficients (polynomial
        in a finite set of symbols).
    - param : Symbol, optional
        A symbol used as the default free integer parameter in parametric solutions.
        By default a symbol named t (integer=True) is used.
    - syms : sequence of Symbol, optional
        An optional list specifying which variables to return and the order of elements in
        the returned tuples. If provided it must be a sequence (e.g. a list) and its
        elements are taken from the variables occurring in the equation.

    Returns
    - set of tuples
        Each element of the returned set is a tuple (one tuple per solution family).
        The tuple entries correspond to solutions for the equation's variables in
        alphabetic order (or in the order given by syms when provided). Components of
        tuples are SymPy expressions (often linear combinations of integer parameters).

    Behavior and algorithmic notes
    - Accepts an Eq or an expression; Eq is converted to a polynomial expression by
      subtracting rhs from lhs. Non-polynomial input (or polynomials with non-rational
      coefficients) raise TypeError.
    - If the expression equals 0 identically, a trivial solution with the parameter alone
      is returned.
    - Numerator/denominator handling: the routine considers the numerator of a rational
      expression; if the denominator contains symbols it will solve the denominator and
      remove solutions that make the denominator zero.
    - Factorization and term splitting: the expression is factorized into multiplicative
      factors with multiplicities (factor_list). Each factor is solved independently
      and solutions are combined (Cartesian-like merge) to generate global solutions.
    - Classification: for each factor the module uses classify_diop to determine the
      equation type and variables for that factor. Known equation types influence whether
      factoring is attempted and how solutions are merged.
    - For some types (e.g. general_sum_of_squares) factoring may be skipped to avoid
      expensive factorization; in such cases the factor is treated as a single term.
    - Solution merging: solutions returned by diop_solve for a factor are merged into
      full-variable solutions using the factor's variable list and the complete variable
      ordering for the original equation.

    Supported / known equation types
    - The module recognizes (and/or delegates) a number of Diophantine equation types:
      binary_quadratic, cubic_thue, general_pythagorean, general_sum_of_even_powers,
      general_sum_of_squares, homogeneous_general_quadratic,
      homogeneous_ternary_quadratic, homogeneous_ternary_quadratic_normal,
      inhomogeneous_general_quadratic, inhomogeneous_ternary_quadratic,
      linear, univariate
    - Handling in diophantine explicitly supports several of these classes when used in
      factorized form; others are delegated to classify_diop and diop_solve which may
      implement problem-specific solvers.

    Exceptions
    - TypeError is raised if the input is not a polynomial with rational coefficients,
      if syms is not a sequence when provided, or when required classification fails.
    - NotImplementedError is raised if a recognized factor type is not handled by the
      merge logic in this module (i.e. an unhandled eq_type).

    Edge cases
    - If no nontrivial solution is found but the all-zero assignment satisfies the polynomial
      equation, the all-zero tuple is returned as the trivial solution.
    - Denominator roots are excluded from solutions when factors of the denominator are
      found that would make a candidate solution invalid.

Examples
--------
>>> diophantine(x**2 - y**2)
{(t_0, -t_0), (t_0, t_0)}

>>> diophantine(x*(2*x + 3*y - z))
{(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}

>>> diophantine(x**2 + 3*x*y + 4*x)
{(0, n1), (3*t_0 - 4, -t_0)}

Related functions and modules
-----------------------------
- classify_diop(expr, ...) : classify a polynomial Diophantine expression,
  returning its variable list and type (used heavily by diophantine).
- diop_solve(expr, param) : solve a single classified factor (returns parameterized
  integer solutions for the factor's variables).
- factor_list, signsimp, factor_terms, as_numer_denom : factorization and
  simplification helpers used prior to classification and solving.

Internal helpers
----------------
Several small internal utility functions are used by the implementation:
- _is_int(i) : checks if an object can be converted to an integer.
- _sorted_tuple(*i) : returns a sorted tuple of the inputs.
- _remove_gcd(*x) : divide input integers by their greatest common divisor.
- _rational_pq(a, b) : return numerator, denominator pair for a/b with sign
  normalized on the numerator and gcd removed.
- _nint_or_floor(p, q) : returns the nearest integer to p/q, ties resolved by floor.
- _odd(i), _even(i) : parity tests.

Notes and limitations
---------------------
- diophantine expects polynomial inputs with rational coefficients; symbolic or transcendental
  non-polynomial constructs are not supported by this routine.
- The routine depends on properly implemented classify_diop and diop_solve functions for
  complete coverage of Diophantine problem types; unsupported types may raise NotImplementedError.
- Factorization can be expensive; for particular recognized classes (e.g. general_sum_of_squares)
  factorization may be suppressed to prevent pathological behavior.

Acknowledgements
----------------
This module integrates combinatorial factor-based solving with specialized Diophantine solvers
(via classify_diop and diop_solve) to produce parametric integer solution sets for polynomial
Diophantine equations.