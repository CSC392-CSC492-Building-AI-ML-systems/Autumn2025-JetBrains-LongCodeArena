Connecting Steps Together
=========================

Overview
--------
Steps expose named inputs and outputs through their configuration. Connections between steps are made using handles (lightweight descriptors of a step endpoint) or Edge objects. The Graph object (see graph API) accepts these handles or Edge instances to create edges in the build graph.

Handles
-------
A handle is a tuple describing a particular step endpoint:
(step_name, 'inputs'|'outputs', filename)

Obtain handles from a Step instance using:

- get_input_handle(name) — returns the input handle for the given input name (asserts that the input exists).
- get_output_handle(name) — returns the output handle for the given output name (asserts that the output exists).

Convenience shorthands:
- i(name) — same as get_input_handle(name)
- o(name) — same as get_output_handle(name)

Examples:

.. code-block:: python

  # explicit
  src_h = src_step.get_output_handle('results.txt')
  dst_h = dst_step.get_input_handle('data.txt')

  # shorthand
  src_h = src_step.o('results.txt')
  dst_h = dst_step.i('data.txt')

Edge objects
------------
An Edge encapsulates a single connection between a source handle and a destination handle:

- Edge(src, dst)
- src and dst are handles (or other objects accepted by your Graph API)

Accessors:
- get_src() -> src handle
- get_dst() -> dst handle

Connecting via Graph
--------------------
The Graph.connect method accepts handles or Edge objects to create connections between steps. Typical usage patterns:

.. code-block:: python

  # connect with handles
  graph.connect( src_step.o('out.txt'), dst_step.i('in.txt') )

  # connect with an Edge instance
  e = Edge( src_step.o('out.txt'), dst_step.i('in.txt') )
  graph.connect( e )

Working with multiple handles
-----------------------------
Get all handles exposed by a Step:

- all_input_handles()  — list of all input handles (empty list if no inputs)
- all_output_handles() — list of all output handles (empty list if no outputs)

Typical patterns:

.. code-block:: python

  # connect every output of A to a named input of B if names match
  for out_h in a_step.all_output_handles():
      name = out_h[2]                      # filename/name carried in the handle
      if name in b_step._config.get('inputs', []):
          graph.connect( out_h, b_step.i(name) )

Extending step interfaces and commands
--------------------------------------
Steps can be modified programmatically before connecting:

- extend_inputs(new_list)   — add names to the step's input list
- extend_outputs(new_list)  — add names to the step's output list

Command insertion:
- pre_extend_commands(new_list) — insert commands before existing commands
- extend_commands(new_list)     — append commands after existing commands

Cloning steps
-------------
Use clone() to create an independent copy of a Step (deep-copies configuration) when the same step template is instantiated multiple times in a build:

.. code-block:: python

  inst = original_step.clone()
  # inst has its own _config and step_dir copied from original

Notes and error conditions
--------------------------
- get_input_handle and get_output_handle assert that the requested name exists; use extend_inputs/extend_outputs to add names first if needed.
- Output YAML may contain tagged/aliased outputs; Step normalizes them and exposes the basename as the handle name while preserving the full source path in the configuration.
- If a step's commands are empty or missing, they are normalized to a no-op command (['true']) so the step remains well-formed.