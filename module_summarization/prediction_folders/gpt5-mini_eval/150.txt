# Supporting data to plotting functions in multiple ways

This document describes the PlotData helper used to flexibly provide supporting data to plotting functions. PlotData lets plotting code accept dictionaries, pandas DataFrames (and optionally Bokeh ColumnDataSource objects) and treat single or multiple plot sets uniformly. It transparently expands list-valued column specifications into multiple plot sets and provides an easy iterator interface that yields per-set named tuples of data keys.

Key features
- Accepts dict, pandas.DataFrame and (if Bokeh is installed) bokeh.models.ColumnDataSource as input data containers.
- Accepts a single data source or a list of data sources.
- Accepts column specifications as keyword arguments (e.g. x='energy', y='intensity').
- If any column specification is a list, PlotData expands into multiple plot sets (one per list-entry) and iterates over them.
- Performs checks for mismatched lengths between data and expanded column lists, raising errors when inconsistent.
- Optional behaviors:
  - same_length: normalize/check that dict entries have matching lengths across keys.
  - copy_data: shallow-copy the provided data containers (with special copying for ColumnDataSource).
  - strict_data_keys: disallow adding new data keys after construction.

Availability of Bokeh
- If Bokeh is installed the class recognizes and can copy ColumnDataSource objects. If not installed, ColumnDataSource support is disabled and the code treats only dict/DataFrame.

Quick usage
- Single set:
  - p = PlotData(data, x='x', y='y')
  - for entry in p: use entry.x and entry.y for plotting.
- Multiple sets (list expansion):
  - p = PlotData(data, x='x', y=['y1', 'y2', 'y3'])
  - Iteration produces three entries with the same x and y taking values 'y1', 'y2', 'y3'.
- Multiple data sources:
  - If data is a list of containers, PlotData will match the number of containers with the number of sets produced by list arguments; lengths must match.

Constructor and parameters
- PlotData(data, use_column_source=False, same_length=False, strict_data_keys=False, copy_data=False, **kwargs)
  - data: dict, pandas.DataFrame, (or ColumnDataSource if available). Can also be a list of such containers.
  - use_column_source: stored flag (kept for plotting backends that might want ColumnDataSource); the class records but does not require conversion here.
  - same_length: if True and a dict source is used, dict entries are normalized/checked so that all columns have the same length.
  - strict_data_keys: if True, new data keys cannot be added after initialization.
  - copy_data: if True the data containers are shallow-copied; ColumnDataSource objects are copied via their data dictionary.
  - **kwargs: column specifications — names become fields of the returned namedtuple. Each value may be:
    - a single key (string) used to index into data containers; or
    - a list of keys — if any kwarg is a list, PlotData expands into multiple sets. Non-list kwargs are broadcast to the number of sets.

Behavioral rules and error conditions
- Allowed data holder types: dict and pandas.DataFrame. If Bokeh is present, ColumnDataSource is allowed.
- If data is a list, its length must equal the number of expanded sets (num_sets). If it does not, a ValueError is raised.
- If one kwarg is a list and others are not, non-list kwargs are repeated across all sets (broadcasting).
- If copy_data is requested, each source is copied (ColumnDataSource objects receive a proper copy of their .data).
- If same_length=True and dict sources are used, all dict entries will be normalized/checked so keys have consistent lengths (internal normalization routine).
- If strict_data_keys=True, add_data_key will raise an error.

Iterator and returned entries
- A namedtuple type Columns is created from the kwargs names. Iterating PlotData yields one namedtuple per set.
- Each namedtuple contains fields corresponding to kwargs; each field contains the key/index name as specified (i.e. the identifier used to select data from the underlying source).
- Typical plotting code constructs arrays by indexing into the data source using the keys returned in each namedtuple entry.

Properties and helper methods
- data_keys: returns the tuple of registered data key names (the namedtuple field names).
- add_data_key(data_key, keys=None):
  - Adds a new data key name to the set of column names (i.e. extends the namedtuple).
  - If strict_data_keys was set at init time, this will raise an error.
  - keys can be used to initialize the values for the new column (single index or list matching number of sets); if omitted the new key is created empty for later assignment.
  - Adding a key updates the Columns namedtuple to include the new field.

Internal utilities
- The implementation includes small helpers:
  - _is_bokeh_cds(data): detects a ColumnDataSource if Bokeh is installed.
  - _copy_bokeh_cds(data): returns a ColumnDataSource copy by copying its .data dict (only available when Bokeh is installed).
  - Internal normalization routines ensure consistent lengths for dict-based sources when same_length is requested.

Examples

1) Single data source, multiple y columns
- data = {'x': x_array, 'y1': y1_array, 'y2': y2_array}
- p = PlotData(data, x='x', y=['y1', 'y2'])
- for entry in p:
    - x_values = data[entry.x]
    - y_values = data[entry.y]

2) List of data sources, one column spec per source
- data = [dset1, dset2]  # each a dict or DataFrame
- p = PlotData(data, x='energy', y=['intensity_a', 'intensity_b'])
- len(p) == 2, and p will iterate twice, pairing each source with its corresponding column spec.

Notes and common pitfalls
- If you pass a list of data sources, make sure the list length matches the number of expanded column sets (num_sets); otherwise PlotData raises a ValueError.
- If you want to mutate/modify the passed data without affecting the caller’s object, use copy_data=True.
- Bokeh ColumnDataSource support is optional and only activated if Bokeh is installed; otherwise ColumnDataSource inputs are not recognized.
- The class provides the keys (strings/indices) to access the actual arrays from your data source — plotting code must index into the provided data container(s) using those keys.

This helper is intended to decouple plotting routines from the structure of incoming data (dict vs DataFrame vs ColumnDataSource) and to provide a uniform per-plot-set interface for flexible multi-set plotting.