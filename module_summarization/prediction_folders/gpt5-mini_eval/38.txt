Examples and usage
==================

This document shows common usage patterns and examples for creating and customizing fields built on top of the Field base type.

Basic Field configuration
-------------------------

When declaring a field instance you can control its behaviour with the constructor arguments:

- source_field: DB column name override.
- generated: mark field as DB-generated.
- pk: primary key (also implies index=True and unique=True).
- null: allow NULL in DB.
- default: static value or callable (called at instance construction time).
- unique: unique constraint on field.
- index: create an index for the field.
- description: human-readable description (appears in describe_model()).

Example:

.. code-block:: py3

    id = Field(source_field="user_id", pk=True, description="Primary id")
    name = Field(null=False, default="", index=True, description="Full name")
    created_at = Field(generated=True, description="Creation timestamp")

Notes:
- You cannot set pk=True and null=True at the same time.
- If pk=True then index and unique are implied.
- If a Field subclass has indexable = False, passing unique or index will raise ConfigurationError.

Field type mixin and _FieldMeta
-------------------------------

_FieldMeta allows declaring a field's Python type by using an additional base class (a type mixin). This sets the instance attribute field_type automatically.

Example – integer field subclass:

.. code-block:: py3

    class IntField(Field, int):
        SQL_TYPE = "INT"
        indexable = True

    # Usage
    age = IntField(default=0)

You can supply multiple mixin types (they will be treated as a Union for field_type):

.. code-block:: py3

    class IntOrStrField(Field, int, str):
        SQL_TYPE = "VARCHAR(255)"

Conversion hooks: to_db_value and to_python_value
-------------------------------------------------

Field defines two conversion helpers used during save/load:

- to_db_value(value, instance): convert Python value to DB representation.
- to_python_value(value): convert DB value to Python type.

Default behavior attempts to coerce to the declared field_type if the value is not already of that type. Override these methods to implement custom conversions.

Example – overriding conversions:

.. code-block:: py3

    class UpperStringField(Field, str):
        SQL_TYPE = "VARCHAR(100)"

        def to_db_value(self, value, instance):
            if value is None:
                return None
            return str(value).upper()

        def to_python_value(self, value):
            if value is None:
                return None
            return str(value)

Per-database overrides
----------------------

You can supply per-SQL-dialect overrides using an inner class named with the pattern _db__{SQL_DIALECT}. Any class attribute or method can be overridden there.

Example – sqlite override:

.. code-block:: py3

    class NumericStringField(Field, str):
        SQL_TYPE = "VARCHAR(40)"

        class _db__sqlite:
            SQL_TYPE = "TEXT"
            skip_to_python_if_native = False

            def function_cast(self, term):  # term is a pypika.Term
                from pypika import functions
                return functions.Cast(term, "NUMERIC")

Notes:
- function_cast (callable that accepts a pypika.Term) can be used to apply database casting/emulation for queries.
- You may use properties inside the inner class for dynamic attributes.

Generated fields and SQL generation
----------------------------------

- allows_generated: set True if this field type supports DB generation.
- GENERATED_SQL: SQL snippet used to instruct the DB to auto-generate the value (required if allows_generated=True).
- SQL_TYPE: SQL type string for schema generation.

Example – auto-increment primary key:

.. code-block:: py3

    class AutoIncIntField(Field, int):
        SQL_TYPE = "INT"
        allows_generated = True
        GENERATED_SQL = "AUTOINCREMENT"

Primary keys and indexing
-------------------------

- Only a single primary key is allowed per model.
- If no pk is declared, a default primary key field (usually named id) is autogenerated.
- pk implies index and unique.
- indexable controls whether the field can be indexed.

Default values and callables
----------------------------

Defaults can be values or callables. If callable, it will be called when creating model instances to produce a dynamic default (the default value is not part of the generated schema).

Example:

.. code-block:: py3

    import datetime

    class CreatedAtField(Field, str):
        SQL_TYPE = "TIMESTAMP"

    created_at = CreatedAtField(default=lambda: datetime.datetime.utcnow())

Field attributes summary
------------------------

- field_type: Python type(s) for the field (set by _FieldMeta).
- indexable: whether the field can be indexed.
- has_db_field: whether the field maps to a DB column.
- skip_to_python_if_native: optimization hint to skip conversion for native DB types.
- allows_generated: supports DB-side generation.
- function_cast: optional callable to cast pypika.Term for query compatibility.
- SQL_TYPE: SQL column type string.
- GENERATED_SQL: SQL used to instruct DB auto-generation.

Putting it together — simple custom field example
------------------------------------------------

.. code-block:: py3

    class EmailField(Field, str):
        SQL_TYPE = "VARCHAR(255)"
        indexable = True

        def to_db_value(self, value, instance):
            if value is None:
                return None
            return value.lower().strip()

        def to_python_value(self, value):
            if value is None:
                return None
            return value

    email = EmailField(unique=True, null=False, description="User email address")

This file documents the common usage patterns for creating and customizing fields using the Field base type, how to implement conversion logic and per-dialect overrides, and the semantics of key constructor flags (pk, null, unique, index, generated, default).