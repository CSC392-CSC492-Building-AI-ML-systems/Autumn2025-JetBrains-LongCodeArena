Simulation utilities
====================

This module provides lightweight simulation and inspection helpers for Bluesky
plans. The helpers operate on plan iterables that yield Msg objects (as used by
Bluesky). They are convenience utilities for visualizing raster paths,
printing compact plan summaries, and checking planned moves against device
limits.

Dependencies
------------
- matplotlib (for plotting)
- bluesky.preprocessors.print_summary_wrapper
- warnings

plot_raster_path
----------------

Plot the raster path encoded in a plan.

Signature
~~~~~~~~~
plot_raster_path(plan, x_motor, y_motor, ax=None, probe_size=None, lw=2)

Description
~~~~~~~~~~~
Iterate over a plan that yields Msg objects and build the 2D trajectory from
'set' and 'save' messages. The function expects the plan to yield concrete
Msg objects (not be a co-routine). It collects positions when the plan issues
a 'save' message and uses the most recent 'set' values for the named x and y
motors.

Parameters
~~~~~~~~~~
- plan : iterable
  An iterable that yields Msg objects (as in Bluesky plans).
- x_motor, y_motor : str
  The names of the motors used for X and Y positions in the plan.
- ax : matplotlib.axes.Axes or None
  Axes to draw into. If None, a new figure and axes are created.
- probe_size : float or None
  If None, plot read points as markers. If provided, draw circular patches
  of radius probe_size at each read position (same units as motor positions).
- lw : float, optional
  Line width used for connecting path points and for marker edge widths.

Returns
~~~~~~~
dict with keys:
- 'path' : matplotlib Line2D
  The line object connecting the trajectory points.
- 'events' : matplotlib Collection or PathCollection
  The artist representing individual read points (either a PatchCollection
  of circles when probe_size is given, or a scatter PathCollection otherwise).

Notes
~~~~~
- The axes are set to equal aspect ratio.
- The function extracts the current x and y positions from 'set' messages by
  checking msg.obj.name against x_motor and y_motor and uses the first positional
  argument in msg.args as the value.
- If no 'save' messages are present the function will raise when attempting to
  unpack trajectory coordinates.

Example
~~~~~~~
>>> artists = plot_raster_path(plan_iterable, 'x', 'y', probe_size=0.1)
>>> ax = artists['path'].axes

summarize_plan (alias: print_summary)
------------------------------------

Signature
~~~~~~~~~
summarize_plan(plan)

Description
~~~~~~~~~~~
Print a minimal, human-readable summary of a plan. This is a thin wrapper
that delegates to bluesky.preprocessors.print_summary_wrapper and yields a
compact representation that emphasizes moves and event points.

Parameters
~~~~~~~~~~
- plan : iterable
  An iterable that yields Msg objects.

Notes
~~~~~
- This function is provided for backward compatibility under the alias
  print_summary.

Example
~~~~~~~
>>> summarize_plan(plan_iterable)

check_limits
------------

Signature
~~~~~~~~~
check_limits(plan)

Description
~~~~~~~~~~~
Validate planned set operations against device limits by iterating over the
plan and calling each device's check_value() method when present. If a device
lacks check_value(), a warning is emitted and further checks for that device
are skipped.

Parameters
~~~~~~~~~~
- plan : iterable
  An iterable that yields Msg objects.

Behavior
~~~~~~~~
- For each Msg with command == 'set', if the target object (msg.obj) implements
  check_value(value) the function calls it with the planned value. Devices
  that do not implement check_value will trigger a warnings.warn and will be
  added to an internal ignore list so that subsequent sets to the same device
  are not repeatedly warned.

Notes
~~~~~
- This function raises whatever exceptions the device's check_value may raise
  if a value is out of allowable bounds; it does not itself convert or
  suppress such exceptions.
- The function uses the warnings module to notify about devices that lack
  check_value().

Example
~~~~~~~
>>> check_limits(plan_iterable)

Additional notes
----------------
- All utilities assume the plan yields Msg objects with attributes such as
  command, obj, args and that msg.obj has a name attribute when appropriate.
- These helpers are intended for inspection and light visualization; they do
  not modify the plan or execute hardware operations.