autowrap — Wrapping codegen output for Python
==============================================

Module purpose
--------------
The autowrap module provides utilities to compile code generated by Diofant's
codegen machinery and to wrap the resulting binaries for use from Python.
It offers a common interface for different external backends (for example
f2py and Cython), allowing expressions or routines produced by the code
generation pipeline to be exposed as normal Python callables or as Diofant
binary Function objects.

Typical uses include:
- speeding up repeated numerical evaluation of long symbolic expressions,
- creating custom ufuncs for NumPy arrays,
- testing generated binaries from within Diofant, and
- quickly verifying code generated for use in other projects.

Note: temporary build files are cleaned up by default; provide a concrete
filepath to preserve files for inspection.

Doctest / optional dependencies
-------------------------------
The module exposes a small mapping of optional test-time dependencies:

_doctest_depends_on = {'exe': ('f2py', 'gfortran', 'gcc'), 'modules': ('numpy',)}

These indicate the external tools and Python modules commonly required by
backends and by some doctests.

Exceptions
----------
CodeWrapError
    Generic exception raised when wrapping or external build commands fail.
    When an external command (for example a compiler or setup script)
    returns a non-zero exit status the exception includes the command
    output to aid diagnosis.

Core classes
------------

CodeWrapper
~~~~~~~~~~~
Base class for backend-specific wrappers.

Constructor
    CodeWrapper(generator, filepath=None, flags=[], verbose=False)

Attributes
- generator: a codegen generator instance (e.g. an instance from the
  codegen API such as CCodeGen) used to render source from routines.
- filepath: when given, use this directory for generated files; otherwise a
  temporary working directory is created and removed after wrapping.
- flags: extra command-line flags passed to the build/compile command used
  by the backend.
- quiet: inverse of verbose; controls printing of external command output.

Properties
- filename: a per-module filename derived from an internal counter.
- module_name: a per-module importable module name derived from an internal
  counter.
- include_header / include_empty: booleans that indicate whether the
  generator should include header/empty-file output; these return True when
  a persistent filepath is provided.

Key methods
- _generate_code(main_routine, routines)
    Append the main routine to the helper routines and invoke the generator's
    write(...) method to produce source files. The generator is expected to
    match the codegen API (e.g. write(routines, filename, ...)).

- wrap_code(routine, helpers=[])
    Top-level orchestration for wrapping a single routine:
    1. Create or use the working directory (temporary if filepath is None).
    2. Add the workdir to sys.path and change cwd to it.
    3. Generate source files with _generate_code.
    4. Call backend-specific preparation (_prepare_files) and processing
       (_process_files) hooks.
    5. Import the built module and obtain the wrapped callable.
    6. Clean up sys.path, cwd and (unless filepath was specified) remove the
       temporary workdir. A module counter is incremented so generated module
       and file names are unique across calls.
    Returns the Python callable that wraps the compiled routine.

- _process_files(routine)
    Runs the backend's external build command stored in self.command, extended
    with self.flags. Captures command output and raises CodeWrapError if the
    command fails. On success, returns or prints command output depending on
    verbose/quiet settings.

Backends should implement or override:
- _prepare_files(self, routine): prepare any additional files needed before
  build (headers, setup scripts, etc.).
- _get_wrapped_function(cls, module, name): obtain the callable attribute
  from the imported module after building.

DummyWrapper
~~~~~~~~~~~~
A small concrete wrapper intended for testing the wrapping infrastructure
without invoking an external compiler.

Behavior
- _prepare_files: no-op.
- _process_files: no-op (no external command is run).
- _generate_code: writes a plain Python module named by module_name with a
  trivial function that returns a textual representation of the routine
  (suitable for unit tests).
- _get_wrapped_function: returns the attribute from the imported module.

Use DummyWrapper to test round-trips of generator → wrapping → import
without relying on compilers or build tools.

CythonCodeWrapper
~~~~~~~~~~~~~~~~~
A wrapper subclass that uses Cython to compile generated code into a Python
extension module. The class holds a setup_template used to create a
setuptools-based build script and runs the appropriate build commands to
produce a loadable module. (The full implementation hooks into the generic
CodeWrapper orchestration described above.)

Usage example
-------------
Note: the example below sketches the standard flow; the construction of a
codegen Routine is via the Diofant codegen utilities (get_code_generator,
make_routine, etc.) and is outside the minimal example.

from autowrap import DummyWrapper, CodeWrapError
# generator: an instance compatible with Diofant's codegen API (e.g. CCodeGen)
# routine: a Routine object produced by make_routine or codegen utilities

wrapper = DummyWrapper(generator, filepath=None, flags=[], verbose=False)
try:
    wrapped_callable = wrapper.wrap_code(routine)
    # wrapped_callable is a normal Python callable (or module attribute)
    result = wrapped_callable(1, 2, 3)
except CodeWrapError as e:
    # inspect e to diagnose build/wrap failures
    raise

Notes and implementation details
-------------------------------
- The wrapper uses a global per-process counter (_module_counter) to produce
  unique filenames and module names on successive invocations. This avoids
  module import name collisions when multiple wrappers are generated in one
  process.
- If filepath is omitted, a temporary directory is created and removed when
  wrapping completes; set filepath to keep generated files for inspection.
- Backends are expected to cooperate with the codegen generator interface;
  the generator should implement write(routines, filename, ...) and the
  produced sources should be suitable for the chosen build pipeline.
- _process_files delegates to the external build command configured by each
  backend and raises CodeWrapError with the captured output if the command
  exits with error. This provides readable feedback from compilers and
  build systems.

See also
--------
- Diofant codegen utilities (get_code_generator, make_routine)
- Backend-specific wrappers (f2py-based wrapper, Cython wrapper)
- autowrap-style helpers such as autowrap() and binary_function() in Diofant
  (the module-level utilities that present a one-button interface for users).