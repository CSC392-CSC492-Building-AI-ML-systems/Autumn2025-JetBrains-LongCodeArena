Using timers
============

This document describes common patterns and recommended practices for timing and scheduling work when developing with ftrack-API-based applications. It covers simple elapsed-time measurement, convenient context-manager and decorator helpers, scheduling delayed calls with the standard library, and integration with ftrack logging.

Measuring elapsed time
----------------------

To measure how long a piece of code takes to run, use a high-resolution clock (time.perf_counter) and compute the difference between start and end times:

Example::

    import time

    start = time.perf_counter()
    # Do work...
    end = time.perf_counter()
    elapsed = end - start
    print('Elapsed: {:.6f} s'.format(elapsed))

Context manager helper
----------------------

A context manager keeps timing code blocks concise and readable. Here is a simple helper you can reuse:

Example::

    import time
    from contextlib import contextmanager

    @contextmanager
    def timer(label=None, logger=None):
        start = time.perf_counter()
        try:
            yield
        finally:
            elapsed = time.perf_counter() - start
            message = '{}: {:.6f} s'.format(label or 'Elapsed', elapsed)
            if logger is not None:
                logger.info(message)
            else:
                print(message)

Usage::

    with timer('fetch data', logger=session.logger):
        fetch_data()

Decorator helper
----------------

A decorator lets you time function calls with minimal intrusion:

Example::

    import time
    import functools

    def timed(label=None, logger=None):
        def decorator(fn):
            @functools.wraps(fn)
            def wrapper(*args, **kwargs):
                start = time.perf_counter()
                try:
                    return fn(*args, **kwargs)
                finally:
                    elapsed = time.perf_counter() - start
                    message = '{}: {}(): {:.6f} s'.format(
                        label or 'Timer', fn.__name__, elapsed
                    )
                    if logger is not None:
                        logger.info(message)
                    else:
                        print(message)
            return wrapper
        return decorator

Usage::

    @timed('process', logger=session.logger)
    def process_items(items):
        ...

Scheduling delayed execution
----------------------------

For one-shot delayed calls, use threading.Timer from the standard library. It runs the provided callable in a new thread after the given interval.

Example::

    from threading import Timer

    def do_later(arg):
        print('Doing work with', arg)

    # Call do_later('x') after 5 seconds
    t = Timer(5.0, do_later, args=('x',))
    t.start()

    # Cancel if no longer needed
    t.cancel()

For repeated intervals, implement a wrapper that reschedules itself or consider sched.scheduler for more control.

Thread safety and integration with ftrack sessions
-------------------------------------------------

- Timers (and any code executed in separate threads) must interact with thread-unsafe objects carefully. ftrack Session objects are not guaranteed to be thread-safe; prefer scheduling thread-safe work or dispatching results back to a main thread or worker pool that has exclusive access to the session.
- When logging from timed or threaded code, use the session.logger (or another thread-safe logger). Make sure any session operations performed inside timers check for proper synchronization or use the session in a thread-safe manner (for example, by using a queue to hand work to a single thread owning the session).
- Use atexit.register to ensure any outstanding timers are cancelled during process shutdown if necessary.

Formatting and reporting
------------------------

- Report durations with an appropriate precision (milliseconds or microseconds) depending on expected durations.
- For human-facing logs, convert seconds to a readable form for long-running tasks (e.g., minutes and seconds).
- Aggregate timings for repeated operations (average, min, max, count) when measuring performance over many runs.

Best practices
--------------

- Prefer time.perf_counter for measuring elapsed time.
- Use context managers and decorators to keep timing code concise and easy to remove when no longer required.
- Avoid heavy work or direct session manipulation inside timer threads unless you ensure thread-safety.
- Integrate with the application's central logging so timings are captured consistently alongside other diagnostics.

Examples
--------

Timing a database fetch with a session logger::

    with timer('query projects', logger=session.logger):
        projects = session.query('Project').all()

Timing a function with a decorator::

    @timed('refresh cache', logger=session.logger)
    def refresh_cache():
        ...

Scheduling a delayed save after a period of inactivity::

    debounce_timer = None

    def schedule_save():
        global debounce_timer
        if debounce_timer:
            debounce_timer.cancel()
        debounce_timer = Timer(2.0, save_changes)
        debounce_timer.start()

See also
--------

- Python standard library: time, threading.Timer, sched, contextlib
- Logging integration: use session.logger or Python logging for consistent observability

License
-------

This documentation describes general timer patterns and examples intended to interoperate safely with ftrack-based applications.