Sync users with LDAP
====================

Overview
--------
This document describes how to synchronise user accounts from an LDAP directory into an ftrack server. The goal is to keep ftrack user records in sync with an authoritative LDAP source — creating users, updating attributes and group memberships, and deactivating accounts no longer present in LDAP.

Prerequisites
-------------
- Access to an LDAP server with credentials that allow searching users.
- An ftrack server reachable via HTTP(S).
- An ftrack API key and user registered on the ftrack server.
- Python environment with required packages (requests, python-ldap or ldap3, ftrack_api).

Configuration
-------------
Environment variables commonly used by the ftrack API client:

- FTRACK_SERVER — URL of the ftrack server (including port if required).
- FTRACK_API_KEY — API key used to authenticate requests.
- FTRACK_API_USER — Username to perform operations as (defaults to current user if omitted).

LDAP configuration items (example):
- LDAP_URI — LDAP server URI (e.g. ldap://ldap.example.com or ldaps://ldap.example.com).
- LDAP_BIND_DN — Bind DN for performing searches.
- LDAP_BIND_PASSWORD — Password for bind DN.
- LDAP_USER_BASE_DN — Base DN to search for user entries.
- LDAP_USER_FILTER — LDAP filter to select user entries (e.g. "(objectClass=person)").
- LDAP_ATTRIBUTE_MAP — Mapping of LDAP attributes to ftrack user attributes (see Mapping section).

Authentication and session
--------------------------
Use the ftrack API Session to interact with the server. The Session requires server_url, api_key and api_user. These can be supplied from environment variables or passed explicitly.

Example (conceptual):

.. code-block:: python

    from ftrack_api import Session

    session = Session(
        server_url='https://ftrack.example.com',
        api_key=os.environ['FTRACK_API_KEY'],
        api_user=os.environ['FTRACK_API_USER']
    )

The Session object records operations and provides query/create/update operations on ftrack entities. When making HTTP requests outside the ftrack_api client, include authentication headers that the server expects. The ftrack client attaches headers such as 'ftrack-api-key' and 'ftrack-user' to requests.

Mapping LDAP to ftrack
----------------------
Define a clear attribute mapping from LDAP entry attributes to ftrack User attributes. Typical attributes:

- username (required) — unique identifier used in ftrack (sAMAccountName, uid, or mail localpart).
- email — LDAP mail attribute.
- first_name, last_name — givenName, sn, or full name parsed into parts.
- enabled/active — map LDAP account status (e.g. userAccountControl or shadowExpire) to ftrack active/disabled state.
- groups — LDAP group membership mapped to ftrack groups or roles.

Example mapping (conceptual):

.. code-block:: python

    ATTRIBUTE_MAP = {
        'username': 'uid',       # LDAP attribute containing username
        'email': 'mail',
        'first_name': 'givenName',
        'last_name': 'sn',
        'groups': 'memberOf',
    }

Sync behaviour
--------------
The sync process should be idempotent: running it multiple times produces the same state.

Basic steps:

1. Query LDAP for all relevant user entries (or incremental changes if LDAP changelog/replication is available).
2. For each LDAP entry:
   - Resolve a unique username or unique identifier.
   - Query ftrack for an existing User with that identifier:
     - If found, update attributes that differ from the LDAP source.
     - If not found, create a new ftrack User with the mapped attributes.
   - Reconcile group memberships and roles.
3. Optionally, identify ftrack users that are no longer present in LDAP and deactivate or disable them (do not delete unless you have a safe retention policy).
4. Record and report changes.

Conflict resolution and uniqueness
----------------------------------
- Ensure the chosen identifier used in ftrack is unique and deterministic (username or email).
- If a user exists in ftrack with a conflicting identifier, log the conflict and skip or handle according to policy (merge, rename, manual review).

Example implementation outline
------------------------------
This example is conceptual and omits LDAP library details:

.. code-block:: python

    def sync_ldap_to_ftrack(session, ldap_entries, attribute_map, dry_run=False):
        for entry in ldap_entries:
            username = entry.get(attribute_map['username'])
            if not username:
                continue

            # Find existing ftrack user
            query = "User where username is \"{0}\"".format(username)
            existing = session.query(query).first()

            mapped = {
                'email': entry.get(attribute_map.get('email')),
                'first_name': entry.get(attribute_map.get('first_name')),
                'last_name': entry.get(attribute_map.get('last_name')),
            }

            if existing:
                changes = {}
                for key, value in mapped.items():
                    if getattr(existing, key, None) != value:
                        changes[key] = value
                if changes:
                    if not dry_run:
                        for key, value in changes.items():
                            setattr(existing, key, value)
                        session.commit()
                    else:
                        session.logger.info('Would update %s: %s', username, changes)
            else:
                if not dry_run:
                    session.create('User', {
                        'username': username,
                        'email': mapped['email'],
                        'first_name': mapped['first_name'],
                        'last_name': mapped['last_name'],
                    })
                    session.commit()
                else:
                    session.logger.info('Would create user %s', username)

Dry-run and logging
-------------------
- Implement a "dry-run" mode that reports changes without applying them.
- Log operations at INFO and differences/failed operations at WARNING/ERROR.
- Keep an audit log of created/updated/deactivated users and timestamps.

Scheduling and incremental updates
---------------------------------
- For large directories run periodic full synchronisations or implement incremental sync using LDAP change logs (if available).
- Consider rate limits and batching when creating/updating many users in ftrack.
- Perform a staged rollout (dry-run, subset, full sync) in production environments.

Error handling and retries
--------------------------
- Catch network and LDAP transient errors and retry with exponential backoff.
- For persistent failures log and surface alerts to administrators.
- Ensure atomicity where appropriate: commit per-user or per-batch and handle partial failures with retries or a rollback policy.

Security considerations
-----------------------
- Store LDAP and ftrack credentials securely (avoid plaintext in version control).
- Use LDAPS (TLS) or StartTLS for LDAP traffic.
- Restrict the ftrack API key permissions to only what is required for user management.
- Rotate credentials periodically.

Testing
-------
- Test against a staging ftrack server and a non-production LDAP mirror.
- Verify mapping rules, group reconciliation, and deactivation policy with representative accounts.
- Use dry-run extensively to validate expected changes.

Best practices
--------------
- Prefer deactivation over deletion for users removed from LDAP.
- Keep a compact, auditable change log of sync operations.
- Provide administrators with a reconciliation report listing: created, updated, skipped, conflicted and deactivated accounts.
- Review and limit the scope of user attributes changed automatically.

Appendix: Recommended attributes to sync
----------------------------------------
- username (unique id)
- email
- first_name
- last_name
- active / disabled status
- groups / roles
- phone, locale, timezone (optional)

Further reading
---------------
Refer to the ftrack API Session documentation for details about Session construction, authentication and entity operations. Use that API to query, create and update User entities as demonstrated in the examples above.