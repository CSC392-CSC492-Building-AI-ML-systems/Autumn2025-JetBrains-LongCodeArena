Miscellaneous features
======================

This section documents various miscellaneous internal utilities used by
astropy.io.fits: the verification framework, a hierarchical error-list
formatter, a simple notifier mixin for change listeners, and a few small
helper constants/functions.

Verification framework
----------------------

The verification subsystem is used throughout the FITS I/O code to check
objects for problems, optionally fix issues, and report errors or warnings.

Key objects and names
- VerifyError -- Exception class raised when verification fails and the
  reporting option demands an exception.
- VerifyWarning -- Warning class (subclass of astropy.utils.exceptions.AstropyUserWarning)
  used for verification warnings.
- VERIFY_OPTIONS -- list of supported verification option strings:
  ``"ignore"``, ``"warn"``, ``"exception"``, ``"fix"``, ``"silentfix"``,
  and the combinations ``"fix+..."`` and ``"silentfix+..."`` with
  ``"ignore"``, ``"warn"``, or ``"exception"``.

_Verify class
- _Verify.verify(option="warn")
  - Runs the instance's internal verification routine and acts according to
    the chosen option. Valid options are those in VERIFY_OPTIONS (case
    insensitive). If an invalid option is passed, ValueError is raised.
  - Behavior overview:
    - "ignore": do nothing.
    - "warn": collect errors and issue VerifyWarning messages.
    - "exception": raise VerifyError with all collected messages.
    - "fix" / "silentfix": attempt to fix fixable issues. The original
      semantics treat "fix" and "silentfix" as implicitly combined with
      "exception" for reporting unfixable errors unless a `+...` report
      qualifier is provided.
    - Compound forms such as "fix+warn" or "silentfix+ignore" separate
      fixing behavior (left of the "+") from reporting behavior (right of
      the "+").
  - The method breaks the option into a fix part and a report part,
    filters messages depending on the fix/report policy, and either warns,
    raises, or returns silently.

- _Verify.run_option(option="warn", err_text="", fix_text="Fixed.", fix=None, fixable=True)
  - Helper to apply the chosen option to a single verification item.
  - If fixable and a fix callable is provided, run it and append fix_text to
    the message. Returns a tuple (fixable, message_text) suitable for the
    verification error list.

Verification options summary
- ignore: no reporting or fixing.
- warn: report problems using VerifyWarning. Fixes are not applied.
- exception: raise VerifyError with all messages. Fixes are not applied.
- fix: attempt to fix fixable issues; by default unfixable issues are
  reported as exceptions unless combined with a reporting option.
- silentfix: attempt to fix but suppress messages for fixed issues.
- Combinations: e.g. "fix+warn" attempts fixes and issues warnings for
  remaining/unfixable problems; "silentfix+ignore" fixes silently and
  suppresses all reporting.

Hierarchical verification error list (_ErrList)
----------------------------------------------

The verification routines collect messages in a hierarchical structure
implemented by the internal _ErrList class. It supports nested
sub-lists, per-level headers, and formatted output with indentation.

- class _ErrList(list)
  - Initialized as _ErrList(val=(), unit="Element") where `unit` is a
    header label used for nested sub-lists (e.g. "HDU", "Column").
  - __str__() returns a single string composed of all formatted lines.
  - iter_lines(filter=None, shift=0)
    - Iterates the nested structure and yields tuples (fixable_flag, line_text)
      where:
        - fixable_flag: boolean or None. A boolean indicates whether the
          item is fixable; None is used for header lines that are not
          associated with a single fixable flag.
        - line_text: the message string with indentation appropriate to the
          nesting level.
    - Behavior:
      - Top-level non-_ErrList items are yielded first.
      - Then nested _ErrList items are traversed. If a nested list yields any
        lines, a header like ``"<unit> N:"`` is emitted (with indentation)
        for that nested element before its lines.
      - The optional `filter` callable may be used to select which items to
        emit (for example, to suppress fixed issues when using silentfix).

Example (conceptual)
::
    errs = _ErrList(unit='HDU')
    errs.append((False, 'Invalid header keyword XYZ'))
    next_level = _ErrList(unit='Column')
    next_level.append((True, 'Non-standard TTYPEn'))
    errs.append(next_level)
    print(str(errs))

NotifierMixin
-------------

NotifierMixin provides a lightweight mechanism for objects to allow
listeners to register for change notifications. It is intended for
internal communication between FITS objects and related helpers.

Key points
- Listener registration is done via an underscored API (intended for
  internal use), e.g. _add_listener(listener). Listeners are held with
  weak references so they are dropped automatically if no longer
  referenced elsewhere.
- Notifications are emitted via _notify(change_type, *args, **kwargs).
  For a given change_type, the notifier will call
  listener._update_<change_type>(*args, **kwargs) on each registered
  listener that implements that update method. Missing update methods are
  ignored.
- This mixin is suitable for keeping dependent objects synchronized when
  an underlying object changes (for example, updating views when an HDU
  is modified).

Minimal example (conceptual)
::
    class Widget(NotifierMixin):
        def __init__(self, name):
            self.name = name
    class Observer:
        def _update_change(self, *args, **kwargs):
            ...
    w = Widget('w')
    obs = Observer()
    w._add_listener(obs)
    w._notify('change', some_arg=1)

Miscellaneous utilities
-----------------------

- path_like = (str, bytes, os.PathLike)
  - Tuple used to identify objects that can represent filesystem paths.

- cmp = lambda a, b: (a > b) - (a < b)
  - Small 3-way comparison helper returning -1, 0 or 1.

- all_integer_types = (int, np.integer)
  - Tuple used to test for native and numpy integer types.

Notes
-----
These utilities are internal helpers used by astropy.io.fits. Public-facing
APIs typically provide higher-level wrappers; consult the FITS I/O
reference for user-oriented functions and classes.