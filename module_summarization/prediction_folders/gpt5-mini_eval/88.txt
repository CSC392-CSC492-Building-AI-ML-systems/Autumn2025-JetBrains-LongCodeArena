Using SQLite and asyncio effectively
==================================

Overview
--------
This module provides SQLite-specific type adapters and converters and an asynchronous batching helper
for use with aiosqlite. It is intended to make SQLite behaviour more consistent with other engines
(e.g. Postgres) by:

- Registering adapters so Python types are converted to SQLite-compatible representations on
  insert/update.
- Registering converters so values returned from SQLite are converted back to appropriate Python
  types.
- Providing AsyncBatch, an async iterator to fetch query results in batches via an aiosqlite
  Connection.

Notes
-----
- To ensure converters are used when connecting to SQLite, open the connection with
  detect_types=sqlite3.PARSE_DECLTYPES (or PARSE_COLNAMES as appropriate).
- Timezone-aware datetimes are converted to UTC before storage, to mirror Postgres behaviour.
- Arrays are stored as JSON strings. Many-to-many (M2M) values are stored as comma-separated
  strings.
- Decimal values are adapted to floats on input and returned as Decimal on output to preserve
  numeric semantics within the application.

Registered converters (SQLite -> Python)
---------------------------------------
- Numeric -> Decimal
  - convert_numeric_out(value: bytes) -> Decimal
  - Assumes encoded ASCII float numeric string. Returns Decimal for higher precision in Python.

- Integer -> int
  - convert_int_out(value: bytes) -> int
  - Converts numeric bytes to float and then to int to ensure integer semantics.

- UUID -> uuid.UUID
  - convert_uuid_out(value: bytes) -> uuid.UUID
  - Decodes UTF-8 and constructs a UUID instance.

- Date -> datetime.date
  - convert_date_out(value: bytes) -> datetime.date
  - Uses datetime.date.fromisoformat on the decoded string.

- Time -> datetime.time
  - convert_time_out(value: bytes) -> datetime.time
  - Uses datetime.time.fromisoformat on the decoded string.

- Seconds -> datetime.timedelta
  - convert_seconds_out(value: bytes) -> datetime.timedelta
  - Interprets the stored value as seconds (float) and returns a timedelta.

- Boolean -> bool
  - convert_boolean_out(value: bytes) -> bool
  - Expects "1" for True; any other value yields False.

- Timestamp -> datetime.datetime
  - convert_timestamp_out(value: bytes) -> datetime.datetime
  - Uses datetime.datetime.fromisoformat on the decoded string (naive datetime).

- Timestamptz -> datetime.datetime (UTC)
  - convert_timestamptz_out(value: bytes) -> datetime.datetime
  - Parses the ISO string and sets tzinfo=datetime.timezone.utc.

- Array -> list
  - convert_array_out(value: bytes) -> list
  - JSON-deserialises the stored string.

- M2M -> list[str]
  - convert_M2M_out(value: bytes) -> list[str]
  - Decodes and splits on commas.

Registered adapters (Python -> SQLite)
-------------------------------------
- Decimal -> float (via convert_numeric_in)
  - Decimal values are cast to float before being passed to SQLite.

- uuid.UUID -> str (via convert_uuid_in)
  - UUIDs are converted to their canonical string representation.

- datetime.time -> str (via convert_time_in)
  - Stored as ISO-formatted time string.

- datetime.date -> str (via convert_date_in)
  - Stored as ISO-formatted date string.

- datetime.datetime -> str (via convert_datetime_in)
  - If timezone-aware, converted to UTC and then stringified; otherwise stringified as-is.

- datetime.timedelta -> float (via convert_timedelta_in)
  - Stored as total seconds (float).

- list -> JSON string (via convert_array_in)
  - Serialises lists to JSON when elements are str/int/float only; otherwise raises ValueError.

Key functions
-------------
- convert_numeric_in(value) -> float
  - Convert Decimal to float for storage.

- convert_uuid_in(value) -> str
  - Convert UUID to string for storage.

- convert_time_in(value: datetime.time) -> str
  - ISO-format a time.

- convert_date_in(value: datetime.date) -> str
  - ISO-format a date.

- convert_datetime_in(value: datetime.datetime) -> str
  - Convert timezone-aware datetimes to UTC then to string.

- convert_timedelta_in(value: datetime.timedelta) -> float
  - Return seconds as float.

- convert_array_in(value: list) -> str
  - JSON-serialise a homogeneous list of str/int/float values.

- convert_numeric_out(value: bytes) -> Decimal
  - Convert ASCII float bytes to Decimal.

- convert_int_out(value: bytes) -> int
  - Convert numeric bytes to int.

- convert_uuid_out(value: bytes) -> uuid.UUID
  - Construct UUID from bytes.

- convert_date_out, convert_time_out, convert_timestamp_out, convert_timestamptz_out
  - Parse ISO strings into appropriate datetime/date/time values. Timestamptz gets tzinfo=UTC.

- convert_array_out(value: bytes) -> list
  - JSON-deserialise the stored array string.

- convert_M2M_out(value: bytes) -> list[str]
  - Comma-split the stored M2M string.

AsyncBatch
----------
A helper dataclass implementing Batch semantics for asynchronous use with aiosqlite.

Attributes
- connection: aiosqlite.Connection
- query: Query object (expects a .querystrings list and a ._process_results coroutine)
- batch_size: int
- _cursor: internal cursor (set during __aenter__)

Behavior
- async with AsyncBatch(...) as batch: opens a cursor and executes the compiled query.
- Use "async for rows in batch:" to iterate batches of results; each iteration yields a list of dicts
  as produced by query._process_results.
- next() asynchronously fetches up to batch_size rows using cursor.fetchmany and processes them
  via query._process_results.
- On exit, the cursor and connection are closed. If an exception occurred, it is propagated.

AsyncBatch example
------------------
Example usage pattern (conceptual):

.. code-block:: python

    import sqlite3
    import aiosqlite
    from using_sqlite_and_asyncio_effectively import AsyncBatch
    # `query` must be an instance compatible with the module's Query interface,
    # providing a compiled querystring and an async _process_results method.

    async def fetch_in_batches(path: str, query, batch_size: int = 100):
        # Enable converters registered with sqlite3
        async with aiosqlite.connect(path, detect_types=sqlite3.PARSE_DECLTYPES) as conn:
            async with AsyncBatch(connection=conn, query=query, batch_size=batch_size) as batch:
                async for rows in batch:
                    # rows is a list[dict] processed by the query object
                    for row in rows:
                        process_row(row)

Important connection flags
--------------------------
When creating an aiosqlite connection, to make use of the converters registered in this module
use:

- detect_types=sqlite3.PARSE_DECLTYPES

Other tips
----------
- Because input Decimal values are converted to float for storage, very high precision may be
  lost in the DB. The module converts floats back to Decimal on read to retain Python-side Decimal
  semantics where possible.
- The module enforces simple constraints for array serialisation: only str, int and float are
  allowed inside lists. Nested complex objects will raise ValueError on serialisation.
- For M2M storage the simple comma-separated format is used; avoid embedding commas in values.

Related
-------
- aiosqlite (async SQLite driver)
- sqlite3 module detect_types and converters
- Piccolo Query/Engine (expected query object interfaces used by AsyncBatch)

License and provenance
----------------------
The functions and registrations in this module are intended to align SQLite behaviour with that
expected by other database backends used in the same codebase (for example Postgres). Converters
and adapters are registered globally with sqlite3 upon import of this module.