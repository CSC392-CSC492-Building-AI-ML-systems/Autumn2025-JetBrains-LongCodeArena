Managers for request handling and raw-transaction sending
======================================================

Module overview
---------------
This module provides manager classes that wrap a JSON-RPC provider and
implement synchronous and asynchronous request patterns, plus a mixin
that assists with constructing, signing, serializing and tracking
raw Ethereum transactions.

The implementation depends on gevent for spawning asynchronous greenlets,
rlp for RLP encoding/decoding of transactions, and several Web3 utility
helpers for encoding/decoding, address and numeric handling.

Classes
-------

RequestManager
^^^^^^^^^^^^^^
A light-weight request manager that issues RPC calls via a provider.

Constructor
    RequestManager(provider)

Attributes
    provider
        The provider used to make RPC requests. Expected to implement
        make_request(method, params) and return either a JSON string or
        a Python object representing the decoded response.
    pending_requests : dict
        Mapping of uuid.UUID -> gevent.Greenlet for outstanding async
        requests.

Methods
    setProvider(provider)
        Replace the current provider.

    request_blocking(method, params) -> result
        Make a synchronous call through the provider:
        - Calls provider.make_request(method, params).
        - If the provider returns a string it will be JSON-decoded.
        - If the resulting response contains an "error" key a ValueError
          is raised with the error payload.
        - On success returns response['result'].

    request_async(method, params) -> uuid.UUID
        Spawn a gevent greenlet to execute request_blocking(method, params)
        and store it in pending_requests keyed by a generated UUID.
        Returns the UUID for later retrieval.

    receive_blocking(request_id, timeout=None) -> result
        Retrieve and wait for an async request previously created by
        request_async:
        - Pops the greenlet from pending_requests.
        - If not found raises KeyError.
        - Optionally applies a gevent.Timeout for the wait.
        - Waits for the greenlet to finish, expects the greenlet's result
          to be a JSON string and decodes it.
        - If the response contains an "error" key a ValueError is raised.
        - On success returns response['result'].

        Note: the method expects the greenlet to have returned a JSON string
        (response_raw) — the implementation performs json.loads on that value.

    receive_async(request_id, *args, **kwargs)
        Not implemented. Raises NotImplementedError (callback pattern not
        implemented).

ManagerWrapper
^^^^^^^^^^^^^^
A proxy wrapper around another manager instance. It forwards attribute
access and common manager methods to the wrapped manager.

Constructor
    ManagerWrapper(wrapped_manager)

Attributes
    wrapped_manager
        The underlying manager instance being wrapped.

Properties
    provider -> proxied provider
    pending_requests -> proxied pending_requests

Methods (proxy)
    setProvider(provider)
    request_blocking(*args, **kwargs)
    request_async(*args, **kwargs)
    receive_blocking(*args, **kwargs)
    receive_async(*args, **kwargs)

BaseSendRawTransactionMixin
^^^^^^^^^^^^^^^^^^^^^^^^^^
A mixin that extends a ManagerWrapper to add helpers for building,
signing, serializing and tracking raw transactions. Intended to be
combined with a manager that implements request_blocking/request_async.

Constructor
    BaseSendRawTransactionMixin(wrapped_manager, ...)
        Initializes:
        - _known_transactions : defaultdict(set) — tracked transaction hashes by address
        - _known_nonces : defaultdict(set) — tracked nonces by address

Internal state
    _known_transactions : defaultdict(set)
        Maps from address -> set(transaction_hash) for locally tracked txns.

    _known_nonces : defaultdict(set)
        Maps from address -> set(nonce) for locally tracked nonces.

Important methods
    _get_nonces_and_cleanup(addr, chain_nonce) -> generator
        - For each tracked transaction hash for addr, fetches the on-chain
          transaction via 'eth_getTransactionByHash'. If the transaction
          is present, yields its nonce (decimal) if it is >= chain_nonce,
          otherwise removes the transaction from _known_transactions.
        - Iterates over tracked nonces in _known_nonces[addr], removing any
          nonce < chain_nonce, otherwise yielding it.
        - Yields outstanding nonces (integers).

    get_chain_nonce(addr) -> int
        Calls 'eth_getTransactionCount' with [addr, 'pending'], decodes to
        decimal and returns the chain's pending transaction count for addr.

    get_nonce(addr) -> int
        - Obtains chain_nonce via get_chain_nonce(addr).
        - Collects tracked nonces via _get_nonces_and_cleanup.
        - Returns max(0, chain_nonce, *tracked_txns).
        - If that value is 0 and there were no tracked nonces returns -1.
          (This behavior encodes "no prior txns" as -1 to callers that
          use get_nonce + 1 as a next-nonce strategy.)

    get_transaction_signature(serialized_txn)
        Abstract/placeholder — must be implemented by subclasses.
        Intended to return a signature for the provided serialized transaction.

    sign_and_serialize_transaction(transaction) -> bytes
        - Uses serialize_transaction(transaction) to get the transaction
          fields in the expected low-level structure.
        - Calls get_transaction_signature on the original transaction.
        - Uses add_signature_to_transaction(serialized_txn, signature)
          to combine the signature and the serialized form.
        - RLP-encodes the signed transaction using rlp.encode(..., Transaction).
        - Returns the signed-and-serialized bytes.

    construct_full_transaction(base_transaction) -> dict
        - Starts from base_transaction (typically from the user) and fills
          in default fields if missing:
            nonce -> get_nonce(txn_from) + 1
            gasPrice -> result of 'eth_gasPrice' RPC
            gas -> hex(90000)
            value -> '0x0'
            to -> ''
            data -> ''
        - Returns a new dict representing the full transaction to be signed.

Constants
    TXN_SENDING_METHODS : set
        A set of method names that this mixin treats as sending transactions:
        {'eth_sendTransaction', 'eth_sendRawTransaction', 'personal_signAndSendTransaction', 'personal_sendTransaction'}

Overridden request_blocking
    request_blocking(method, params) -> result
        - If method == 'eth_sendTransaction':
            - Takes the provided base transaction (params[0]),
              constructs a full transaction, signs and serializes it and
              sends it through 'eth_sendRawTransaction' using its hex form.
            - This effectively converts a normal sendTransaction call into
              a sendRawTransaction call using the mixin's signing routine.
        - Otherwise delegates to the wrapped manager's request_blocking.
        - After delegation: if method is in TXN_SENDING_METHODS the mixin
          performs additional tracking/handling related to the sent
          transaction (the implementation continues beyond the visible
          fragment to maintain _known_transactions/_known_nonces and/or
          decode raw tx hex). The complete tracking behavior is implemented
          in the remainder of the method.

Notes and error handling
------------------------
- RequestManager.request_blocking expects the provider to return either a
  JSON string or an already-decoded object. If the provider returns an
  unexpected type exceptions may occur in json decoding or result access.
- Errors returned by the JSON-RPC provider in the "error" key are
  surfaced as ValueError with the error payload.
- receive_blocking raises KeyError if an unknown request_id is provided.
- BaseSendRawTransactionMixin.get_transaction_signature is intentionally
  abstract; subclasses must supply signing logic (e.g., using a local key
  or a remote signer).
- The mixin assumes certain web3 utility functions are available for
  encoding and transaction serialization. Integration requires those
  helpers to be available in the runtime environment.

Typical usage patterns
----------------------
- Instantiate a RequestManager with a provider implementing make_request.
- Wrap the RequestManager with ManagerWrapper or extend it with the
  BaseSendRawTransactionMixin to enable transparent signing of
  eth_sendTransaction calls and to track locally-sent transaction nonces.
- For async usage, call request_async to spawn a request and later
  receive_blocking(request_id) to obtain its result.

Authors and dependencies
------------------------
- Relies on: gevent, rlp, and web3.utils helper modules (crypto, string,
  address, types, encoding, transactions).