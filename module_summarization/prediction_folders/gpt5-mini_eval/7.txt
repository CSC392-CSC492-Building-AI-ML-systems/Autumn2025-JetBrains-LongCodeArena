Using lists
===========

This document describes common and recommended ways to work with Python lists when writing code for the project. It covers creation, access, mutation, iteration, performance patterns for large sequences, safe use in threaded code, and simple guidance for serializing lists when storing them in external systems (for example, as attribute values on entities or for transport over an API).

Creating lists
--------------

- Literal construction:
  my_list = [1, 2, 3]

- From an iterable:
  my_list = list(some_iterable)

- Comprehensions:
  squares = [x * x for x in range(10)]

Accessing elements
------------------

- Indexing (zero-based):
  first = my_list[0]
  last = my_list[-1]    # negative indices allowed

- Slicing (returns a new list):
  sub = my_list[1:4]
  head = my_list[:3]
  tail = my_list[3:]

Iteration
---------

- Simple iteration:
  for item in my_list:
      process(item)

- With index:
  for i, item in enumerate(my_list):
      process(i, item)

- Use generator expressions or itertools for streaming large or computed sequences.

Mutating lists
--------------

- Append and extend:
  my_list.append(value)
  my_list.extend([a, b, c])

- Insert and remove:
  my_list.insert(index, value)
  my_list.remove(value)     # removes first matching value
  popped = my_list.pop()    # remove and return last (or pop(i))

- In-place operations:
  my_list.sort()            # sorts in-place
  my_list.reverse()

- Deleting:
  del my_list[2]
  del my_list[1:4]
  my_list.clear()           # empty the list

Searching and counting
----------------------

- Membership:
  if value in my_list:
      ...

- Position and frequency:
  index = my_list.index(value)   # raises ValueError if not found
  count = my_list.count(value)

Sorting and ordering
--------------------

- Non-destructive sorted():
  sorted_list = sorted(my_list)

- In-place sort with key and reverse:
  my_list.sort(key=lambda x: x.attr, reverse=True)

List comprehensions and generators
----------------------------------

- List comprehensions are concise and fast for building lists:
  evens = [n for n in range(100) if n % 2 == 0]

- Use generator expressions when you only need to iterate once or want to save memory:
  total = sum(x * x for x in large_iterable)

Working with large sequences
----------------------------

- Avoid building large intermediate lists when possible; use itertools and generator expressions.
- Use itertools.islice to slice iterators without materializing the whole sequence.
- Prefer streaming-processing approaches (map/filter/itertools) when processing many items.

Thread-safety
-------------

- Python lists are safe to read from multiple threads concurrently, but not safe for concurrent mutations.
- If multiple threads may modify the same list, protect mutations with threading.Lock or use a thread-safe collection.
- Minimize contention by limiting shared mutable state.

Serialization and storage
-------------------------

- To store lists in text-based fields (databases, JSON attributes, or APIs), serialize with json:
  serialized = json.dumps(my_list)
  my_list = json.loads(serialized)

- When storing lists as part of entity attributes or sending them via HTTP, prefer JSON-serializable elements (strings, numbers, booleans, null, lists, dicts).

- For stable identity or caching keys, consider hashing a canonical representation:
  key = hashlib.sha1(json.dumps(my_list, sort_keys=True).encode('utf-8')).hexdigest()

Practical notes for integration code
-----------------------------------

- Many project collection and query utilities expose list-like or iterable results. Treat these objects as sequences: iterate, slice, and use len() where supported. Consult the specific collection implementation for any lazy-loading behavior.

- When modifying list-like attributes stored on entities:
  - Deserialize the stored value (for example, via json.loads), modify the Python list, then reserialize (json.dumps) before storing.
  - If the system records operations (for example, a session's recorded operations or an operation log), ensure your changes are applied through the provided APIs so they are tracked and persisted correctly.

- Be mindful of auto-population or lazy-fetch behaviors in higher-level APIs. Accessing an attribute that represents a list may trigger a fetch; prefer explicit fetching or checks when that matters for performance.

Tips and best practices
-----------------------

- Prefer list comprehensions over manual loops for clarity and performance when building lists.
- Use tuple() for fixed-size, immutable sequences.
- Use sets for membership-heavy operations where order and duplicates are irrelevant.
- Keep lists of simple, JSON-serializable objects when they will be persisted or transported.
- For large datasets, stream processing with generators and itertools will reduce memory usage and improve responsiveness.

Examples
--------

Basic creation and mutation::

    tags = ['lighting', 'animation']
    tags.append('rig')
    tags = [t.upper() for t in tags]

Serializing for storage::

    stored = json.dumps(tags)
    # store `stored` on entity attribute
    loaded = json.loads(stored)  # ['LIGHTING', 'ANIMATION', 'RIG']

Using itertools for large sequences::

    from itertools import islice, chain
    stream = (compute(i) for i in range(10_000_000))
    first_100 = list(islice(stream, 100))

Further reading
---------------

- Python standard library docs on lists and itertools.
- JSON module docs for serialization and deserialization.