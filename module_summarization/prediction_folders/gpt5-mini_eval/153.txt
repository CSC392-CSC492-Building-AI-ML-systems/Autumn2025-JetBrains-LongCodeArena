Geometric Image Transformations
===============================

Overview
--------
This module provides core building blocks for geometric image transformations based on a pinhole camera model and related linear transforms. It is designed for batched, GPU-friendly workflows and exposes a compact PinholeCamera abstraction together with utilities for transforming points and inverting transformations.

PinholeCamera
-------------
The PinholeCamera class represents a pinhole camera with full 4x4 intrinsics and extrinsics stored in batch form. It is intended for use in multi-view, differentiable, and batched image-geometry pipelines.

Constructor
~~~~~~~~~~~
PinholeCamera(intrinsics, extrinsics, height, width)

- intrinsics: Tensor, shape (B, 4, 4)
  - Full 4x4 intrinsics (camera calibration) matrix in batch form.
- extrinsics: Tensor, shape (B, 4, 4)
  - Full 4x4 extrinsics (rotation + translation) matrix in batch form.
- height: Tensor, shape (B,)
  - Image height per batch element.
- width: Tensor, shape (B,)
  - Image width per batch element.

Notes
- All inputs are expected in batch form (first dimension B) so operations can be executed in parallel.
- Shapes are validated on construction. Intrinsics/extrinsics may also be provided with an extra leading dimension (BxNx4x4) when appropriate.

Properties
~~~~~~~~~~
- intrinsics -> Tensor (B, 4, 4)
  - Returns the full 4x4 intrinsics matrix.
- extrinsics -> Tensor (B, 4, 4)
  - Returns the full 4x4 extrinsics matrix.
- batch_size -> int
  - Batch size B.
- fx, fy -> Tensor (B,)
  - Focal lengths in x and y (from intrinsics[..., 0,0] and intrinsics[..., 1,1]).
- cx, cy -> Tensor (B,)
  - Principal point coordinates (from intrinsics[..., 0,2] and intrinsics[..., 1,2]).
- tx, ty, tz -> Tensor (B,)
  - Translation vector coordinates extracted from extrinsics. These also have setter accessors that allow in-place updates of the camera translation.
- rt_matrix -> Tensor (B, 3, 4)
  - 3x4 rotation-translation matrix (first 3 rows and 4 cols of extrinsics).
- camera_matrix -> Tensor (B, 3, 3)
  - 3x3 camera matrix containing intrinsics.
- rotation_matrix -> Tensor (B, 3, 3)
  - 3x3 rotation extracted from extrinsics.
- translation_vector -> Tensor (B, 3, 1)
  - 3x1 translation vector extracted from extrinsics.

Common workflows
----------------
1) Building a 3x4 projection matrix
   - Combine camera intrinsics and the 3x4 rotation-translation matrix:
     projection = camera.camera_matrix @ camera.rt_matrix
   - projection has shape (B, 3, 4).

2) Projecting 3D points (world -> image)
   - Given 3D world points in homogeneous form X_h (B, N, 4) or non-homogeneous (B, N, 3):
     - Transform world points into camera coordinates using extrinsics (or transform_points utility).
     - Apply the 3x3 camera matrix and perform homogeneous division to obtain image pixel coordinates (u, v).
   - Typical sequence:
     - X_cam = Rt @ X_world_h
     - x_proj = K @ X_cam[:3]
     - u = x_proj[..., 0] / x_proj[..., 2]; v = x_proj[..., 1] / x_proj[..., 2]

3) Changing camera pose
   - Update camera translation directly via tx, ty, tz setters or replace the extrinsics tensor.
   - Use inverse_transformation to invert extrinsics when mapping from camera to world or to compute relative poses.

Batch and differentiability
---------------------------
- All operations and properties are designed to operate on batched tensors (first dim B), enabling simultaneous processing of multiple cameras or views.
- When used with PyTorch tensors on supported devices (CPU/GPU), geometric transforms are differentiable and can be embedded in learning pipelines.

Example
-------
Code sketch showing projection matrix creation and projecting points (conceptual):

.. code-block:: python

    # camera: instance of PinholeCamera
    # world_points: tensor of shape (B, N, 3)

    # 1) Build projection matrix (B, 3, 4)
    P = camera.camera_matrix @ camera.rt_matrix

    # 2) Convert world points to homogeneous coordinates (B, N, 4)
    ones = torch.ones(B, N, 1, device=world_points.device, dtype=world_points.dtype)
    X_h = torch.cat([world_points, ones], dim=-1)

    # 3) Project: (B, 3, 4) @ (B, N, 4)^T -> (B, 3, N)
    X_proj = torch.matmul(P, X_h.unsqueeze(-1)).squeeze(-1)  # (B, 3, N)

    # 4) Homogeneous division -> (u, v)
    u = X_proj[:, 0, :] / X_proj[:, 2, :]
    v = X_proj[:, 1, :] / X_proj[:, 2:]

Utilities
---------
- inverse_transformation: compute the inverse of a 4x4 rigid transform (useful to go from camera->world).
- transform_points: apply a 4x4 transform to 3D points (handles homogeneous lifting and batched transforms).

See also
--------
- Use the provided camera properties and utilities together to build robust multi-view projection, reprojection, rectification, and pose-manipulation pipelines.
- The batched design enables efficient integration with other differentiable geometry operators.