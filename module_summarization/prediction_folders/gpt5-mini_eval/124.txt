Header Interface Transition Guide
=================================

This guide describes the behavior and migration considerations for the header verification
and notification utilities used by the header interface. It summarizes the verification
options, how verification results are reported, the error-list structure, and the
notification mixin API so callers can transition code that inspects, verifies, and
listens to header changes.

Summary
-------
- Verification is driven by the _Verify helper and controlled by a string
  option (see “Verification options”).
- Verification results are returned as a nested _ErrList structure; messages can be
  iterated with indentation via _ErrList.iter_lines().
- Errors and warnings are represented by VerifyError and VerifyWarning.
- NotifierMixin provides a simple weak-referenced listener pattern for header-like
  objects to notify listeners of changes.

Verification options
--------------------
The following options are supported (case-insensitive):

- ignore
- warn
- exception
- fix
- silentfix
- fix+ignore
- fix+warn
- fix+exception
- silentfix+ignore
- silentfix+warn
- silentfix+exception

Behavior summary:
- "ignore": do nothing.
- "warn": report problems as warnings (VerifyWarning).
- "exception": raise a VerifyError containing all reported messages.
- "fix": attempt to fix all fixable issues, then report according to the second
  component (default for unpaired "fix" is to raise exception for unfixable errors).
- "silentfix": attempt to fix fixable issues and suppress reporting of the fixes;
  the second component controls reporting of unfixable errors.

Combined forms (e.g. "fix+warn") split into a fix operation and a report operation.
When using "silentfix", fixed problems are not reported (unless the report option is
set to report unfixable issues).

Important note: verification messages include a short note:
"Note: astropy.io.fits uses zero-based indexing."

Programmatic usage
------------------
Typical use:
- Call verify(option) on an object that implements the verification protocol (this
  will call the object's internal _verify method and act according to the option).
- If option leads to reporting, warnings.warn(..., VerifyWarning) or VerifyError will be used.

Example:
- header.verify("warn")        -> emits VerifyWarning(s)
- header.verify("exception")   -> raises VerifyError with a combined message
- header.verify("fix+warn")    -> attempts fixes, emits warnings for remaining issues
- header.verify("silentfix")   -> attempts fixes and, if successful and no unfixable
                                issues remain, returns silently

Handling returned errors
------------------------
The internal verification results are represented as an _ErrList instance. Use
iter_lines(filter=None, shift=0) to obtain (fixable_flag, message) pairs with proper
indentation for nested structures. Behavior details:

- Each yielded item is either:
  - a tuple (fixable, message) where fixable is True/False/None, or
  - a tuple (None, header_message) used as a header for a nested block.
- iter_lines yields top-level non-_ErrList items first, then recurses into child
  _ErrList entries. The optional filter can be used to include/exclude lines
  based on their fixable flag.
- str(_ErrList) produces a newline-separated concatenation of iter_lines() messages.

Example iteration pattern:
- iterate over errs.iter_lines(filter=some_filter) to build a list of messages and
  to detect whether any unfixable items exist (the first element in each yielded
  tuple indicates fixability).

Verification helper behavior
---------------------------
The internal helper _Verify provides:

- run_option(option="warn", err_text="", fix_text="Fixed.", fix=None, fixable=True)
  - Decides whether to apply a fix() callable and constructs the text returned for
    that verification item. It returns (fixable, text). If fixable is False and
    option requests a fix, the message is prefixed with "Unfixable error:".
  - Options "warn" and "exception" will not perform fixes; they force fixable to
    False when computing the returned tuple.

- verify(option="warn")
  - Validates the option against the supported list, calls self._verify(opt) to
    collect _ErrList-like results, splits combined options into fix/report parts,
    filters lines when silentfix/fix+ignore variants are used, and then either
    warns or raises VerifyError with the assembled messages.

Exceptions and warnings
-----------------------
- VerifyError: raised when verification is requested to fail (e.g., option
  "exception" or when fix attempts leave unfixable errors and reporting mode
  escalates to an exception).
- VerifyWarning: subclass of AstropyUserWarning used to emit verification warnings.

Notification API (NotifierMixin)
--------------------------------
NotifierMixin provides an internal listener mechanism for objects (for example,
header containers) to notify interested listeners of changes.

Key points:
- Listeners are registered with weak references so they are dropped automatically
  when no other strong references exist.
- Use _add_listener(listener) to register; the mixin holds weak references internally.
- Use _notify(change_type, *args, **kwargs) to dispatch notifications. For each
  registered listener, _notify will attempt to call a method named
  _update_<change_type> on that listener with the supplied args and kwargs.
- If a listener does not implement the corresponding _update_<change_type> method,
  it is silently ignored.

This pattern allows decoupled components (e.g., a header object and an observing
UI or index builder) to stay in sync without requiring the notifier to know the
listener's concrete type.

Type and small utilities
------------------------
- path_like: tuple alias for (str, bytes, os.PathLike) for convenient input
  type checks where file-system-like paths are accepted.
- cmp(a, b): simple comparison returning -1/0/1 (a > b -> 1, a < b -> -1, equal -> 0).
- all_integer_types: (int, numpy.integer) — helper for integer-type checks.

Migration recommendations
-------------------------
1. Replace direct inspection of verification internals with calls to the public
   verify(option) method and handle VerifyError or VerifyWarning according to
   your desired policy.
2. Prefer "fix+warn" or "fix+exception" when moving to an environment where
   automatic correction is acceptable but you still want to be alerted to
   remaining problems.
3. Use "silentfix" only when you want fixes applied silently and you are
   confident no unfixable conditions should occur; otherwise pair it with an
   appropriate reporting option for unfixable issues.
4. When consuming verification results programmatically, iterate the returned
   _ErrList via iter_lines() rather than parsing string representations to
   preserve structure and fixability metadata.
5. To observe header changes (e.g., for GUI updates or caches), register a
   listener with _add_listener(listener). Implement _update_<change_type>
   methods on the listener to receive notifications.

Appendix — examples
-------------------
Calling verify and handling outcomes:

- Emit warnings:
  header.verify("warn")

- Auto-fix and warn about remaining issues:
  header.verify("fix+warn")

- Auto-fix, suppress reporting of fixed items, but raise on unfixable:
  header.verify("silentfix+exception")

- Raise an exception for any reported problem:
  try:
      header.verify("exception")
  except VerifyError as e:
      handle_error(e)

Iterating nested error lists:

- For a returned errs (_ErrList):
  for fixable, message in errs.iter_lines(filter=None):
      if fixable is not None and not fixable:
          handle_unfixable(message)
      else:
          process_message(message)

Registering a listener:

- Add a listener object that implements, for example, _update_change_type(self, *args):
  notifier._add_listener(listener)
  notifier._notify("change_type", arg1, key=value)

This guide is intended to help transition code to the header verification and
notification primitives summarized here. Use verify(...) with appropriate
options for controlled verification behavior and NotifierMixin to safely observe
header changes.