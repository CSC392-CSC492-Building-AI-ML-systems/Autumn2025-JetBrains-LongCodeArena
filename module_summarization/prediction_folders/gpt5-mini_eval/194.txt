Pairwise metrics, Affinities and Kernels
=======================================

Overview
--------
Pairwise metrics, affinities and kernels are utilities that compute similarity
or dissimilarity measures between all pairs of samples in one or two input
arrays. They are used throughout the library for clustering, nearest
neighbours, manifold learning, metrics evaluation and kernel methods.

- Pairwise distances: d(X, Y) returns an array of shape (n_samples_X,
  n_samples_Y) containing distances between rows of X and rows of Y.
- Affinities / kernels: k(X, Y) returns an affinity (similarity) matrix
  (often called a Gram matrix). For kernels, the Gram matrix K(X, X) is
  expected to be symmetric and (usually) positive semi-definite.

Input shapes and conventions
----------------------------
- X: array-like or sparse matrix of shape (n_samples_X, n_features).
- Y: array-like or sparse matrix of shape (n_samples_Y, n_features) or None.
  If Y is None, most pairwise functions treat Y as X (no copy; Y is a
  pointer to X when possible) and compute pairwise values within X.
- Pairwise (not precomputed) arrays require X.shape[1] == Y.shape[1].
- When a precomputed distance matrix is supplied (precomputed=True), X is
  interpreted as distances from queries (rows) to indexed samples (columns)
  and must satisfy X.shape[1] == Y.shape[0] (n_indexed).

Data types and sparsity
----------------------
- The pairwise utilities coerce inputs to floating dtypes suitable for the
  computations. A helper routine prefers to preserve float32 if both inputs
  are float32; otherwise float64 (float) is used.
- accept_sparse controls allowed sparse formats:
  - Default: 'csr' (convert allowed sparse inputs to CSR).
  - True: allow any sparse format.
  - False: raise an error on sparse inputs.
- Sparse inputs are supported for many pairwise metrics and kernels; some
  algorithms and kernel implementations use optimized sparse paths.

Input validation and options
----------------------------
Common validation is performed by utility functions used by pairwise
routines:

check_pairwise_arrays(X, Y, *, precomputed=False, dtype=None,
                      accept_sparse='csr', force_all_finite=True, copy=False)
- Ensures X and Y are array-like or sparse matrices and coerces them to the
  requested dtype (or an appropriate float dtype if dtype is None).
- If Y is None or Y is X, both are validated and set to the same object
  reference when possible (no unnecessary copy).
- precomputed:
  - False (default): standard feature-wise check X.shape[1] == Y.shape[1].
  - True: interprets X as a precomputed distance matrix and enforces
    X.shape[1] == Y.shape[0].
- dtype: requested dtype for the returned arrays. If None, dtype is chosen
  by the float-preserving policy described above.
- accept_sparse: allowed sparse formats (see above).
- force_all_finite: controls handling of infinite or missing values:
  - True (default): raise an error for np.inf, np.nan, pd.NA.
  - False: allow np.inf and np.nan.
  - 'allow-nan': allow np.nan/pd.NA but not infinite values.
  - This option was extended to accept the string 'allow-nan' to permit
    NaNs but not infinities.
- copy: if True, force a copy; otherwise conversion may or may not copy.

check_paired_arrays(X, Y)
- Used for paired distances (elementwise distances between corresponding
  rows of X and Y). It ensures X and Y are the same length along the sample
  axis and that dtypes and shapes are compatible for paired computations.

Behavioral notes
----------------
- Many pairwise routines use helpers for numerical stability and performance,
  such as safe sparse dot-products, row norms, and optimized kernels (e.g.
  a fast chi-squared kernel for dense inputs and optimized sparse L1
  distance computations).
- When Y is a reference to X (Y is None or Y is X), no unnecessary copies are
  made whenever possible.
- Precomputed distances are a common convention: passing precomputed=True
  changes the expectations on X and Y shapes and bypasses feature-wise
  compatibility checks.

Kernels and affinities
----------------------
- Kernels compute similarities: examples include linear, polynomial,
  RBF (Gaussian), sigmoid, and specialized kernels (e.g., chi2 kernel).
- Kernels should return a Gram matrix K of shape (n_samples_X, n_samples_Y).
  For many algorithms a symmetric K(X, X) is required.
- Affinity matrices are used by spectral clustering, manifold learning and
  other methods that rely on similarities rather than explicit feature
  vectors.

Examples (conceptual)
---------------------
- Pairwise distance matrix between samples of X:
  D = pairwise_distances(X)  # shape (n_samples, n_samples)
- Cross distances between arrays X and Y:
  D = pairwise_distances(X, Y)  # shape (n_samples_X, n_samples_Y)
- Precomputed distances (queries Ã— indexed):
  Dq = check_pairwise_arrays(Dq, X_indexed, precomputed=True)
- Kernel (Gram) matrix:
  K = pairwise_kernels(X, Y)  # shape (n_samples_X, n_samples_Y)

Implementation details
----------------------
- The library provides a consistent validation layer so that downstream
  pairwise implementations can assume correctly shaped, typed and
  finite-checked inputs.
- For performance and memory efficiency, many routines provide chunked
  computation (batches) and multithreading support. Sparse-specialized
  implementations (when available) are used for sparse inputs.

See also
--------
- Specific distance and kernel functions (e.g., euclidean, manhattan,
  cosine, rbf_kernel, linear_kernel) for per-metric semantics and
  parameters.
- The validation options documented above for details on dtype, sparsity
  and handling of missing/infinite values.