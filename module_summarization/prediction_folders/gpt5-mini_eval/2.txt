Encoding media
==============

This document describes the recommended approach for encoding media for use with ftrack using the ftrack-python-api. It covers authentication, session setup, an encoding workflow, registering encoded files, and common configuration options.

Overview
--------
Encoding media typically involves transcoding or repackaging source files into target formats (proxies, reviewables, delivery masters) and registering those encoded files with the ftrack server so they can be linked to versions, takes, or other entities. The ftrack API supplies the session, authentication, and storage access primitives; the actual encoding/transcoding is performed by external tools (ffmpeg, OpenTimelineIO workflows, renderers, etc.).

Requirements
------------
- ftrack-python-api installed and available in the environment.
- Access to the ftrack server (URL, API key and API user).
- Local or network storage location for encoded files; optionally a centralized storage configuration.
- Encoding toolchain (ffmpeg, compressor, renderer) appropriate for target formats.

Authentication and session setup
--------------------------------
Create a Session to authenticate with the ftrack server. The Session encapsulates server URL, API key and user, caching, plugin discovery and the event hub. For attaching authentication to HTTP requests (for example when uploading encoded files to server-backed accessors), use the SessionAuthentication helper which adds the ftrack headers to requests.

Example: create a session and authentication helper::

    from ftrack_api import Session
    from ftrack_api import SessionAuthentication

    session = Session(
        server_url='https://ftrack.example.com',
        api_key='YOUR_API_KEY',
        api_user='your.username'
    )

    auth = SessionAuthentication(api_key='YOUR_API_KEY', api_user='your.username')

Encoding workflow
-----------------
A typical workflow for encoding media and registering it with ftrack follows these steps:

1. Identify the source media:
   - Locate the Version or Take entity in ftrack and resolve the file path or the disk accessor that points to the source file.

2. Prepare encoding parameters:
   - Decide target format, bitrates, resolutions, codec, and filename convention (for example: version_<id>_proxy.mp4).

3. Execute the encoding:
   - Use your encoder (ffmpeg or other) to produce the encoded file(s) on disk or to a staging location (local or network share).

4. Validate outputs:
   - Ensure the encoded files exist and are readable; compute checksums (MD5/SHA1) if needed.

5. Register the encoded file with ftrack:
   - Create or update a representation or an attachment on the relevant ftrack entity so the encoded file is discoverable. Use the session to perform API operations atomically and to record the operation in ftrackâ€™s operation log.

6. Upload the file (if required):
   - If the server expects files to be uploaded (server-side storage), upload the encoded file using the accessor provided by the session or via HTTP with SessionAuthentication to ensure server-side headers are set.

7. Publish notifications:
   - Optionally publish an event or trigger a plugin that informs other systems that new encoded media is available.

Registering encoded files (pattern)
-----------------------------------
The exact API calls depend on your ftrack schema and whether you use representations, components, or attachments. The high-level pattern is:

- Query or fetch the target entity (Version, Take, Asset).
- Create a new file reference object (e.g. a component/representation) with metadata:
  - filename, file size, mime type, encoding profile, resolution, checksum.
- Associate the file reference with the target entity.
- Upload the file to the storage backend if necessary (use session authentication or the session-managed accessor).

Example pseudocode (illustrative)::

    # Resolve target version and local encoded path
    version = session.query("Version where id is <version-id>").one()
    encoded_path = "/staging/version_123_proxy.mp4"
    checksum = compute_sha1(encoded_path)

    # Create representation / attachment (example keys; adapt to your schema)
    representation = {
        'name': 'proxy',
        'filename': os.path.basename(encoded_path),
        'filesize': os.path.getsize(encoded_path),
        'checksum': checksum,
        'mimetype': 'video/mp4',
        'resolution': '1280x720',
        'encoding_profile': 'h264_proxy'
    }

    # Persist to ftrack (API calls will vary)
    # e.g. session.create('Representation', representation) or attach to version

    # Upload file if storage requires it (use SessionAuthentication for requests)
    import requests
    with open(encoded_path, 'rb') as fh:
        url = 'https://ftrack.example.com/upload/endpoint'
        requests.post(url, auth=SessionAuthentication(session._api_key, session._api_user), files={'file': fh})

Configuration hints
-------------------
- Use a consistent filename and folder structure for encoded media to make re-linking reliable.
- Store checksums and file sizes in the metadata when registering a file to allow integrity checks.
- If your environment uses centralized storage, ensure the session is configured for the same storage scheme and that accessors are able to resolve uploaded file locations.
- Use schema_cache_path on Session to enable schema caching and speed up repeated creation/lookup operations.

Best practices and tips
-----------------------
- Perform encoding on dedicated workers or render nodes and register results using a short-lived API session from that worker.
- Make encoding idempotent: if an encoded file with matching checksum already exists, skip re-encoding and simply register/upload if absent.
- Record encoding parameters (codec, bitrate, profile) as metadata so downstream tools can select appropriate assets.
- Keep file uploads atomic: upload to a temporary path then move into place once complete to avoid partially written files being used.
- Use the session's operation recording to group changes into a single, auditable operation in ftrack.

Troubleshooting
---------------
- Authentication errors: verify FTRACK_SERVER, FTRACK_API_KEY and FTRACK_API_USER are correct and that the account has permissions to create/modify representations or upload files.
- Upload failures: examine server-side storage configuration and ensure the request includes the SessionAuthentication headers if required.
- Missing files after registration: ensure that the storage accessor referenced by the ftrack entity can resolve the registered file path.

Further reading
---------------
- ftrack API reference for your ftrack-python-api version (for concrete entity types and field names).
- Storage/accessor documentation for details on how to upload and register files with the server-side storage solution in use.
- Encoding tool documentation (ffmpeg, renderers) for optimal transcode settings for proxies and reviewables.