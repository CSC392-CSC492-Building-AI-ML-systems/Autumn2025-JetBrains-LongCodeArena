Examples and Usage
==================

The `Field` class serves as the base type for all field definitions in Tortoise ORM models. It provides a flexible and extensible way to define how model attributes map to database columns, including support for primary keys, nullability, uniqueness, indexing, default values, and more.

Basic Field Definition
----------------------

When defining a model, you typically use subclasses of `Field` to specify the type and behavior of each attribute. For example:

.. code-block:: python

    from tortoise import fields
    from tortoise.models import Model

    class User(Model):
        id = fields.IntField(pk=True)
        username = fields.CharField(max_length=50, unique=True)
        email = fields.CharField(max_length=255, null=True)
        is_active = fields.BooleanField(default=True)

Field Parameters
----------------

- **source_field**: Use this to specify a custom database column name if it differs from the model attribute name.
- **generated**: Set to `True` if the field value is generated by the database (e.g., auto-increment).
- **pk**: Marks the field as the primary key. Only one primary key is allowed per model.
- **null**: Allows the field to be nullable in the database.
- **default**: Provides a default value or a callable that returns a default value when none is specified.
- **unique**: Enforces uniqueness on the field.
- **index**: Creates a database index on the field.
- **description**: Adds a description to the field, which appears in model descriptions and database comments.

Primary Key and Indexing
------------------------

If a field is marked as a primary key (`pk=True`), it is automatically indexed and unique. Attempting to set both `pk=True` and `null=True` will raise a configuration error, as primary keys cannot be nullable.

Default Values
--------------

The `default` parameter can be a static value or a callable. If a callable is provided, it will be called to generate a dynamic default value when creating new model instances.

Type Conversion
---------------

The `Field` class handles conversion between Python types and database types through the methods:

- `to_db_value(value, instance)`: Converts a Python value to a database-compatible value.
- `to_python_value(value)`: Converts a database value back to the appropriate Python type.

These methods can be overridden in subclasses to customize serialization and deserialization behavior.

Per-Database Customization
--------------------------

You can customize field behavior for specific database backends by defining an inner class named `_db__{SQL_DIALECT}` inside your field subclass. For example:

.. code-block:: python

    class CustomField(Field):
        SQL_TYPE = "VARCHAR(40)"

        class _db__sqlite:
            SQL_TYPE = "TEXT"
            skip_to_python_if_native = False

            def function_cast(self, term):
                from pypika import functions
                return functions.Cast(term, "NUMERIC")

This allows you to override SQL types, casting functions, and other attributes on a per-database basis.

Indexing Constraints
--------------------

Fields that are not indexable (`indexable = False`) cannot be marked as unique or indexed. Attempting to do so will raise a `ConfigurationError`.

Example Model Using Fields
--------------------------

.. code-block:: python

    from tortoise import fields
    from tortoise.models import Model

    class Product(Model):
        id = fields.IntField(pk=True)
        name = fields.CharField(max_length=100, unique=True, description="Product name")
        price = fields.DecimalField(max_digits=10, decimal_places=2, default=0.0)
        description = fields.TextField(null=True)
        created_at = fields.DatetimeField(auto_now_add=True, generated=True)

This example demonstrates defining various field types with different options such as primary key, uniqueness, nullability, default values, and descriptions.

Summary
-------

The `Field` base class provides a powerful and flexible foundation for defining model attributes in Tortoise ORM. By leveraging its parameters and customization options, you can precisely control how your models map to database schemas and how data is converted between Python and the database.