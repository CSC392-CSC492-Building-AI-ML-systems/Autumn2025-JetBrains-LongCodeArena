Iterables Utilities
===================

This module provides a collection of utility functions for working with iterables,
including flattening nested iterables, grouping elements, generating subsets, and
traversing tree-like structures.

Functions
---------

flatten(iterable, levels=None, cls=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Recursively denest iterable containers.

- If `levels` is specified, only that many levels of nesting are flattened.
- If `cls` is specified, only instances of that class are flattened.

Examples:

>>> flatten([1, 2, 3])
[1, 2, 3]
>>> flatten([1, 2, [3]])
[1, 2, 3]
>>> flatten([1, 2, [3, 4]])
[1, 2, 3, 4]
>>> flatten([[(-2, -1), (1, 2)], [(0, 0)]], levels=1)
[(-2, -1), (1, 2), (0, 0)]

unflatten(iter, n=2)
~~~~~~~~~~~~~~~~~~~~
Group the iterable `iter` into tuples of length `n`.

Raises a ValueError if the length of `iter` is not a multiple of `n`.

Example:

>>> unflatten([1, 2, 3, 4], 2)
[(1, 2), (3, 4)]

group(seq, multiple=True)
~~~~~~~~~~~~~~~~~~~~~~~~~
Splits a sequence into a list of lists of equal, adjacent elements.

- If `multiple` is True (default), returns groups as lists of repeated elements.
- If `multiple` is False, returns a list of tuples `(element, count)`.

Examples:

>>> group([1, 1, 1, 2, 2, 3])
[[1, 1, 1], [2, 2], [3]]
>>> group([1, 1, 1, 2, 2, 3], multiple=False)
[(1, 3), (2, 2), (3, 1)]

multiset(seq)
~~~~~~~~~~~~
Returns a dictionary representing the multiset of elements in `seq`,
where keys are elements and values are their multiplicities.

Example:

>>> multiset('mississippi')
{'m': 1, 'i': 4, 's': 4, 'p': 2}

postorder_traversal(node, keys=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Generator that performs a postorder traversal of a tree-like structure.

- Yields all subtrees in postorder (children before parent).
- If `keys` is provided, it is used to sort the children nodes.

Parameters:
- `node`: The root node to traverse.
- `keys`: Sorting key(s) for children nodes (default None).

Example:

>>> from diofant.abc import w, x, y, z
>>> list(postorder_traversal(w + (x + y)*z, keys=True))
[w, z, x, y, x + y, z*(x + y), w + z*(x + y)]

subsets(seq, k=None, repetition=False)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Generates all k-subsets (combinations) from the sequence `seq`.

- If `k` is None, generates all subsets of all lengths.
- If `repetition` is False (default), subsets are generated without repetition.

Examples:

>>> list(subsets([1, 2], 2))
[(1, 2)]
>>> list(subsets([1, 2]))
[(), (1,), (2,), (1, 2)]
>>> list(subsets([1, 2, 3], 2))
[(1, 2), (1, 3), (2, 3)]

See Also
--------
- `group` — for grouping adjacent equal elements.
- `multiset` — for counting element multiplicities.

---

This module is useful for manipulating and analyzing iterable data structures,
especially when dealing with nested or grouped data.