Asynchronous Queues for Coroutines
==================================

The `tornado.queues` module provides an asynchronous producer/consumer pattern designed specifically for use with coroutines. These queue classes facilitate coordination between producer and consumer coroutines, allowing items to be safely passed and processed asynchronously.

Unlike the standard library's `queue` module, the queues in this module are *not* thread-safe. To interact with these queues from other threads, use `.IOLoop.add_callback` to transfer control to the `.IOLoop` thread before calling any queue methods.

Overview
--------

The module offers several queue implementations similar to those found in Python's `asyncio` package, including:

- `Queue`: A basic FIFO queue.
- `PriorityQueue`: A queue where items are retrieved in priority order.
- `LifoQueue`: A last-in, first-out queue.

Additionally, two exceptions are defined for queue operations:

- `QueueFull`: Raised when attempting to put an item into a full queue without waiting.
- `QueueEmpty`: Raised when attempting to get an item from an empty queue without waiting.

Queue Class
-----------

The `Queue` class implements an asynchronous FIFO queue with optional size limits. It is designed to coordinate producer and consumer coroutines efficiently.

### Initialization

```python
q = Queue(maxsize=0)
```

- `maxsize` (int): The maximum number of items allowed in the queue. If zero (default), the queue size is unbounded.

### Basic Methods

- `put(item, timeout=None)`: Asynchronously put an item into the queue. If the queue is full, the coroutine waits until space is available or the optional `timeout` expires. Returns a `Future` that resolves when the item is enqueued.

- `put_nowait(item)`: Put an item into the queue without blocking. Raises `QueueFull` if the queue is full.

- `get(timeout=None)`: Asynchronously remove and return an item from the queue. If the queue is empty, the coroutine waits until an item is available or the optional `timeout` expires. Returns an awaitable resolving to the item.

- `get_nowait()`: Remove and return an item from the queue without blocking. Raises `QueueEmpty` if the queue is empty.

- `qsize()`: Return the current number of items in the queue.

- `empty()`: Return `True` if the queue is empty, `False` otherwise.

- `full()`: Return `True` if the queue is full, `False` otherwise.

- `task_done()`: Indicate that a formerly enqueued task is complete. Used to track when all tasks have been processed.

- `join()`: Block until all items in the queue have been processed (i.e., `task_done()` has been called for each item).

### Iteration Support

The `Queue` supports asynchronous iteration, allowing consumers to process items using `async for` syntax:

```python
async for item in q:
    # process item
    q.task_done()
```

Example Usage
-------------

```python
import asyncio
from tornado.ioloop import IOLoop
from tornado.queues import Queue

q = Queue(maxsize=2)

async def consumer():
    async for item in q:
        try:
            print('Doing work on %s' % item)
            await asyncio.sleep(0.01)
        finally:
            q.task_done()

async def producer():
    for item in range(5):
        await q.put(item)
        print('Put %s' % item)

async def main():
    # Start consumer without waiting (since it never finishes).
    IOLoop.current().spawn_callback(consumer)
    await producer()     # Wait for producer to put all tasks.
    await q.join()       # Wait for consumer to finish all tasks.
    print('Done')

asyncio.run(main())
```

Output:

```
Put 0
Put 1
Doing work on 0
Put 2
Doing work on 1
Put 3
Doing work on 2
Put 4
Doing work on 3
Doing work on 4
Done
```

Compatibility
-------------

For Python versions prior to 3.5 that lack native coroutine support, the consumer coroutine can be implemented using Tornado's `@gen.coroutine` decorator and `yield` syntax:

```python
@gen.coroutine
def consumer():
    while True:
        item = yield q.get()
        try:
            print('Doing work on %s' % item)
            yield gen.sleep(0.01)
        finally:
            q.task_done()
```

Timeouts
--------

The `put` and `get` methods accept an optional `timeout` parameter, which can be either a float representing a deadline (compatible with `IOLoop.time()`) or a `datetime.timedelta` object. If the operation does not complete before the timeout, a `tornado.util.TimeoutError` is raised.

Thread Safety
-------------

These queues are *not* thread-safe. To safely interact with a queue from another thread, use `.IOLoop.add_callback` to schedule queue operations on the IOLoop's thread.

Exceptions
----------

- `QueueFull`: Raised by `put_nowait` when the queue is at its maximum size.

- `QueueEmpty`: Raised by `get_nowait` when the queue has no items.

Summary
-------

The `tornado.queues` module provides efficient, coroutine-friendly queue implementations that enable asynchronous producer/consumer patterns. They integrate seamlessly with Tornado's IOLoop and coroutine system, supporting timeouts, task tracking, and asynchronous iteration.