Collection API
==============

The `collections` module provides support for collections of mapped entities within SQLAlchemy's ORM. It supplies the machinery used to inform the ORM of collection membership changes through an instrumentation via decoration approach. This allows arbitrary types, including built-in Python collections, to be used as entity collections without requiring inheritance from a base class.

Overview
--------

Instrumentation decoration relays membership change events to the `CollectionAttributeImpl` managing the collection. The decorators observe function call arguments and return values, tracking entities entering or leaving the collection.

Two main decorator approaches are provided:

1. **Generic Decorators**  
   These map function arguments and return values to events. For example:

   ```python
   from sqlalchemy.orm.collections import collection

   class MyClass:
       @collection.adds(1)
       def store(self, item):
           self.data.append(item)

       @collection.removes_return()
       def pop(self):
           return self.data.pop()
   ```

2. **Targeted Decorators**  
   These wrap appropriate append and remove notifiers around mutation methods present in standard Python collection interfaces (`list`, `set`, `dict`). They are hand-crafted for efficiency and may implement adapter-like behavior, such as mapping bulk-set methods (`extend`, `update`, `__setslice__`, etc.) into atomic mutation events required by the ORM.

Instrumentation Process
----------------------

Every collection class undergoes a transformation process during mapper compilation:

1. If the class is a built-in, a trivial subclass is substituted.
2. Check if the class is already instrumented.
3. Add generic decorators.
4. Detect the collection interface through duck-typing.
5. Add targeted decoration to any undecorated interface method.

This process modifies the class at runtime by decorating methods and adding bookkeeping properties. For built-in classes like `list`, trivial subclasses are used to hold decorations:

```python
class InstrumentedList(list):
    pass
```

Usage in Relationships
----------------------

Collection classes can be specified in `relationship(collection_class=...)` as types or as a callable returning an instance. The collection class is inspected and instrumented during mapper compilation. If a callable returns a built-in type like `list`, it will be adapted to produce instrumented instances.

Extending Known Types
---------------------

When extending known types like `list`, additional decorations are generally unnecessary because extension methods typically delegate to already instrumented methods. For example:

```python
class QueueIsh(list):
    def push(self, item):
        self.append(item)

    def shift(self):
        return self.pop(0)
```

Decorating these methods would cause duplicate events and should be avoided.

Bulk Operations and Exception Management
----------------------------------------

Targeted decorators try to avoid relying on other methods in the underlying collection class, but some dependencies exist (e.g., `__setitem__` needs `__getitem__`). Bulk methods like `update` and `extend` may be reimplemented in terms of atomic appends and removes, firing multiple append events instead of calling the underlying method.

For tight control over bulk operations and event firing, internal instrumentation within methods is possible. The `collection_adapter(self)` function retrieves an adapter object for explicit control over triggering append and remove events. The adapter also provides access to the owning object and the `CollectionAttributeImpl`, enabling sophisticated behaviors.

Key Components
--------------

- **collection**  
  A class providing decorators for entity collection classes. Decorators fall into two groups:

  - *Annotating decorators* (e.g., `appender`, `remover`, `iterator`, `converter`, `internally_instrumented`) indicate the method's purpose and take no arguments. They are used without parentheses:

    ```python
    @collection.appender
    def append(self, item):
        ...
    ```

  - *Recipe decorators* require parentheses, even if no arguments are passed (e.g., `adds()`, `removes_return()`):

    ```python
    @collection.adds('entity')
    def insert(self, position, entity):
        ...

    @collection.removes_return()
    def popitem(self):
        ...
    ```

- **collection_adapter(collection_instance)**  
  Returns an adapter object for the given collection instance, allowing explicit control over append and remove events.

- **MappedCollection, KeyFuncDict, attribute_keyed_dict, column_keyed_dict, keyfunc_mapping**  
  Various collection classes and utilities supporting key-based and attribute-based collection mappings.

Notes
-----

- The module uses a mutex lock to ensure thread-safe instrumentation.
- It supports both generic and targeted instrumentation strategies.
- The instrumentation assumes collection mutation methods do not raise unusual exceptions; for complex exception management, internal instrumentation is recommended.

License
-------

This module is part of SQLAlchemy and is released under the MIT License.

---

This documentation summarizes the purpose, usage, and key features of the `collections` module, which enables SQLAlchemy ORM to track and manage changes in entity collections efficiently and flexibly.