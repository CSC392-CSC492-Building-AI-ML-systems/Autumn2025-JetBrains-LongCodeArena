Model Usage
===========

The `Model` class is the core abstraction for defining database models. It provides a rich interface for defining fields, relationships, and querying the database asynchronously.

Defining Models
---------------

Models are defined by subclassing the `Model` class and declaring fields as class attributes. Fields can be of various types such as `IntField`, `ForeignKeyFieldInstance`, `ManyToManyFieldInstance`, and others.

Example:

```python
from tortoise import Model, fields

class User(Model):
    id = fields.IntField(pk=True)
    username = fields.CharField(max_length=50)
    email = fields.CharField(max_length=255, unique=True)
```

Meta Options
------------

Each model can define an inner `Meta` class to specify metadata options:

- `abstract`: If set to `True`, the model will not create a database table.
- `table`: Custom database table name.
- `app`: The application label for the model.
- `unique_together`: A tuple of tuples specifying sets of fields that must be unique together.
- `indexes`: A tuple of tuples specifying sets of fields to be indexed.
- `ordering`: A tuple specifying default ordering for querysets.

Example:

```python
class User(Model):
    # fields...

    class Meta:
        table = "auth_user"
        unique_together = (("username", "email"),)
        ordering = ("username",)
```

Fields and Relationships
------------------------

- **Basic Fields**: Define columns in the database, e.g., `IntField`, `CharField`.
- **ForeignKeyFieldInstance**: Defines a foreign key relationship to another model.
- **OneToOneFieldInstance**: Defines a one-to-one relationship.
- **ManyToManyFieldInstance**: Defines a many-to-many relationship.

Relationship fields provide asynchronous accessors to related objects:

- Foreign key fields use getter and setter methods to access related models.
- Reverse relations and many-to-many relations are accessed via special relation objects (`ReverseRelation`, `ManyToManyRelation`).

Querying
--------

Models support asynchronous querying using the `QuerySet` interface:

- `filter()`: Filter records by field values.
- `first()`: Retrieve the first record matching the query.
- `all()`: Retrieve all records.
- `order_by()`: Specify ordering of results.

Example:

```python
user = await User.filter(username="john").first()
users = await User.all().order_by("username")
```

Transactions
------------

Database operations can be performed within transactions using the `in_transaction` context manager to ensure atomicity.

Signals
-------

Models support signals for hooking into lifecycle events such as pre-save, post-save, pre-delete, and post-delete.

Comments and Documentation
--------------------------

Field comments can be extracted from source code comments placed immediately before field declarations using the `#:` syntax. These comments support multiline text and can include placeholders like `{model}` which will be replaced with the model class name.

Example:

```python
class User(Model):
    #: The unique username of the user
    username = fields.CharField(max_length=50)
```

This comment will be associated with the `username` field in the documentation.

Error Handling
--------------

The model layer raises various exceptions to handle errors:

- `ConfigurationError`: Raised for configuration issues.
- `IncompleteInstanceError`: Raised when an instance is incomplete.
- `IntegrityError`: Raised on database integrity violations.
- `OperationalError`: Raised on operational database errors.
- `TransactionManagementError`: Raised on transaction management issues.

Summary
-------

The `Model` class provides a powerful and flexible way to define and interact with database tables asynchronously. It supports rich field types, relationships, querying capabilities, transactions, and lifecycle signals, making it suitable for building complex data-driven applications.