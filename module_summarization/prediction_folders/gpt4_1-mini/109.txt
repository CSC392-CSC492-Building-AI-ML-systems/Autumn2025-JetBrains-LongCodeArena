async
=====

This module provides asynchronous scanning and counting plans for data acquisition in experimental setups. These plans are designed to work with 'readable' and 'settable' objects such as detectors and motors, enabling flexible and customizable data collection workflows.

Functions
---------

count(detectors, num=1, delay=None, *, per_shot=None, md=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Take one or more readings from detectors.

Parameters
~~~~~~~~~~
- **detectors** : list  
  List of 'readable' objects (e.g., detectors) from which to take readings.

- **num** : int or None, optional  
  Number of readings to take; default is 1.  
  If `None`, capture data until canceled.

- **delay** : iterable or scalar, optional  
  Time delay in seconds between successive readings; default is 0.  
  If an iterable, it must have at least `num - 1` entries.

- **per_shot** : callable, optional  
  Hook for customizing the action of the inner loop (messages per step).  
  Expected signature:  
  ```python
  def f(detectors: Iterable[OphydObj]) -> Generator[Msg]:
      ...
  ```

- **md** : dict, optional  
  Metadata dictionary to attach to the plan.

Notes
~~~~~
- If `delay` is an iterable, it must have at least `num - 1` entries or the plan will raise a `ValueError` during iteration.

Returns
~~~~~~~
A generator that yields messages to be consumed by a RunEngine.

list_scan(detectors, *args, per_step=None, md=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scan over one or more variables in steps simultaneously (inner product).

Parameters
~~~~~~~~~~
- **detectors** : list  
  List of 'readable' objects (e.g., detectors).

- **\*args** : variable length argument list  
  For one dimension: `motor, [point1, point2, ...]`.  
  For multiple dimensions:  
  ```python
  motor1, [point1, point2, ...],
  motor2, [point1, point2, ...],
  ...,
  motorN, [point1, point2, ...]
  ```  
  Motors can be any 'settable' object (motor, temperature controller, etc.).

- **per_step** : callable, optional  
  Hook for customizing the action of the inner loop (messages per step).  
  Expected signature:  
  ```python
  f(detectors, motor, step) -> plan (a generator)
  ```

- **md** : dict, optional  
  Metadata dictionary to attach to the plan.

Raises
~~~~~~
- `ValueError` if the number of points lists provided for each motor are not all the same length.

Returns
~~~~~~~
A generator that yields messages to be consumed by a RunEngine.

See Also
~~~~~~~~
- :func:`bluesky.plans.rel_list_scan`  
- :func:`bluesky.plans.list_grid_scan`  
- :func:`bluesky.plans.rel_list_grid_scan`  

rel_list_scan(detectors, *args, per_step=None, md=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scan over one or more variables in steps relative to current position.

Parameters
~~~~~~~~~~
- **detectors** : list  
  List of 'readable' objects (e.g., detectors).

- **\*args** : variable length argument list  
  For one dimension: `motor, [point1, point2, ...]`.  
  For multiple dimensions:  
  ```python
  motor1, [point1, point2, ...],
  motor2, [point1, point2, ...],
  ...,
  motorN, [point1, point2, ...]
  ```  
  Motors can be any 'settable' object (motor, temperature controller, etc.).  
  Points are relative to the current position.

- **per_step** : callable, optional  
  Hook for customizing the action of the inner loop (messages per step).  
  Expected signature:  
  ```python
  f(detectors, motor, step)
  ```

- **md** : dict, optional  
  Metadata dictionary to attach to the plan.

Returns
~~~~~~~
A generator that yields messages to be consumed by a RunEngine.

See Also
~~~~~~~~
- :func:`bluesky.plans.list_scan`  
- :func:`bluesky.plans.list_grid_scan`  
- :func:`bluesky.plans.rel_list_grid_scan`  

Notes
~~~~~
- This function is currently a placeholder and requires implementation.

General Notes
-------------

- These plans use decorators from the `preprocessors` module to stage devices and run the plan with metadata.
- The `per_shot` and `per_step` hooks allow users to customize the behavior of the inner loops during scanning or counting.
- Metadata dictionaries (`md`) are used extensively to provide context and hints for downstream consumers of the data.
- The plans support flexible delay specifications and can handle both fixed and iterable delays between steps.
- The `list_scan` plan internally uses a cycler pattern (`inner_list_product`) to generate the scan points.

This module is intended for use with asynchronous execution frameworks that consume generator-based plans for experimental control and data acquisition.