Plans
=====

This module provides a collection of experimental plans for data acquisition and scanning in scientific experiments. These plans are designed to work with detectors and motors (or other settable devices) to automate the process of collecting data at specified points or under certain conditions.

Functions
---------

count(detectors, num=1, delay=None, *, per_shot=None, md=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Take one or more readings from detectors.

Parameters
~~~~~~~~~~
- detectors : list  
  List of 'readable' objects (detectors) from which data will be collected.

- num : int or None, optional  
  Number of readings to take; default is 1.  
  If None, capture data until canceled.

- delay : iterable or scalar, optional  
  Time delay in seconds between successive readings; default is 0.

- per_shot : callable, optional  
  Hook for customizing action of inner loop (messages per step).  
  Expected signature:  
  ``def f(detectors: Iterable[OphydObj]) -> Generator[Msg]: ...``

- md : dict, optional  
  Metadata dictionary to be associated with the plan.

Notes
~~~~~
If `delay` is an iterable, it must have at least `num - 1` entries or the plan will raise a `ValueError` during iteration.

Returns
~~~~~~~
A generator that yields messages to be consumed by a RunEngine.

list_scan(detectors, *args, per_step=None, md=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scan over one or more variables in steps simultaneously (inner product).

Parameters
~~~~~~~~~~
- detectors : list  
  List of 'readable' objects (detectors).

- *args :  
  For one dimension, specify as ``motor, [point1, point2, ...]``.  
  For multiple dimensions, specify as pairs of motor and list of points:  
  ``motor1, [point1, point2, ...], motor2, [point1, point2, ...], ..., motorN, [point1, point2, ...]``  
  Motors can be any 'settable' object (motor, temperature controller, etc.).

- per_step : callable, optional  
  Hook for customizing action of inner loop (messages per step).  
  Expected signature:  
  ``f(detectors, motor, step) -> plan (a generator)``

- md : dict, optional  
  Metadata dictionary.

Raises
~~~~~~
- ValueError if the number of points lists does not match the number of motors or if the lengths of all point lists are not the same.

Returns
~~~~~~~
A generator that yields messages to be consumed by a RunEngine.

See Also
~~~~~~~~
- :func:`bluesky.plans.rel_list_scan`  
- :func:`bluesky.plans.list_grid_scan`  
- :func:`bluesky.plans.rel_list_grid_scan`

rel_list_scan(detectors, *args, per_step=None, md=None)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scan over one variable in steps relative to current position.

Parameters
~~~~~~~~~~
- detectors : list  
  List of 'readable' objects (detectors).

- *args :  
  For one dimension, specify as ``motor, [point1, point2, ...]``.  
  For multiple dimensions, specify as pairs of motor and list of relative points:  
  ``motor1, [point1, point2, ...], motor2, [point1, point2, ...], ..., motorN, [point1, point2, ...]``  
  Motors can be any 'settable' object (motor, temperature controller, etc.).  
  Points are relative to the current position.

- per_step : callable, optional  
  Hook for customizing action of inner loop (messages per step).  
  Expected signature:  
  ``f(detectors, motor, step)``

- md : dict, optional  
  Metadata dictionary.

Returns
~~~~~~~
A generator that yields messages to be consumed by a RunEngine.

See Also
~~~~~~~~
- :func:`bluesky.plans.list_scan`  
- :func:`bluesky.plans.list_grid_scan`  
- :func:`bluesky.plans.rel_list_grid_scan`

Notes
~~~~~
This function is currently a placeholder and requires implementation.

General Notes
-------------

- These plans use decorators for staging devices and running the plan with metadata.
- Metadata (`md`) dictionaries are used extensively to provide context and hints for data acquisition and analysis.
- The plans support hooks (`per_shot`, `per_step`) to customize behavior during data acquisition.
- The plans rely on external modules such as `plan_patterns` and `plan_stubs` for core functionality.
- The plans are designed to be used with a RunEngine that drives the execution of the generators.

This documentation covers the primary scanning and counting plans available in this module. Additional plans and utilities may be found in related modules.