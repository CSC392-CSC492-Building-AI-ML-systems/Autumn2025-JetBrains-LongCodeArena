Array Best Practices
====================

This document outlines best practices for working with arrays in Dask, particularly focusing on masked arrays and dispatch mechanisms that enable efficient and flexible array operations.

Dispatch Mechanism
------------------

Dask uses a dispatch system to handle various array operations such as concatenation, tensordot, einsum, and others. This system allows Dask to route operations to the appropriate backend or implementation, enabling compatibility with multiple array libraries and optimized computation.

Key dispatch objects include:

- `concatenate_lookup`
- `tensordot_lookup`
- `einsum_lookup`
- `empty_lookup`
- `divide_lookup`
- `percentile_lookup`
- `numel_lookup`
- `nannumel_lookup`
- `to_numpy_dispatch`
- `to_cupy_dispatch`

These dispatchers facilitate extensibility and backend-specific optimizations.

Masked Arrays in Dask
---------------------

Dask provides support for masked arrays, similar to NumPy's `numpy.ma` module, allowing for operations on arrays with missing or invalid data.

### Normalizing Masked Arrays

Dask normalizes masked arrays by considering their data, mask, and fill value components. This ensures consistent hashing and tokenization for caching and task graph optimizations.

### Creating Filled Arrays

The `filled` function returns a new array where masked elements are replaced with a specified fill value. This is useful for converting masked arrays into standard arrays for further processing.

```python
filled_array = filled(masked_array, fill_value=0)
```

### Masked Comparison Operations

Dask supports a variety of masked comparison operations that return masked arrays where elements satisfy certain conditions:

- `masked_greater`
- `masked_greater_equal`
- `masked_less`
- `masked_less_equal`
- `masked_not_equal`
- `masked_equal`

These functions are implemented using a blockwise approach, enabling efficient parallel computation.

### Masking Based on Conditions

Functions such as `masked_invalid`, `masked_inside`, `masked_outside`, and `masked_where` allow masking of array elements based on various criteria:

- `masked_invalid`: Masks invalid entries (e.g., NaNs or infinities).
- `masked_inside`: Masks elements inside a specified interval.
- `masked_outside`: Masks elements outside a specified interval.
- `masked_where`: Masks elements where a given condition is true.

### Masked Values with Tolerance

The `masked_values` function masks elements that are approximately equal to a given value, within specified relative (`rtol`) and absolute (`atol`) tolerances. This is useful for handling floating-point comparisons with numerical precision considerations.

### Fixing Invalid Data

The `fix_invalid` function replaces invalid entries in an array with a specified fill value, facilitating downstream computations that require valid data.

### Accessing Masked Array Data and Masks

- `getdata`: Retrieves the underlying data of a masked array, ignoring the mask.
- `getmaskarray`: Retrieves the mask array indicating which elements are masked.

General Best Practices
----------------------

- **Use `asanyarray` to Convert Inputs:** When working with Dask array functions, convert inputs using `asanyarray` to ensure compatibility and proper handling of Dask arrays and NumPy arrays.

- **Leverage Blockwise Operations:** Use `blockwise` and `map_blocks` to apply functions elementwise or blockwise across arrays. This approach enables parallelism and efficient computation.

- **Avoid Passing Arrays as Values in Masked Functions:** Functions like `masked_equal` and `masked_values` do not support array inputs for the `value` parameter. Use scalar values to avoid errors.

- **Ensure Shape Compatibility:** When using functions like `masked_where`, ensure that the condition array and the input array have compatible shapes to prevent indexing errors.

- **Use Derived Functions from NumPy Masked Array Module:** Dask provides many functions derived from `numpy.ma` to maintain API familiarity and ease of transition.

License
-------

Parts of the masked array functionality are derived from NumPy and are subject to the following license:

```
Copyright (c) 2005-2015, NumPy Developers.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
       copyright notice, this list of conditions and the following
       disclaimer in the documentation and/or other materials provided
       with the distribution.

    * Neither the name of the NumPy Developers nor the names of any
       contributors may be used to endorse or promote products derived
       from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

Summary
-------

By following these best practices, users can effectively utilize Dask arrays for large-scale, parallel, and masked array computations, leveraging familiar NumPy-like APIs while benefiting from Dask's scalability and flexibility.