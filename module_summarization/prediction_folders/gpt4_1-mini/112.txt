Generate Documentation for Code
===============================

This module provides a set of experimental plans for data acquisition and scanning in scientific instrumentation contexts. The plans are designed to work with detectors and motors (or other settable devices) to automate the process of collecting data points in a controlled manner.

Functions
---------

count(detectors, num=1, delay=None, *, per_shot=None, md=None)
    Take one or more readings from detectors.

    Parameters
    ----------
    detectors : list
        List of 'readable' objects (detectors) from which data is collected.
    num : int or None, optional
        Number of readings to take; default is 1.
        If None, capture data until canceled.
    delay : iterable or scalar, optional
        Time delay in seconds between successive readings; default is 0.
        If an iterable, it must have at least `num - 1` entries.
    per_shot : callable, optional
        Hook for customizing the action of the inner loop (messages per step).
        Expected signature:
        
            def f(detectors: Iterable[OphydObj]) -> Generator[Msg]:
                ...
    md : dict, optional
        Metadata dictionary to be associated with the plan.

    Notes
    -----
    The function yields messages that represent the data acquisition steps.
    Metadata includes detector names, number of points, intervals, and plan arguments.

list_scan(detectors, *args, per_step=None, md=None)
    Scan over one or more variables in steps simultaneously (inner product).

    Parameters
    ----------
    detectors : list
        List of 'readable' objects (detectors).
    *args :
        Arguments specifying motors and their positions. For one dimension:
        
            motor, [point1, point2, ...]
        
        For multiple dimensions:
        
            motor1, [point1, point2, ...],
            motor2, [point1, point2, ...],
            ...,
            motorN, [point1, point2, ...]
        
        Each motor is a 'settable' object (e.g., motor, temperature controller).
    per_step : callable, optional
        Hook for customizing the action of the inner loop (messages per step).
        Expected signature:
        
            f(detectors, motor, step) -> plan (a generator)
    md : dict, optional
        Metadata dictionary.

    Raises
    ------
    ValueError
        If the lengths of all position lists are not the same.

    See Also
    --------
    bluesky.plans.rel_list_scan
    bluesky.plans.list_grid_scan
    bluesky.plans.rel_list_grid_scan

    Notes
    -----
    The function constructs a plan that moves motors through specified positions
    simultaneously and collects data from detectors at each step.
    Metadata includes detector names, motor names, number of points, intervals,
    plan arguments, and hints for data visualization.

rel_list_scan(detectors, *args, per_step=None, md=None)
    Scan over one or more variables in steps relative to current position.

    Parameters
    ----------
    detectors : list
        List of 'readable' objects (detectors).
    *args :
        Arguments specifying motors and relative positions. For one dimension:
        
            motor, [point1, point2, ...]
        
        For multiple dimensions:
        
            motor1, [point1, point2, ...],
            motor2, [point1, point2, ...],
            ...,
            motorN, [point1, point2, ...]
        
        Each motor is a 'settable' object (e.g., motor, temperature controller).
        Positions are relative to the current location.
    per_step : callable, optional
        Hook for customizing the action of the inner loop (messages per step).
        Expected signature:
        
            f(detectors, motor, step)
    md : dict, optional
        Metadata dictionary.

    See Also
    --------
    bluesky.plans.list_scan
    bluesky.plans.list_grid_scan
    bluesky.plans.rel_list_grid_scan

    Notes
    -----
    This function is a placeholder and is not yet implemented.

General Notes
-------------

- The plans use decorators for staging devices and running the plan with metadata.
- Metadata dictionaries (`md`) are used extensively to store information about the plan,
  including detectors, motors, number of points, intervals, plan arguments, and hints.
- The plans yield messages that are interpreted by the Bluesky RunEngine to execute
  the experimental procedure.
- The module attempts to import `partition` from `cytools` for performance; if unavailable,
  it falls back to `toolz.partition`.
- The plans rely on helper modules such as `plan_patterns`, `utils`, `preprocessors`, and `plan_stubs`.

This documentation covers the primary scanning plans implemented in the code and their usage for automated data acquisition workflows.