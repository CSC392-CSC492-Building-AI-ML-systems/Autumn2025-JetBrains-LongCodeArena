Polynomial Factorization Routines
==================================

This module provides routines for factorization of polynomials over characteristic zero domains, with a focus on integer polynomials and algebraic number fields. It includes implementations of classical algorithms such as trial division, Zassenhaus factorization, and methods for handling multivariate polynomials.

Overview
--------

The core functionality is encapsulated in the `_Factor` mixin class, which offers various methods to factor polynomials efficiently and correctly. The factorization routines handle both univariate and multivariate polynomials, including those over algebraic number fields and integer coefficient rings.

Key Classes and Methods
-----------------------

### class _Factor

Mixin class providing polynomial factorization methods.

#### _trial_division(self, f, factors)

Performs trial division of polynomial `f` by a list of candidate `factors` to determine their multiplicities. Returns a sorted list of tuples `(factor, multiplicity)`.

#### _aa_factor_trager(self, f)

Factors multivariate polynomials over algebraic number fields using Trager's algorithm. It returns the leading coefficient and a list of irreducible factors with their multiplicities.

#### _zz_factor(self, f)

Factors polynomials with integer coefficients (`Z[X]`), including non square-free polynomials. The method computes the complete factorization into irreducibles over the integers:

    f = content(f) * f_1**k_1 * ... * f_n**k_n

The factorization process involves:

- Reducing the polynomial to a primitive square-free polynomial.
- Applying Zassenhaus or Enhanced Extended Zassenhaus (EEZ) algorithms.
- Using trial division to recover factor multiplicities.

Returns a tuple `(content(f), [(f_1, k_1), ..., (f_n, k_n)])`.

**Examples:**

```python
_, x = ring('x', ZZ)
(2*x**4 - 2).factor_list()
# Output: (2, [(x - 1, 1), (x + 1, 1), (x**2 + 1, 1)])

_, x, y = ring('x y', ZZ)
(2*x**2 - 2*y**2).factor_list()
# Output: (2, [(x - y, 1), (x + y, 1)])
```

#### _zz_mignotte_bound(self, f)

Computes the Mignotte bound for multivariate polynomials in `Z[X]`. This bound is used to estimate the size of coefficients of factors during factorization.

#### _zz_zassenhaus(self, f)

Factors primitive square-free univariate polynomials over the integers using the Zassenhaus algorithm. The method includes:

- Selecting a suitable prime `p` for modular factorization.
- Performing Hensel lifting to lift factors modulo higher powers of `p`.
- Combining lifted factors to recover the factorization over the integers.

Algorithmic Details
-------------------

- **Trial Division:** Used to determine the multiplicities of factors once candidate factors are found.
- **Zassenhaus Algorithm:** A classical algorithm for factoring univariate polynomials over the integers, involving modular factorization and Hensel lifting.
- **Trager's Algorithm:** Used for factoring multivariate polynomials over algebraic number fields.
- **Mignotte Bound:** Provides an upper bound on the size of coefficients of polynomial factors, aiding in the correctness and efficiency of factorization.

Dependencies
------------

The factorization routines rely on several auxiliary modules and functions:

- `query` from configuration for algorithmic options.
- Number theory utilities such as `factorint`, `isprime`, and `nextprime`.
- Modular arithmetic utilities like `symmetric_residue`.
- Custom exceptions for error handling: `CoercionFailedError`, `DomainError`, `EvaluationFailedError`, `ExtraneousFactorsError`.
- Utility functions such as `_sort_factors` for organizing factor lists.

References
----------

- Gathen, J. von zur, & Gerhard, J. (1999). *Modern Computer Algebra*. Cambridge University Press.

This module is designed to be integrated into a larger polynomial arithmetic framework, providing robust and efficient factorization capabilities for symbolic computation systems.