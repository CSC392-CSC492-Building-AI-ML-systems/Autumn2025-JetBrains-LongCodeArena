Contracts
=========

Interaction with Smart Contracts over Web3 Connector
----------------------------------------------------

This module provides a base class and utilities for interacting with Ethereum smart contracts using a Web3 connector. It allows you to create contract proxy classes from compiled Solidity contract ABIs, deploy new contracts, and interact with existing deployed contracts.

Contract Class
--------------

The `Contract` class serves as the base class for all contract proxy classes. It is designed to be subclassed by contract factory functions that take Solidity contract ABI definitions as input.

### Creating Contract Instances

You can create a contract proxy object for an existing deployed smart contract by providing its address and optionally overriding the ABI, code, runtime code, or source code:

```python
contract = Contract(
    abi=contract_abi,
    address='0x1234567890abcdef1234567890abcdef12345678',
    code=contract_bytecode,
    code_runtime=contract_runtime_bytecode,
    source=contract_source_code,
)
```

### Properties

- `abi`: Returns the contract ABI. Raises `AttributeError` if not specified.
- `code`: Returns the contract bytecode. Raises `AttributeError` if not specified.
- `code_runtime`: Returns the runtime bytecode of the contract. Raises `AttributeError` if not specified.
- `source`: Returns the source code of the contract. Raises `AttributeError` if not specified.
- `address`: The Ethereum address of the deployed contract instance.

### Deploying Contracts

Use the class method `deploy` to deploy a new contract to the blockchain:

```python
txn_hash = MyContract.deploy(
    transaction={
        'from': web3.eth.accounts[1],
        'value': 12345,
    },
    args=('DGD', 18),
)
```

- `transaction`: A dictionary of transaction parameters such as `from`, `gas`, `value`, etc.
- `args`: Positional arguments for the contract constructor.
- `kwargs`: Keyword arguments for the contract constructor.

The method returns the hexadecimal transaction hash of the deployment transaction.

**Note:** The contract class must have the contract bytecode (`code`) associated with it to be deployable.

### Encoding Contract Function Calls

The class method `encodeABI` encodes the arguments for a contract function call according to the Ethereum ABI specification:

```python
data = MyContract.encodeABI('transfer', args=(to_address, amount))
```

- `fn_name`: The name of the contract function.
- `args`: Positional arguments for the function.
- `kwargs`: Keyword arguments for the function.
- `data`: Optional data prefix, defaults to the function selector.

Returns the ABI-encoded data as a hexadecimal string.

### Event Handling

The instance method `on` allows registering callbacks to be triggered when specific contract events occur:

```python
contract.on('Transfer', {'filter': {'from': sender_address}}, callback_function)
```

- `event_name`: The name of the event to listen for.
- `filter_params`: Optional dictionary of filter parameters, including argument filters under the key `'filter'`.
- `callbacks`: One or more callback functions to be called when the event is detected.

This method sets up event filters and data extraction to handle event logs emitted by the contract.

Summary
-------

The `Contract` class and its associated methods provide a comprehensive interface for:

- Creating contract proxy objects for deployed contracts.
- Deploying new contracts to the blockchain.
- Encoding function calls according to the Ethereum ABI.
- Registering event listeners with filtering capabilities.

This enables seamless interaction with Ethereum smart contracts through a Pythonic API built on top of Web3.