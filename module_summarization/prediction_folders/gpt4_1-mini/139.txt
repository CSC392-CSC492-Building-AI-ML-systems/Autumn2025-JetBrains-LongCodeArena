Controlling Chunking
===================

Dask arrays are composed of many smaller NumPy arrays called *chunks*. Controlling how these chunks are created and managed is essential for optimizing performance and memory usage in Dask computations.

Chunking Basics
---------------

- **Chunks** are the fundamental units of computation in Dask arrays. Each chunk is a NumPy array, and Dask schedules operations on these chunks in parallel.
- The shape and size of chunks can significantly affect the efficiency of computations. Smaller chunks allow for more parallelism but may increase overhead, while larger chunks reduce overhead but may limit parallelism and increase memory usage.

Creating and Modifying Chunks
-----------------------------

- When creating a Dask array, you can specify the chunk size explicitly. For example:

  ```python
  import dask.array as da
  x = da.ones((1000, 1000), chunks=(100, 100))
  ```

- You can also rechunk an existing Dask array to change its chunk structure:

  ```python
  y = x.rechunk((200, 200))
  ```

- Rechunking can be useful to optimize computations that require specific chunk shapes or to balance memory and parallelism.

Chunking and Masked Arrays
--------------------------

Dask supports masked arrays through integration with NumPy's `numpy.ma` module. Operations on masked arrays are performed chunk-wise, preserving the chunking structure.

- Functions like `filled`, `masked_equal`, `masked_invalid`, `masked_inside`, `masked_outside`, `masked_where`, `masked_values`, `fix_invalid`, `getdata`, and `getmaskarray` operate on Dask arrays by applying the corresponding NumPy masked array functions to each chunk.
- These functions use `map_blocks` or `blockwise` internally to apply the masked array operations chunk-wise, ensuring that chunking is respected and maintained.

Example:

```python
import dask.array.ma as dma

a = dma.from_array(np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1]), chunks=2)
filled_array = dma.filled(a, fill_value=0)
```

Dispatch Mechanism
------------------

Dask uses a dispatch mechanism to handle various array operations efficiently across different backends and array types. This mechanism allows Dask to control how chunking and computation are performed internally.

- Dispatchers such as `concatenate_lookup`, `tensordot_lookup`, `einsum_lookup`, `empty_lookup`, `divide_lookup`, `percentile_lookup`, `numel_lookup`, `nannumel_lookup`, `to_numpy_dispatch`, and `to_cupy_dispatch` are used to route operations to the appropriate implementations depending on the array type and chunking.
- This design enables flexible and efficient chunk management and computation across different array types and hardware backends.

Summary
-------

Controlling chunking in Dask arrays is crucial for optimizing performance and resource usage. By specifying chunk sizes during array creation, rechunking arrays as needed, and leveraging Dask's support for masked arrays and dispatch mechanisms, users can fine-tune their computations to achieve the best balance between parallelism, memory consumption, and computational efficiency.