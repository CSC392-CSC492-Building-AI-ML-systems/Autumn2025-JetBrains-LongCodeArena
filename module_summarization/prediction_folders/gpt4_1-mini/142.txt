dask.delayed
=============

The `dask.delayed` interface provides a simple and flexible way to build task graphs for parallel and distributed computation. It allows you to wrap Python functions and values so that their execution is deferred until explicitly computed, enabling lazy evaluation and efficient scheduling.

Key Components
--------------

- **Delayed**: The core class representing a deferred computation. Instances of `Delayed` wrap a task and its dependencies, forming nodes in a Dask task graph.

- **delayed**: A function decorator and constructor that converts a Python function or value into a `Delayed` object.

Core Concepts
-------------

### Delayed Objects

A `Delayed` object represents a computation that has not yet been executed. It contains:

- A unique key identifying the task in the Dask graph.
- The task graph itself, which may include dependencies on other delayed objects.
- Methods to inspect and manipulate the task graph.

### Creating Delayed Objects

You can create delayed objects by:

- Wrapping functions with the `delayed` decorator.
- Wrapping values directly with `delayed(value, name)`.

Example:

```python
from dask import delayed

@delayed
def inc(x):
    return x + 1

@delayed
def add(x, y):
    return x + y

a = inc(1)
b = inc(2)
c = add(a, b)
```

In this example, `a`, `b`, and `c` are `Delayed` objects representing deferred computations.

### Task Graph Construction

The delayed interface automatically constructs a task graph by tracking dependencies between delayed objects. The graph is a dictionary mapping keys to tasks, where tasks are tuples describing function calls and their arguments.

### Unpacking Collections

The function `unpack_collections(expr)` normalizes Python objects by:

- Replacing `Delayed` objects with their keys.
- Converting literals to scheduler-friendly formats.
- Extracting and merging Dask graphs from all enclosed values.

This function supports various Python types including lists, tuples, sets, dictionaries, slices, dataclasses, and namedtuples, recursively unpacking delayed computations within them.

Example:

```python
task, collections = unpack_collections([a, b, 3])
# task: ['a', 'b', 3]
# collections: (Delayed('a'), Delayed('b'))
```

### Finalizing Computations

The `finalize(collection)` function wraps a Dask collection into a single `Delayed` object that represents the final computation, ensuring that the entire graph is executed when computed.

### Deprecated Functionality

The function `to_task_dask(expr)` was previously used to normalize Python objects and merge sub-graphs into a task and a Dask graph. It is now deprecated in favor of `unpack_collections`.

Usage Summary
-------------

- Use `delayed` to wrap functions and values for lazy evaluation.
- Compose delayed objects to build complex task graphs.
- Use `compute()` on delayed objects to execute the graph and retrieve results.
- Use `unpack_collections` internally to normalize and merge graphs.
- Use `finalize` to wrap collections into a single delayed computation.

Example Workflow
----------------

```python
from dask import delayed

@delayed
def inc(x):
    return x + 1

@delayed
def add(x, y):
    return x + y

a = inc(10)
b = inc(20)
c = add(a, b)

result = c.compute()  # Executes the graph and returns 32
```

This interface enables building complex, parallelizable workflows with minimal changes to existing Python code.

See Also
--------

- `dask.compute`: Execute one or more delayed objects in parallel.
- `dask.persist`: Persist delayed computations in memory.
- `dask.visualize`: Visualize the task graph of delayed objects.

---

This documentation covers the core interface and utility functions of the `dask.delayed` module, enabling users to leverage lazy evaluation and task graph construction for scalable computation.