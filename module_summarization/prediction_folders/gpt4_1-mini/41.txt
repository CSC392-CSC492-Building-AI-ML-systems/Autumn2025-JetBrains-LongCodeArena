QuerySet
========

The `QuerySet` is a powerful and flexible interface for building and executing database queries in an asynchronous environment. It allows you to construct complex queries using Pythonic expressions, including filtering, ordering, joining related models, and annotating with aggregate functions.

How to Use QuerySet to Build Your Queries
-----------------------------------------

### Creating a QuerySet

A `QuerySet` is typically obtained from a model class and represents a lazy database query. You can chain various methods to refine the query before execution.

### Filtering Queries

You can filter your queries using `Q` objects or keyword arguments to specify conditions. The filters are resolved and applied to the underlying SQL query, including support for related fields.

Example:

```python
queryset = MyModel.filter(field_name=value)
```

### Prefetching Related Objects

To optimize queries involving related models, use `prefetch_related()` to fetch related objects in a single query, reducing the number of database hits.

Example:

```python
queryset = MyModel.all().prefetch_related('related_field')
```

### Annotating Queries

You can add annotations to your queries using aggregate functions or custom expressions. This allows you to include computed fields in your results.

Example:

```python
from tortoise.functions import Count

queryset = MyModel.annotate(related_count=Count('related_field'))
```

### Selecting Specific Fields

Use `only()` to select a subset of fields from the model, which can improve performance by fetching only the necessary data.

Example:

```python
queryset = MyModel.all().only('id', 'name')
```

### Values and Values List

- `values()` returns dictionaries with specified fields.
- `values_list()` returns tuples or flat lists of field values.

Example:

```python
queryset = MyModel.all().values('id', 'name')
values_list = MyModel.all().values_list('id', flat=True)
```

### Ordering Results

You can specify the order of results using the `order_by()` method. Ordering supports ascending and descending order by prefixing the field name with `-` for descending.

Example:

```python
queryset = MyModel.all().order_by('name')        # Ascending order
queryset = MyModel.all().order_by('-created_at') # Descending order
```

The ordering mechanism supports ordering by related fields using double underscores (`__`) to traverse relationships.

### Joining Related Tables

When filtering or ordering by related fields, the `QuerySet` automatically performs the necessary SQL joins. This is handled internally by resolving the related fields and joining the appropriate tables with left outer joins.

### Executing Queries

`QuerySet` objects are awaitable. Awaiting a `QuerySet` will execute the query asynchronously and return the results.

- Awaiting a `QuerySetSingle` will return a single model instance.
- Awaiting a regular `QuerySet` will return a list of model instances.

Example:

```python
instance = await MyModel.get(id=1)  # Returns a single instance
instances = await MyModel.filter(active=True)  # Returns a list of instances
```

### Handling Annotations and Aggregates

When annotations with aggregate functions are present, the `QuerySet` automatically applies grouping by the primary key to ensure correct results.

### Error Handling

- `FieldError` is raised if you attempt to filter or order by a non-existent field or by a relation directly without specifying nested fields.
- `DoesNotExist` is raised when a query expecting a single result does not find any.
- `MultipleObjectsReturned` is raised when a query expecting a single result returns multiple.

Summary
-------

The `QuerySet` provides a rich API to build complex queries in an intuitive and efficient way. It supports:

- Filtering with complex conditions
- Prefetching related models
- Annotating with aggregate and custom functions
- Selecting specific fields
- Ordering results, including by related fields
- Automatic joining of related tables
- Asynchronous execution with awaitable queries

By leveraging these features, you can write expressive and performant database queries tailored to your application's needs.