Quick Start
===========

This document provides a quick overview of how to use the geometric path abstractions and utilities provided by the `toppra` library.

Overview
--------

The `toppra` library requires geometric paths that implement the abstract base class `AbstractGeometricPath`. This class defines the interface for geometric paths, which can be evaluated at any position along the path, including derivatives up to the second order.

Key Classes and Functions
-------------------------

### AbstractGeometricPath

This is the base class for all geometric paths. Any custom geometric path should inherit from this class and implement the following:

- `__call__(path_positions, order=0)`: Evaluate the path or its derivatives at given positions.
- `dof`: Property returning the degrees of freedom of the path.
- `path_interval`: Property returning the start and end positions of the path.
- `waypoints`: Optional property returning the waypoints of the path if applicable.

### propose_gridpoints(path, max_err_threshold=1e-4, max_iteration=100, max_seg_length=0.05)

This function generates gridpoints that sufficiently cover a given geometric path. It adaptively subdivides the path based on curvature and interpolation error to ensure accurate approximation.

Parameters:

- `path`: An instance of `AbstractGeometricPath`.
- `max_err_threshold`: Maximum allowable interpolation error.
- `max_iteration`: Maximum number of refinement iterations.
- `max_seg_length`: Maximum allowed segment length between gridpoints.

Returns:

- A sorted numpy array of gridpoints along the path.

Usage Example
-------------

Below is a simple example demonstrating how to use the `propose_gridpoints` function with a geometric path.

```python
import numpy as np
from toppra import propose_gridpoints, AbstractGeometricPath

# Define a custom geometric path by inheriting AbstractGeometricPath
class MyPath(AbstractGeometricPath):
    def __init__(self):
        self._dof = 2
        self._interval = np.array([0.0, 1.0])

    def __call__(self, path_positions, order=0):
        path_positions = np.atleast_1d(path_positions)
        if order == 0:
            # Example: simple linear path in 2D
            return np.vstack((path_positions, path_positions)).T
        elif order == 1:
            # First derivative (velocity)
            return np.tile(np.array([1.0, 1.0]), (len(path_positions), 1))
        elif order == 2:
            # Second derivative (acceleration)
            return np.zeros((len(path_positions), 2))
        else:
            raise ValueError("Order must be 0, 1, or 2")

    @property
    def dof(self):
        return self._dof

    @property
    def path_interval(self):
        return self._interval

# Instantiate the path
path = MyPath()

# Generate gridpoints for the path
gridpoints = propose_gridpoints(path, max_err_threshold=1e-4, max_iteration=50, max_seg_length=0.1)

print("Proposed gridpoints:", gridpoints)
```

Integration with OpenRAVE
-------------------------

If OpenRAVE is available, `toppra` provides the `RaveTrajectoryWrapper` class, which wraps OpenRAVE's `GenericTrajectory` objects as geometric paths. This wrapper supports trajectories with quadratic or cubic interpolation and converts them into piecewise polynomial representations compatible with `toppra`.

Summary
-------

- Implement your geometric path by subclassing `AbstractGeometricPath`.
- Use `propose_gridpoints` to generate an adaptive grid for your path.
- If using OpenRAVE, wrap trajectories with `RaveTrajectoryWrapper` for compatibility.
- Evaluate the path and its derivatives at any position using the `__call__` method.

This setup allows `toppra` to perform time-parameterization and trajectory optimization on a wide variety of geometric paths.