Storage Driver Documentation
============================

Overview
--------

The Storage driver module provides classes and interfaces to store arbitrary NetCDF (or other) options and describe how to handle them. It is designed to facilitate structured storage and retrieval of data variables on disk, supporting dynamic creation of variables and directories, and efficient read/write operations.

StorageInterfaceDirVar Class
----------------------------

The `StorageInterfaceDirVar` (SIDV) class is a versatile and dynamic interface representing variables and directories stored on disk. It provides a structured way to access and manipulate stored data by representing variables as properties of the storage interface or other SIDV instances.

Key Features:
- Dynamic creation of new variables and directories by accessing them as attributes.
- Data is not kept in memory but passed directly to the storage driver for writing or read on demand.
- Supports both fixed-size variables and appendable variables.
- Metadata buffering and management.
- Designed as an internal component of the storage system and not intended for direct instantiation by users.

Initialization
--------------

```python
StorageInterfaceDirVar(name, storage_interface, predecessor=None)
```

Parameters:
- `name` (str): The name of the storage variable or directory on disk. The full path is determined by the chain of predecessors.
- `storage_interface` (StorageInterface): The top-level interface handling IO operations and managing the storage driver.
- `predecessor` (StorageInterfaceDirVar, optional): The parent directory-like SIDV instance.

User Methods
------------

### write(data, at_index=None)

Write data to a variable that is either fixed-size or appendable at a specific index.

- If the variable does not exist on disk, it is created.
- Raises an error if called on a directory instance.
- If `at_index` is specified (integer), the data at that index in an appendable variable is overwritten.

Parameters:
- `data`: The data to write to disk. The storage system processes the data before writing.
- `at_index` (int or None, optional): Index at which to overwrite data in an appendable variable.

Example:
```python
import numpy as np
my_driver = NetCDFIODriver('my_store.nc')
my_store = StorageInterface(my_driver)
x = np.eye(3)
my_store.my_arr.write(x)
```

### append(data)

Append data to a variable whose size changes dynamically.

- If the variable does not exist, it is created with a dynamic first dimension.
- Raises an error if called on a directory instance.

Parameters:
- `data`: The data to append to the variable.

Example:
```python
my_driver = NetCDFIODriver('my_store.nc')
my_store = StorageInterface(my_driver)
x = 756
my_store.IAmADir.AnInt.append(x)
my_store.IAmADir.AnInt.append(x+1)
my_store.IAmADir.AnInt.append(x+2)
```

### read()

Read the variable and its data from disk.

- Raises an error if called on an unbound or directory instance.
- Returns the data stored on disk, processed back into a Python type and possibly converted into a Quantity with units.

Returns:
- The data read from the variable on disk.

Usage Notes
-----------

- The `StorageInterfaceDirVar` class is not intended to be instantiated directly by users. Instead, it is used internally by the `StorageInterface` class to provide a user-friendly API.
- Variables and directories are created dynamically by attribute access.
- The storage driver handles the actual IO operations and data management.
- Metadata is buffered and written to disk as needed.

Example Usage
-------------

```python
from iodrivers import NetCDFIODriver

# Create a storage driver instance
my_driver = NetCDFIODriver('my_store.nc')

# Create a storage interface with the driver
my_store = StorageInterface(my_driver)

# Write a numpy array to a variable
import numpy as np
x = np.eye(3)
my_store.my_arr.write(x)

# Append data to a variable inside a directory
my_store.IAmADir.AnInt.append(756)
my_store.IAmADir.AnInt.append(757)

# Read data back from a variable
data = my_store.my_arr.read()
```

Summary
-------

The storage driver and its associated classes provide a flexible and powerful interface for managing data storage in NetCDF or similar formats. By abstracting the details of file IO and data handling, it allows users to focus on their data and its structure, while ensuring efficient and consistent storage operations.