Conditions
===========

Overview
--------

A condition is a boolean expression used to select a subset of rows from a Table (or related PyTables structures) by applying a filter. Conditions are provided as strings to methods such as Table.where(), read_where(), or similar querying interfaces. When possible, PyTables uses available indexes on the involved columns to speed up evaluation; otherwise a full scan is performed.

Syntax
------

- Atomic expressions have the form: column operator value
  - column: the name of a column in the table
  - operator: one of ==, !=, <, <=, >, >=
  - value: a scalar value (numbers or strings; strings must be quoted)

- Combination of conditions:
  - Use bitwise operators to combine expressions:
    - & for logical AND
    - | for logical OR
    - ~ for logical NOT
  - Parentheses can be used to group sub-expressions and control precedence

- Example expressions:
  - table.where('(age > 20) & (status == "A")')
  - table.read_where('(score >= 90) | (grade == "A")')
  - table.where('~(flag == 0)')

Notes
-----

- Expressions reference column names in the target table. All comparisons are performed row-by-row unless an index is available.

Indexing and performance
------------------------

- PyTables maintains indexes on table columns to speed up condition evaluation.
- If a condition references a column with a suitable index, the query engine will use the index to reduce the search space.
- Auto-indexing:
  - There is a default policy to automatically update indexes after operations that modify the table (controlled by default_auto_index, which is True by default).
  - Index kinds may vary in fidelity and storage: ultralight, light, medium, and full (covering increasing levels of row-position tracking).

Internal condition cache
------------------------

- PyTables uses a Condition Cache to store results of condition evaluations for efficiency.
- When an index becomes dirty (out of sync with the underlying data), the condition cache is notified by “nailing” it to invalidate cached results.
- When the index is updated and returns to a clean state, the nail is removed (“unnail”).
- The cache is managed automatically; users typically do not interact with it directly, but it is part of how PyTables keeps query results correct after data modifications.

Examples
--------

- Simple filter on a numeric column:
  - table.where('(temperature > 300)')

- Combined conditions with AND/OR:
  - table.where('(temperature > 300) & (humidity < 0.5)')

- Negation:
  - table.where('~(status == "inactive")')