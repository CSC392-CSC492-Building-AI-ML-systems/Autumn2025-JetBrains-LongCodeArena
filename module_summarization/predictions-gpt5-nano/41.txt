QuerySet: How to Build Your Queries
====================================

Overview
--------
QuerySet provides a fluent API to construct database queries using a programmatic approach. It supports:

- Filtering with Q objects and simple field lookups
- Joins and traversal of related models
- Prefetching related data for efficient access
- Annotations and aggregations (e.g., counting related items)
- Selecting only specific fields (values, values_list)
- Sorting/ordering of results

Starting a Query
---------------
- Start from a model to obtain a QuerySet:
  - User.all()
  - User.filter(...) (optionally with Q objects)
- The QuerySet is awaitable; awaiting it resolves to the results (single instance or a sequence, depending on how you use the API).

Examples
--------
- Basic filter
  - await User.filter(Q(name="Alice") & Q(is_active=True))
- Simple all items
  - await User.all()

Prefetching Related Data
-----------------------
Prefetch related data to avoid N+1 queries and to load related objects efficiently.

- Example:
  - await User.prefetch_related("posts", Prefetch("profile"))

Annotating and Aggregating
--------------------------
Annotate lets you create computed fields (aggregations) that you can sort or filter on.

- Count related items:
  - from tortoise.functions import Count
  - await User.annotate(post_count=Count("posts"))
- Use the annotation in ordering:
  - await User.annotate(post_count=Count("posts")).order_by("-post_count")

Selecting Fields
----------------
- values_list: retrieve specific fields as tuples (optionally flat)
  - rows = await User.values_list("id", "name")
  - flat=True if you want a single field per row
- values: retrieve dictionaries with specified fields
  - dicts = await User.values("id", "name", "email")

Filtering on Related Fields
---------------------------
QuerySet supports filtering on related models directly by using field lookups separated by __.

- Filter by a related field:
  - await User.filter(Q(profile__bio__icontains="engineer"))
- Filter across relationships and nested fields will trigger the appropriate joins:
  - The library will automatically join related tables as needed.

Ordering
--------
Apply ordering to the results. You can use simple field-based ordering or a more explicit tuple form.

- Simple descending/ascending:
  - await User.order_by("-created_at")  # newest first
  - await User.order_by("name")        # alphabetical
- Explicit (field, direction) tuples:
  - await User.resolve_ordering(model, table, [("name", "asc"), ("created_at", "desc")], {})

Handling Special Cases
----------------------
- Exceptions you may encounter:
  - DoesNotExist: No matching object for retrieval
  - MultipleObjectsReturned: More than one object returned where one was expected
  - FieldError: Unknown field or invalid field lookup
  - ParamsError: Incorrect query parameters supplied

Notes on Query Resolution
-------------------------
- Internal process:
  - resolve_filters builds where clauses, applies Q objects, and handles custom filters
  - Joins are added for related fields as needed
  - _wheres and _havings are set on the query builder
  - If the query uses aggregates, and there are joins or having/order components, a groupby is added automatically
- Ordering across relations:
  - If an ordering uses a nested field (e.g., related_model__field), the library joins the related table and recursively applies ordering
- Prefetching is recommended when you will access related data after the initial query to minimize database round-trips

Code Snippet: Common Usage Pattern
----------------------------------
.. code-block:: python

   from tortoise.query_utils import Q
   from tortoise.functions import Count

   # Basic filter
   users = await User.filter(Q(name="Alice") & Q(is_active=True))

   # Prefetch related data
   users = await User.prefetch_related("posts", Prefetch("profile"))

   # Annotation and aggregation
   users_with_counts = await User.annotate(post_count=Count("posts")).order_by("-post_count")

   # Selecting specific fields
   ids_and_names = await User.values_list("id", "name")
   simple_names = await User.values_list("name", flat=True)

   # Filtering on related fields
   active_authors = await User.filter(Q(posts__title__icontains="intro"))

Usage notes
-----------
- Use Q objects for complex filters and combining conditions.
- Use Prefetch to optimize related data access patterns.
- Use annotations to derive computed values for filtering or ordering.
- Use values/values_list to optimize data transfer when only specific fields are needed.

This documentation describes how to use the QuerySet API to build and execute queries, including filtering, joining, prefetching, annotating, selecting fields, and ordering.