Plans
=====


Overview
--------

This document documents the planning helpers provided by the code. The module exposes three plans to drive detectors and motors:

- count: Take one or more readings from detectors.
- list_scan: Scan multiple motors over specified positions (inner product).
- rel_list_scan: Scaffold for a relative-position scan (not yet implemented).

count
-----

Signature
- count(detectors, num=1, delay=None, *, per_shot=None, md=None)

Description
- Take one or more readings from detectors.

Parameters
- detectors: list
  - A list of readable detector objects (e.g., Ophyd objects).
- num: int, optional
  - Number of readings to take. If None, capture data until canceled.
- delay: iterable or scalar, optional
  - Time delay in seconds between successive readings. Default is 0.
  - If an iterable is provided, it must have at least num - 1 entries; otherwise a ValueError is raised during iteration.
- per_shot: callable, optional
  - Hook for customizing the action of the inner loop (messages per step).
  - Expected signature: f(detectors) -> Generator[Msg, ...]
- md: dict, optional
  - Metadata to attach to the plan.

Behavior and Metadata
- Builds an internal metadata dictionary (_md) containing:
  - detectors: names of the detectors
  - num_points: the value of num
  - num_intervals: num - 1 (or None if num is None)
  - plan_args: representation of detectors and num
  - plan_name: 'count'
  - hints: dictionary (dimensions default to time/primary if provided)
- If per_shot is not provided, it defaults to bps.one_shot.
- The inner plan yields from bps.repeat(partial(per_shot, detectors), num=num, delay=delay).

Return
- Returns a generator yielded by inner_count().

Notes
- This plan is designed to be used in bluesky environments where detectors are read serially or in short sequences.
- The md dictionary is extended with any user-provided metadata (md).

Example
- A simple usage example (conceptual):

  count(detectors=[det1, det2], num=5, delay=0.1)

Related concepts
- Uses plan_stubs (bps) and preprocessors (bpp) to wrap the inner generator.
- Metadata is prepared for downstream plan cataloging and visualization.


list_scan
---------

Signature
- list_scan(detectors, *args, per_step=None, md=None)

Description
- Scan over one or more variables in steps simultaneously (inner product).

Parameters
- detectors: list
  - A list of readable detector objects.
- args: pairs
  - For one dimension: motor, [point1, point2, ...].
  - In general: motor1, [points], motor2, [points], ..., motorN, [points].
- per_step: callable, optional
  - Hook for customizing the action of the inner loop (messages per step).
  - Expected signature: f(detectors, motor, step) -> plan (generator)
- md: dict, optional
  - Metadata to attach to the plan.

Behavior and Metadata
- Validates that the number of motors matches the number of position lists (even length of args).
- Builds an internal _md with:
  - detectors: names of the detectors
  - motors: list of motor names
  - num_points: number of steps per motor (length)
  - num_intervals: length - 1
  - plan_args: representation of detectors and per-step arguments
  - plan_name: 'list_scan'
  - plan_pattern: 'inner_list_product'
  - plan_pattern_module: plan_patterns.__name__
  - plan_pattern_args: {'args': md_args}
  - hints: default hints (dimensions) derived from motor hints if available
- Computes x_fields from motor hints (fields) and establishes default_dimensions.
- Merges user-provided hints (md['hints']) on top of defaults.
- Obtains a full cycler via plan_patterns.inner_list_product(args).
- Delegates to scan_nd(detectors, full_cycler, per_step=per_step, md=_md) and yields from it.

Return
- Returns a generator yielded by scan_nd(...).

See Also
- bluesky.plans.rel_list_scan
- bluesky.plans.list_grid_scan
- bluesky.plans.rel_list_grid_scan

Notes
- This plan relies on plan_patterns.inner_list_product to generate the product of the provided motors and their points.
- The planâ€™s metadata is crafted to describe the plan name, pattern, and inputs for introspection and plotting.

Example
- A conceptual usage example:

  list_scan(detectors=[det1], motor1, [0, 1, 2], motor2, [10, 20, 30])

Related concepts
- Uses plan_patterns for generating the scan space.
- Mirrors typical bluesky list scan patterns with an inner product approach.

rel_list_scan
-------------

Signature
- rel_list_scan(detectors, *args, per_step=None, md=None)

Description
- Intended to scan over one variable in steps relative to the current position.

Parameters
- detectors: list
  - A list of readable detector objects.
- args: pairs
  - For one dimension: motor, [points], where points are relative to the current motor position.
- per_step: callable, optional
  - Hook for customizing the action of the inner loop (messages per step).
- md: dict, optional
  - Metadata to attach to the plan.

Notes
- This plan is currently a placeholder (TODO) and is not implemented in the code.
- The docstring describes the intended behavior and signatures, but no functional implementation is present yet.

Return
- Not implemented in the current codebase; raises or returns None if invoked.

Example
- Planned usage (conceptual):

  rel_list_scan(detectors=[det1], motor1, [0.5, 1.0, 1.5])

Additional Metadata and Dependencies
------------------------------------

- plan_patterns: Provides inner_list_product and related scan pattern helpers.
- bpp (preprocessors): Supplies stage and run decorators used to wrap plans.
- bps (plan_stubs): Provides stubs like one_shot and repeat used in count.
- Msg: Message type for per-shot communications (from utils).
- The code expects detectors to have a .name attribute for metadata construction.

Notes for Documentation Consumers
-------------------------------

- The plans integrate with Bluesky conventions for plan metadata, hints, and plan patterns.
- Users should ensure detectors and motors provide appropriate interfaces (e.g., .name, .hints.fields).
- The rel_list_scan plan is not yet implemented; contributions are welcome to complete this plan.