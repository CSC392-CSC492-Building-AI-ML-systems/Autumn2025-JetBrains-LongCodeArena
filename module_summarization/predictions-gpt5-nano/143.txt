Memory Management
=================

Overview
--------
This guide documents how memory is accounted for, tracked, and managed when using the distributed computing system. It focuses on how data size, serialization, data locality, and futures influence memory usage across clients and workers.

Memory accounting
-----------------
- Object sizing
  - The system uses a size estimation utility (sizeof) to determine the memory footprint of Python objects. This helps in understanding how much memory a datum or result consumes.
- Presenting sizes
  - Size measurements are formatted for readability using a human-friendly formatter (format_bytes).
- Serialization and payload size
  - Data that is moved between processes or over the network is serialized. Serialization helpers (dumps, loads, to_serialize) determine how objects are prepared for transport.
  - A check (is dumpsable) ensures only serializable objects are sent to workers, preventing unexpected memory growth from non-serializable payloads.

Data locality and residency
---------------------------
- Location tracking
  - HasWhat and WhoHas track which data keys are present on which workers. This enables informed decisions about where to perform computations and how to minimize data movement and memory pressure.
- Scheduler visibility
  - The scheduler is aware of data residency, allowing it to optimize task placement based on current memory availability and data locality.

Futures and memory lifecycle
----------------------------
- Remote computations
  - Futures act as local proxies for results computed on remote workers. They carry a key that identifies the remote data and track the state of the computation.
- Memory implications
  - Creating and managing a Future involves maintaining references and state information both locally and on the scheduler/worker(s). The system records the lifecycle of futures to understand when memory associated with results can be released or reused.
- State management
  - Each Future maintains internal state (e.g., whether the result is ready or failed) and interacts with the client to request updates about needed keys, influencing memory usage and lifecycle decisions.

Global references and leak prevention
-------------------------------------
- Weak references
  - Global client registries are implemented with weak references to prevent memory leaks when clients are no longer in use. This helps ensure that orphaned client objects do not keep memory alive unnecessarily.

Monitoring and tooling
----------------------
- Observability
  - Memory-related information can be surfaced alongside other diagnostics. Metrics and dashboards (where available) help monitor object sizes, data locality, and serialization overhead to diagnose memory pressure.

Tips and best practices
-----------------------
- Be mindful of object sizes
  - Before transferring large objects, estimate their size and consider strategies to reduce payloads or chunk data.
- Favor locality
  - Place computations on workers that already hold the necessary data to minimize memory duplication and transfer costs.
- Use serialization judiciously
  - Ensure objects are serializable and efficient to serialize; avoid including large, unnecessary payloads in task arguments or results.
- Manage futures actively
  - Track futures and release references when results are no longer needed to allow memory to be freed.
- Leverage weak references
  - Rely on weakly-referenced registries to prevent unintended retention of clients or related objects.

API and internals (reference)
------------------------------
Key components related to memory management include:
- sizeof: utility to estimate Python object size
- format_bytes: human-friendly size formatting
- dumps / loads: serialization utilities
- to_serialize: determines how objects are prepared for transport
- _is_dumpable: check for serializability
- HasWhat / WhoHas: data residency information (which worker has which data)
- Future: local proxy for remotely computed results and its lifecycle
- weakref.WeakValueDictionary: memory-safe global client registry

This documentation reflects how memory usage is influenced by data size, serialization, data locality, and the lifecycle of futures within the distributed system.