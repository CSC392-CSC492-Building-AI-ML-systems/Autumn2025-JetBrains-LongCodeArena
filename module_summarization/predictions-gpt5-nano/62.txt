Visitors
========

Overview
--------
The sql.visitors module provides a visitor/traversal interface used by SQLAlchemy's compiler
to dispatch to visitor objects. It defines the core protocol and symbols that support
traversal of SQL expression trees and internal structures. The module is designed to be
extensible via a dynamic dispatch mechanism and to support both internal and external
traversal needs.

Public API
----------
The public API, as exposed by this module, includes the following symbols:

- iterate
- traverse_using
- traverse
- cloned_traverse
- replacement_traverse
- Visitable
- ExternalTraversal
- InternalTraversal
- anon_map

Notes:
- __all__ in the module lists these public names, which are the intended surface for external users.
- anon_map is provided via a compatibility import path that may come from a cython extension or from a Python fallback depending on the environment.

Key Concepts
------------
- Visitable: Base class for objects that participate in the traversal/dispatch mechanism.
  - Subclasses must define a __visit_name__ at the class level.
  - When a subclass is created, it automatically generates a _compiler_dispatch method (unless one is provided directly).
  - The generated _compiler_dispatch looks for a visitor method named visit_<visit_name> on the visitor object and calls it with the same keyword arguments.
  - If the corresponding visitor method does not exist, the code falls back to visitor.visit_unsupported_compilation(self, err, **kw).
  - The mechanism preserves the original dispatch function (via _original_compiler_dispatch) to support overrides by other components.
  - __class_getitem__ is supported to allow generic-style usage in Python 3.9+.

- InternalTraversal: Enum used to define symbols for internal traversal. It is used both as a superclass for objects implementing visit methods and as the keys within the _traverse_internals collection on those objects.
  - Typical members include:
    - dp_has_cache_key: Visit a HasCacheKey object.
    - dp_has_cache_key_list: Visit a list of HasCacheKey objects.
    - dp_clauseelement: Visit a ClauseElement object.
    - dp_fromclause_canonical_column_collection: Visit a FromClause object in the context of the columns attribute; the canonical column collection (e.g., TableClause or Table).
    - dp_clauseelement_tuples: Visit a list of tuples representing clause elements.
  - These symbols are used to describe the internal traversal structure and enable automatic support for the HasTraverseInternals interface (get_children, _copy_internals, _gen_cache_key).

- _CompilerDispatchType (Protocol): A protocol describing the signature of the compiler dispatch function used by Visitable. It is callable with a visitor and keyword arguments and returns a result. This protocol underpins the dynamic dispatch mechanism implemented by Visitable.

- anon_map / prefix_anon_map: Helper mappings used for anonymizing or canonicalizing elements during traversal/cache key generation. Depending on the environment (C extensions available or not), anon_map may be provided by cython code or pure Python code.

How the dispatch mechanism works
-------------------------------
- Each Visitable subclass must declare __visit_name__.
- On subclass creation, if no fixed _compiler_dispatch exists, the module generates one at runtime.
- The generated _compiler_dispatch:
  - Looks up a method on the visitor named visit_<visit_name>.
  - If found, calls it with the Visitable instance and any provided keyword arguments.
  - If not found, calls visitor.visit_unsupported_compilation(self, err, **kw) to signal the missing handler.
- This design enables clean separation between the data structures (visitable objects) and the logic that consumes them (visitor implementations).

Extending and usage
-------------------
- To participate in traversal, create a class that derives from Visitable and set a meaningful __visit_name__.
- Implement corresponding visit_<visit_name> methods on your visitor class to handle the logic for that visit.
- If you need custom or fixed dispatch behavior, you may provide your own _compiler_dispatch, in which case the automatic generation is bypassed.

Version and compatibility notes
-------------------------------
- InternalTraversal and the dynamic dispatch mechanism have been designed for SQLAlchemy 1.4+ style traversal semantics.
- The module supports environments with or without a cython-based extension (HAS_CYEXTENSION), selecting anon_map implementation accordingly.
- Typing and TYPE_CHECKING guards are used to avoid runtime imports when type information is only needed for static analysis.

Example
-------
Below is a minimal illustrative example (conceptual) of how a Visitable subclass and a visitor might be defined:

.. code-block:: python

    from sql.visitors import Visitable

    class MyVisitable(Visitable):
        __visit_name__ = "example"

    class MyVisitor:
        def visit_example(self, obj, **kw):
            # handle visiting obj
            return f"visited {type(obj).__name__}"

        def visit_unsupported_compilation(self, obj, err, **kw):
            raise TypeError(f"No handler for {type(obj).__name__}: {err}")

    v = MyVisitor()
    o = MyVisitable()
    # o will dispatch to MyVisitor.visit_example(o, **kw) when compiled
    # Actual usage depends on SQLAlchemy's compilation process

See Also
--------
- The module is part of SQLAlchemy's traversal and compilation internals, and it interacts with HasTraverseInternals, _gen_cache_key, and related internals in the broader codebase.

This page serves as a reference for the public API and the core traversal mechanism provided by sql.visitors.