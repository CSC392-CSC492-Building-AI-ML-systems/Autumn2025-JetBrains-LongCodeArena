Using timers
============

This document describes basic patterns for delaying and scheduling work using Pythonâ€™s threading.Timer, with emphasis on clean shutdown within an ftrack-like session environment.

Overview
--------

- Timers run in their own threads and execute a callable after a specified interval.
- A timer can be started and canceled before it fires.
- For periodic (repeating) work, timers can be re-scheduled after each execution.
- To ensure a clean shutdown, timers should be canceled on program exit or session termination.

Basics
------

- Creating a one-shot timer:

  .. code-block:: python

     from threading import Timer

     def on_timeout():
         print("Timer fired")

     t = Timer(5.0, on_timeout)  # fires after 5 seconds
     t.start()
     # t.cancel()  # cancel before it fires

One-shot timers vs. repeating work
----------------------------------

- One-shot timers are simple: start once and let them fire or cancel if needed.
- There is no built-in repeating timer in threading.Timer; implement repetition by re-scheduling:

  .. code-block:: python

     from threading import Timer

     def periodic():
         print("tick")
         t = Timer(5.0, periodic)
         t.daemon = True
         t.start()

     periodic()  # starts the loop

Note: Implementing a robust repeating timer is best done with a small wrapper class that can manage cancellation of the current timer and any future ones.

Cancellation and shutdown
-------------------------

- Always be able to cancel a running timer:

  .. code-block:: python

     t.cancel()

- To ensure no timers keep running after exit, collect active timers and cancel them on shutdown:

  .. code-block:: python

     import atexit

     active_timers = []

     def register_timer(t):
         active_timers.append(t)

     def cancel_all():
         for t in list(active_timers):
             t.cancel()

     atexit.register(cancel_all)

Integrating with a session
--------------------------

- Timers can be used for delayed or periodic work inside a session lifecycle.
- Tie timer creation and cancellation to the Session instance:
  - Create timers after the session is created.
  - Cancel and clean up timers when the session is closed or destroyed to avoid orphaned threads.

See also
--------

- Python threading.Timer documentation for details on arguments and lifecycle.