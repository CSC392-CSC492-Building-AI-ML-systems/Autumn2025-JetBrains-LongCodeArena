Markov Chain Monte Carlo (MCMC) framework
==========================================

Overview
--------

This module provides a framework for equilibrium sampling from a given thermodynamic state
of a biomolecule using Markov chain Monte Carlo (MCMC). It supports several move engines
and allows them to be composed into sequences or weighted mixtures. By default, MCMC moves
use the fastest OpenMM platform available and a shared global ContextCache to minimize
OpenMM context creation overhead.

Key features
------------

- Langevin dynamics (assumed to be integration-error free; use at your own risk)
- Hybrid Monte Carlo (HMC)
- Generalized Hybrid Monte Carlo (GHMC)
- Monte Carlo barostat moves
- Composition of moves via:
  - SequenceMove: apply moves in a fixed sequence
  - WeightedMove: select moves according to specified weights
- Flexible caching and platform configuration through ContextCache and a global cache

API
---

MCMCMove
- Abstract base class for all MCMC moves.
- Implementations must provide apply(thermodynamic_state, sampler_state) and may update
  the thermodynamic state and/or the sampler state.
- Example responsibilities include proposing state updates and returning acceptance decisions.

MCMCSampler
- Basic Markov chain Monte Carlo sampler.
- Parameters
  - thermodynamic_state: initial ThermodynamicState
  - sampler_state: initial SamplerState
  - move_set: collection of MCMCMove objects
    - If a list/tuple: moves are attempted in the specified order each iteration
    - If a dict: unnormalized weights are used to select moves
- Attributes
  - thermodynamic_state: current thermodynamic state
  - sampler_state: current sampler state
  - move_set: collection of MCMCMove objects (sequence or weighted)
- Methods (examples)
  - minimize(): perform energy minimization if supported
  - run(n_iterations): run the MCMC loop for the given number of iterations
  - The sampler may also be configured with a ContextCache and platform settings

Composition of moves
-------------------

- SequenceMove: execute a fixed sequence of MCMCMove objects each iteration
- WeightedMove: randomly select a move from a set of moves according to specified probabilities
- Context caching: moves can be created with per-move ContextCache instances or use a global cache
- Caching options: use a real OpenMM platform or a dummy/local cache as needed

Configuration and usage
------------------------

- By default, the framework uses the fastest available OpenMM platform and a global ContextCache
- The default platform can be overridden before starting a simulation, for example by setting
  cache.global_context_cache.platform to a specific OpenMM Platform
- The time-to-live (TTL) and other cache settings can be tuned to balance performance and memory

Examples
--------

Create a basic setup and perform a couple of MCMC iterations:

.. code-block:: python

    from simtk import unit
    from openmmtools import testsystems, cache
    from openmmtools.states import ThermodynamicState, SamplerState

    # Create the initial state for an alanine dipeptide in vacuum
    test = testsystems.AlanineDipeptideVacuum()
    thermodynamic_state = ThermodynamicState(system=test.system,
                                            temperature=298*unit.kelvin)
    sampler_state = SamplerState(positions=test.positions)

    # Define moves
    ghmc_move = GHMCMove(timestep=1.0*unit.femtosecond, n_steps=50)
    langevin_move = LangevinDynamicsMove(n_steps=10)

    # Create an MCMC sampler with a single move
    sampler = MCMCSampler(thermodynamic_state, sampler_state, move=ghmc_move)

    # Or compose moves, or use weighted moves
    sequence_move = SequenceMove([ghmc_move, langevin_move])
    sampler = MCMCSampler(thermodynamic_state, sampler_state, move=sequence_move)

    weighted_move = WeightedMove([(ghmc_move, 0.5), (langevin_move, 0.5)])
    sampler = MCMCSampler(thermodynamic_state, sampler_state, move=weighted_move)

    # Optional: configure the default platform and caching
    reference_platform = openmm.Platform.getPlatformByName('Reference')
    cache.global_context_cache.platform = reference_platform
    cache.global_context_cache.time_to_live = 10

    # Run a short test
    sampler.minimize()
    sampler.run(n_iterations=2)

Caching and per-move customization
----------------------------------

- If you do not want to share a global cache, you can create per-move caches:
  local_cache1 = cache.ContextCache(capacity=5, time_to_live=50)
  local_cache2 = cache.ContextCache(platform=reference_platform, capacity=1)
  sequence_move = SequenceMove([HMCMove(), LangevinDynamicsMove()],
                               context_cache=local_cache1)
  ghmc_move = GHMCMove(context_cache=local_cache2)

- To disable caching entirely, you can use a DummyCache:
  dummy_cache = cache.DummyContextCache(platform=reference_platform)
  ghmc_move = GHMCMove(context_cache=dummy_cache)

References
----------

- Jun S. Liu. Monte Carlo Strategies in Scientific Computing. Springer, 2008.

See Also
--------

- openmmtools.integrators
- openmmtools.states
- openmmtools.cache

Authors
-------

 John D. Chodera
 (Licensed under the MIT License)