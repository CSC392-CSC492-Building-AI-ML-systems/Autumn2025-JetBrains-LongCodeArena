PyTables File Format
====================

Overview
--------
PyTables stores data in HDF5 files with PyTables-specific extensions. In addition to the standard HDF5 objects (datasets, groups, attributes), PyTables reserves a small, well-defined structure to store indexing information that accelerates queries on table columns. The indexing information is kept as a dedicated Index object associated with a single column of a Table.

Index storage and naming
------------------------
- Each index is attached to a table and is stored inside the table’s group.
- The index node uses a name prefixed with _i_ (for example, _i_age). This prefix helps identify the node as an index for a column.
- The index path encodes both the table location and the column being indexed. The exact layout is determined by the internal pathname split logic, where the portion starting with _i_ marks the index, followed by the column path.

Index versioning
----------------
- The internal index format version is controlled by the obversion modifier.
- Current version for PyTables Pro 2.1 and newer is "2.1".
- Older or deprecated API versions (e.g., 1.0, 2.0) exist for compatibility but are not the default for new files.

Default options and filters
---------------------------
- Automatic indexing: default_auto_index is True, i.e., PyTables will attempt to maintain indexes automatically after table modifications unless disabled.
- Index compression and I/O filters: default_index_filters sets compression and I/O behavior:
  - complevel=1
  - complib='zlib'
  - shuffle=True
  - fletcher32=False

  These defaults should be kept in sync with the user-visible docstrings and user guide.

Optimized search and supported data types
-----------------------------------------
- PyTables implements optimized search paths for a defined set of numeric types. The supported types include:
  int8, int16, int32, int64, uint8, uint16, uint32, uint64, float32, float64

Index internals (structure and properties)
------------------------------------------
An Index object describes the indexing state for a single table column and exposes properties such as:

- kind: The granularity of the index. Mapping:
  - 1 -> ultralight
  - 2 -> light
  - 4 -> medium
  - 8 -> full
  The “full” kind tracks the full 64-bit row position; the lighter kinds track row location at coarser grain (chunk/slice level).

- filters: The Filters instance applied to index I/O (compression, shuffling, etc.). This mirrors the general filtering used for index data.

- dirty: Indicates whether the index is out of sync with the underlying table data. A dirty index is present but not usable for queries until rebuilt or updated. The attribute DIRTY is stored in the index node’s attributes.

- column: The Column object associated with this index (derived from the table and column path).

- table: The Table object to which this index belongs.

- nblockssuperblock: Number of blocks per superblock (computed as superblocksize // blocksize).

- nslicesblock: Number of slices per block (computed as blocksize // slicesize).

- nchunkslice: Number of chunks per slice (computed as slicesize // chunksize).

- nsuperblocks: Number of superblocks in the index (derived from the total number of blocks and the superblock configuration).

Index data organization (blocks, slices, and superblocks)
--------------------------------------------------------
The internal storage of index data follows a multi-level block structure to balance I/O efficiency and memory usage:

- Superblock: A large, high-level grouping containing multiple blocks.
- Block: A contiguous region containing a number of slices.
- Slice: A segment within a block containing a number of chunks.
- Chunk: The smallest unit of index data storage.

This hierarchical organization allows fast, cache-friendly access patterns during index construction and query-time lookups.

Implications for users
----------------------
- The index for a column is transparent to most users but can influence performance significantly, especially for large tables and numeric searches.
- Users can rely on the default behaviors (auto index and default filters) or adjust them via the public API to tune performance and storage.
- Understanding the pathing and naming of index nodes helps diagnose file structure and ensures compatibility when inspecting or manipulating the file at the raw level.