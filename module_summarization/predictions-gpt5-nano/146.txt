Quick Start
===========

This guide shows how to quickly use toppra with a geometric path that implements the AbstractGeometricPath interface, how to generate gridpoints along the path, and how to wrap OpenRAVE trajectories if OpenRAVE is available.

What you need
--------------

- Python 3.x
- numpy
- scipy
- toppra
- Optional: OpenRAVE (for RaveTrajectoryWrapper)

Algorithm overview
------------------

- AbstractGeometricPath defines how to evaluate a path and its derivatives:
  - __call__(path_positions, order=0) returns the path values (order=0), first derivative (order=1), or second derivative (order=2).
  - dof: number of joints (degrees of freedom).
  - path_interval: start and end positions along the geometric path.
  - waypoints: optional tuple of waypoints (or None).

- propose_gridpoints(path, max_err_threshold=..., max_iteration=..., max_seg_length=...)
  - Generates a set of gridpoints along the path by iteratively refining segments until the estimated interpolation error is below the threshold.
  - The error estimate uses the second derivative of the path and the segment length.

- RaveTrajectoryWrapper (optional)
  - If OpenRAVE is available, wrap an OpenRAVE trajectory to obtain a geometric path compatible with toppra.

Example: Quick-start geometric path and gridpoint generation
-----------------------------------------------------------

Define a simple geometric path by subclassing AbstractGeometricPath and generate gridpoints along it.

.. code-block:: python

    import numpy as np

    # Define a simple 2-DOF straight-line path from 0 to 1 in each DOF
    class StraightLinePath(AbstractGeometricPath):
        def __init__(self, dof=2):
            self._dof = dof
            self._interval = np.array([0.0, 1.0])

        @property
        def dof(self):
            return self._dof

        @property
        def path_interval(self):
            return self._interval

        @property
        def waypoints(self):
            return None

        def __call__(self, path_positions, order=0):
            t = np.asarray(path_positions)
            q_start = np.zeros(self.dof)
            q_end = np.ones(self.dof)
            if order == 0:
                return (1.0 - t)[:, None] * q_start + t[:, None] * q_end
            elif order == 1:
                return np.ones((t.shape[0], self.dof))
            else:
                return np.zeros((t.shape[0], self.dof))

    # Instantiate and generate gridpoints
    path = StraightLinePath(dof=2)
    gridpoints = propose_gridpoints(path, max_err_threshold=1e-4, max_iteration=50, max_seg_length=0.1)
    print(gridpoints)

Optional: OpenRAVE integration
------------------------------

If OpenRAVE is installed and detected, you can wrap an OpenRAVE trajectory to obtain a compatible geometric path:

.. code-block:: python

    if FOUND_OPENRAVE:
        # traj is an OpenRAVE trajectory and robot is an OpenRAVE robot
        wrapper = RaveTrajectoryWrapper(traj, robot)
        # wrapper can now be used as the path input to toppra algorithms

API reference (high level)
--------------------------

- AbstractGeometricPath
  - __call__(path_positions, order=0) -> np.ndarray
  - dof -> int
  - path_interval -> np.ndarray shape (2,)
  - waypoints -> Optional[Tuple[np.ndarray, np.ndarray]]

- propose_gridpoints(path, max_err_threshold=1e-4, max_iteration=100, max_seg_length=0.05) -> list of gridpoints

Notes
-----

- The grid refinement adapts to path curvature: segments with higher curvature will receive more gridpoints to reduce interpolation error.
- The wrapper for OpenRAVE (RaveTrajectoryWrapper) enables using existing OpenRAVE trajectories with toppra when OpenRAVE is available.