Handling large datasets
=======================

This package provides multiple strategies for computing moment maps from SpectralCube data to balance speed and memory usage when working with very large datasets.

Strategies for moment computation
- Cubewise (moment_cubewise): loads the entire data array into memory and computes the moment along the specified axis in one shot. Fastest for small-to-moderate cubes but memory intensive.
- Raywise (moment_raywise): processes one ray at a time along the chosen axis. Much more memory efficient, but potentially slower due to Python-level looping.
- Slicewise (moment_slicewise): processes one plane (slice) at a time along the axis. Highly memory efficient and a good default for very large cubes; relies on per-plane data access and weighting.

Automatic strategy selection
- moment_auto(cube, order, axis) selects a strategy using iterator_strategy(cube, axis) and calls the corresponding function:
  - cube -> moment_cubewise
  - ray  -> moment_raywise
  - slice -> moment_slicewise
- This automatic choice helps balance speed and memory without manual intervention.

Data handling, masking, and NaNs
- The slice-based approach uses per-plane data access with explicit fill values (np.nan or 0) to handle missing data.
- Zero-th moment handles invalid regions by marking them as NaN in the result.
- Higher-order moments compute weighted averages using pixel sizes and centroid positions, with careful handling of NaNs in the data.
- Masks and data quality are respected through the underlying cube access methods, enabling consistent results across approaches.

Memory considerations and practical guidance
- For very large cubes, prefer raywise or slicewise to limit memory usage.
- If the cube fits in memory, cubewise computation can be the fastest option.
- Reusing masks across multiple Stokes components can reduce memory usage when working with Stokes cubes.

Notes on usage
- Axis conventions follow NumPy (0, 1, 2, â€¦), with the moment map shaped by collapsing the chosen axis.
- The code provides internal helpers to determine the moment map shape and to compute moments plane-by-plane or ray-by-ray, enabling scalable handling of large datasets.

Examples
- m0 = moment_auto(cube, 0, axis=2)
- m1 = moment_auto(cube, 1, axis=2)
- m2 = moment_auto(cube, 2, axis=2)

API overview
- moment_cubewise(cube, order, axis)
- moment_raywise(cube, order, axis)
- moment_slicewise(cube, order, axis)
- moment_auto(cube, order, axis)  (automatic strategy selection)