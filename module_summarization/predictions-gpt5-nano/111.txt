Documentation for generate
==========================

Module overview
---------------
This module provides planning helpers for Bluesky-style experiments. It exposes three entry points:

- count(detectors, num=1, delay=None, *, per_shot=None, md=None)
- list_scan(detectors, *args, per_step=None, md=None)
- rel_list_scan(detectors, *args, per_step=None, md=None)

The functions are designed to be used inside a Bluesky RunEngine as part of a data acquisition plan. They rely on internal decorators and utilities from the surrounding package (preprocessors, plan stubs, plan patterns, and messaging utilities).

API reference
-------------

count(detectors, num=1, delay=None, *, per_shot=None, md=None)
Take one or more readings from detectors.

Parameters
- detectors: list
  List of 'readable' objects (detectors) to read from.
- num: int, optional
  Number of readings to take; default is 1. If None, capture data until canceled.
- delay: iterable or scalar, optional
  Time delay in seconds between successive readings; default is 0.
- per_shot: callable, optional
  Hook for customizing action of inner loop (messages per step).
  Expected signature: def f(detectors: Iterable[OphydObj]) -> Generator[Msg]: ...
- md: dict, optional
  Metadata to attach to the plan. If provided, it is merged with generated metadata.

Returns
- A generator produced by inner_count(), i.e., yield from inner_count().

Notes
- If delay is an iterable, it must have at least num - 1 entries or a ValueError will be raised during iteration.
- The function builds a metadata dict (_md) describing detectors, number of points, plan name, and hints, and uses Bluesky plan decorators to manage the plan lifecycle.

Internal behavior (summary)
- Computes num_intervals = num - 1 (unless num is None).
- Sets up a metadata dictionary including plan_name 'count' and plan_args.
- Uses per_shot (defaulting to bps.one_shot) to drive inner loop behavior.
- Executes a repeating sequence via bps.repeat(partial(per_shot, detectors), num=num, delay=delay).

Example
- count([det1, det2], num=5, delay=0.1)

list_scan(detectors, *args, per_step=None, md=None)
Scan over one or more variables in steps simultaneously (inner product).

Parameters
- detectors: list
  List of 'readable' objects to read from.
- args: variadic
  Pairs of (motor, [points...]). For N motors, provide N pairs.
- per_step: callable, optional
  Hook for customizing action of inner loop (messages per step).
  Expected signature: f(detectors, motor, step) -> plan (generator)
- md: dict, optional
  Metadata to attach to the plan.

Returns
- A generator produced by scan_nd(detectors, full_cycler, per_step=per_step, md=_md).

Notes
- All provided motors must have position lists of equal length.
- The function builds a plan metadata dictionary that includes the list of motor names, the points for each motor, and a description of the plan pattern ('inner_list_product').
- It derives default hints from motor metadata (fields) and applies a default dimension of time (or other fields if defined).
- The full cycler is produced by plan_patterns.inner_list_product(args) and executed via scan_nd.

Internal behavior (summary)
- Validates that the number of point lists matches across motors.
- Assembles metadata (_md) with detectors, motors, points, and plan information.
- Determines default hints from motor hints and applies them to the plan.
- Delegates execution to scan_nd with the constructed cycler.

Example
- list_scan([det1], motor1, [0, 1, 2], motor2, [10, 20, 30], md=my_md)

rel_list_scan(detectors, *args, per_step=None, md=None)
Scan over one variable in steps relative to current position.

Parameters
- detectors: list
  List of 'readable' objects to read from.
- args: variadic
  Pairs of (motor, [relative_points...]). Points are relative to the motor's current position.
- per_step: callable, optional
  Hook for customizing action of inner loop (messages per step).
  Expected signature: f(detectors, motor, step)
- md: dict, optional
  Metadata to attach to the plan.

Returns
- Not implemented yet. The function body contains a TODO and currently does nothing.

Notes
- See Also references to similar non-relative scans in Bluesky.

See Also
- bluesky.plans.rel_list_scan
- bluesky.plans.list_grid_scan
- bluesky.plans.rel_list_grid_scan

Examples (complete)
- Relative scans are not yet implemented in this module; refer to Bluesky equivalents for progressively stepping relative to the current position.

Internal details and dependencies
- Uses a partition utility (from cytools or toolz) to split paired arguments into (motor, positions) tuples.
- Builds metadata dictionaries (_md) with plan names, arguments, and hints.
- Relies on plan_patterns for generating the inner list product cycler.
- Employs decorators from preprocessors (bpp) and plan stubs (bps) to manage plan lifecycle and messaging.

Notes for users
- The count and list_scan functions are ready for use; rel_list_scan is a placeholder and will need implementation before use in plans.
- Ensure the environment provides the required dependencies (cytools or toolz, Bluesky components) for proper operation.