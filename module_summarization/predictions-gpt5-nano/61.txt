orm.instrumentation
===================

Overview
--------
Defines SQLAlchemy's system of class instrumentation. This module is typically not visible to user applications, but it forms a large part of the ORM’s interactivity by managing registration of end-user classes for state tracking. It works closely with state.py and attributes.py to establish per-instance and per-class instrumentation.

The instrumentation system can be customized on a per-class or global basis using the sqlalchemy.ext.instrumentation package.

Key concepts
------------
- Class-level state tracking: The central element is ClassManager, which tracks instrumentation state and ties a Python class to the ORM’s instrumentation machinery.
- Interaction with others: ClassManager coordinates with state.py (per-instance state) and attributes.py (per-attribute instrumentation), enabling the ORM to monitor and manage attribute access and changes on mapped classes.
- Extension points: The system can be customized or extended via the external instrumentation package (sqlalchemy.ext.instrumentation).

Public API
----------
ClassManager
- Purpose: Tracks and manages instrumentation state for a specific user-defined class at the class level.
- Inheritance and type: 
  - Inherits HasMemoized, Dict[str, QueryableAttribute[Any]], Generic[_O], and EventTarget.
  - Exposes dispatch: dispatcher[ClassManager[_O]] for event handling related to the class.
- Main attributes:
  - class_: The user-defined class being instrumented.
  - info: A per-class payload dictionary for internal use.
  - new_init, original_init: Hold initialization-related callbacks and the original __init__ to preserve behavior.
  - local_attrs, originals: Storage for per-class attribute instrumentation data and original attributes.
  - _finalized: Flag indicating whether instrumentation has completed.
  - factory: Optional factory for creating manager instances.
  - init_method: Optional custom initialization method for the class.
  - declarative_scan: Optional weak reference to a MapperConfig used during declarative mapping.
  - registry: Internal registry that tracks managers; defaults to None during setup.
  - _bases: List of ClassManager instances corresponding to base classes (if instrumented), used to inherit instrumentation behavior.
  - _state_setter: Internal setter for the STATE_ATTR value.
  - expired_attribute_loader: Protocol-cached loader responsible for loading attributes when they expire (formerly known as deferred_scalar_loader).
- Properties:
  - deferred_scalar_loader (deprecated alias): See expired_attribute_loader. This property is kept for backward compatibility and is deprecated in favor of expired_attribute_loader.
- Methods:
  - __init__(self, class_): Initialize a ClassManager for the given class, set up bases, propagate from bases, install per-class event hooks, and warn if __del__ is defined (to avoid cycles and leaks).
  - _update_state(self, finalize=False, mapper=None, registry=None, declarative_scan=None, expired_attribute_loader=None, init_method=None): Update instrumentation state with optional mapper, registry, declarative scan, loader, and init method. Captures and validates init_method usage, and can trigger finalization.
  - _finalize(self): Finalize instrumentation for the class, enabling the instrumentation mechanisms for the mapped class.
- Internal behavior:
  - During initialization, the manager traverses base classes to inherit or merge instrumentation, registers events on the class, and wires up dispatching for related managers.
  - If a __del__ method is present on the class, a warning is emitted to avoid potential reference cycles and memory leaks commonly associated with instrumentation.

Protocols and internal types
- _ExpiredAttributeLoaderProto: Protocol defining a loader callable that accepts a class state, a set of attribute names to load, and a passive flag, returning None.
- _ManagerFactory: Protocol defining a factory callable that, given a class, returns a ClassManager instance.

Notes
------
- The module serves as a foundational piece of the ORM’s instrumentation system, bridging user classes with internal state tracking facilities.
- It interacts with the event system (via EventTarget) to expose and respond to class-level events.
- The class can be extended or customized through the external sqlalchemy.ext.instrumentation package, which installs its own resolution and management mechanics when imported.