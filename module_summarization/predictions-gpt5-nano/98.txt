Contracts API Reference
========================

Overview
--------
This module provides a base Contract proxy class for interacting with Ethereum smart contracts via a Web3 connector. It is designed to be extended by generated contract classes created from a compiled Solidity ABI (typically via a factory such as construct_contract_factory). A contract proxy class inherits behavior to deploy contracts, encode function calls, and subscribe to contract events.

Key concepts
- ABI: Application Binary Interface defining contract functions and events.
- Code and runtime code: The deployed bytecode and its runtime counterpart.
- Web3 integration: Interaction is performed through a class attribute web3 that must be initialized before use.
- Proxies: Instances represent specific contract deployments or addresses, enabling calls and event listening.

Prerequisites
- A Web3 instance must be assigned to the Contract subclass via the web3 class attribute before creating instances.
- The contract subclass should be created with an ABI (and optionally code, code_runtime, and source) using a factory such as construct_contract_factory.

Usage flow
- Create a Contract subclass (proxy) from the contract ABI.
- Initialize a proxy instance with the contract address (and optionally ABI/code metadata).
- Deploy a new contract when needed.
- Encode ABI for function calls.
- Listen for and handle contract events.

API Reference
Contract (base class)
---------------------

Class attributes
- web3: A Web3 instance. Must be set prior to using the Contract class or its subclasses. If not set, __init__ will raise an AttributeError.
- _abi: Optional an existing ABI to use (class-level).
- _code: Optional bytecode for deployment (class-level).
- _code_runtime: Optional runtime bytecode (class-level).
- _source: Optional source representation (class-level).

Instance attributes
- address: The contract address (0x-prefixed) representing the deployed contract instance.

Initialization
- __init__(self, abi=None, address=None, code=None, code_runtime=None, source=None)

  Create a new smart contract proxy object.

  Parameters:
  - abi: Contract ABI (optional). If provided, overrides the class ABI.
  - address: Contract address as a 0x hex string.
  - code: Bytecode for deployment (optional). Overrides class code.
  - code_runtime: Runtime bytecode (optional). Overrides class code_runtime.
  - source: Source metadata (optional). Overrides class source.

  Notes:
  - The class variable web3 must be initialized prior to instantiation.
  - If abi/code/code_runtime/source are provided, they become instance-level values.

Deployment
- deploy(cls, transaction=None, args=None, kwargs=None)

  Deploys the contract to the blockchain and returns the transaction hash.

  Behavior:
  - Requires that the subclass has associated bytecode (cls.code); otherwise raises ValueError.
  - Validates the deployment transaction to ensure it does not contain 'data' (overrides) or 'to'.
  - Encodes constructor arguments using internal helpers and sets deploy data.
  - Submits the deployment transaction via cls.web3.eth.sendTransaction.
  - Returns the transaction hash.

  Example:
  .. code-block:: python

     MyContract.deploy(
         transaction={
             'from': web3.eth.accounts[1],
             'value': 12345,
         },
         args=('DGD', 18),
     )
     '0x5c504ed432cb51138bcf09aa5e8a410dd4a1e204ef84bfed1be16dfba1b22060'

  Parameters:
  - transaction: Transaction parameters for deployment (dict) [optional].
  - args: Constructor arguments as positional arguments [optional].
  - kwargs: Constructor arguments as keyword arguments [optional].

  Returns:
  - The hexadecimal transaction hash of the deployment.

ABI Encoding
- encodeABI(cls, fn_name, args=None, kwargs=None, data=None)

  Encodes the arguments for a contract function call according to the contract ABI.

  - This is a classmethod decorated with coerce_return_to_text, returning the ABI-encoded payload.
  - If data is not provided, the function selector (the first 4 bytes of the keccak-256 hash of the function signature) is used as the payload.
  - The function looks up the function ABI by name and arguments, then delegates to internal encoding logic to produce the final data.

  Example:
  .. code-block:: python

     data = MyContract.encodeABI('transfer', args=('0xabc...123', 1000))

  Parameters:
  - fn_name: Name of the contract function to encode.
  - args: Positional arguments for the function (optional).
  - kwargs: Keyword arguments for the function (optional).
  - data: Optional override data (defaults to function selector).

  Returns:
  - ABI-encoded function call data (hex string, typically with 0x prefix).

Event subscription
- on(self, event_name, filter_params=None, *callbacks)

  Register a callback to be triggered on the appropriate events for this contract.

  - Combomethod, meaning it can be used as both an instance method and a class-level method depending on usage.
  - Accepts an event name and optional filter parameters, along with one or more callback functions.
  - Builds an event filter using the contract address and provided filters, and wires a data extractor for events using the event ABI.
  - Creates a log filter via the Web3 provider and attaches data filters and a formatter for log entries.

  Example:
  .. code-block:: python

     def handle_log(log):
         print(log)

     contract.on('Transfer', filter={'filter': {'from': some_address}}, handle_log)

  Parameters:
  - event_name: The name of the event to listen for.
  - filter_params: Optional dict of filter parameters (may include 'fromBlock', 'toBlock', 'address', etc.) and a nested 'filter' dict for event argument filters.
  - callbacks: One or more callback callables to handle matching events.

  Returns:
  - A reference to the configured log filter (implementation-dependent).

Internal helpers (not part of the public API)
---------------------------------------------
The Contract base class relies on several private helper methods to perform ABI selection, encoding, and event filtering. Examples include:
- _get_function_info: Resolve function ABI, selector, and argument handling.
- _encode_abi: Perform the actual encoding of function arguments.
- _encode_constructor_data: Prepare deployment data from constructor arguments.
- _find_matching_event_abi: Locate the event ABI by name and argument hints.
- construct_event_filter_params: Build filter parameters for event subscriptions.
- get_event_data: Decode event data according to the event ABI.

Notes
- The class is designed to be extended by generated contract proxy classes that provide concrete ABI/code/runtime/code and optionally a source.
- The web3 attribute must be set by the user of the library (usually by the factory) before any contract interaction.

Examples
- Deploying a contract
  - See the deploy example in the deploy() docstring for a concrete usage scenario.
- Encoding a function call
  - Use Contract.encodeABI to obtain the data payload for a function invocation.
- Subscribing to events
  - Use the on() method to attach callbacks that react to emitted events from the contract.

Dependencies
- eth_abi for ABI encoding/decoding
- web3.py and its submodules for Ethereum interaction, filtering, and event handling

End of API Reference

Notes for Documentation Authors
- The examples provided reflect the current behavior of the base Contract class as seen in the source. If the implementation adds or changes private helper APIs, consider documenting them in a separate Internal API section.