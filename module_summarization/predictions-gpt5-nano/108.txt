polys.rst

Polynomial Factorization Routines (Characteristic Zero)
=====================================================

Overview
--------
This module provides polynomial factorization routines for characteristic zero. It exposes a mixin class, _Factor, which implements the core factorization algorithms used by higher-level polynomial objects in the package. The routines handle both univariate and multivariate polynomials, and they rely on a number of configuration flags and auxiliary modules for arithmetic in rings and fields.

Key dependencies
----------------
- Algebraic number field factorization utilities and helpers
- Integer and modular factorization routines
- Primitive/content handling and polynomial coefficient ring management
- Error types used by the factoring routines
- Utility for sorting factor lists

Class: _Factor
-------------
A mixin class intended to be combined with concrete polynomial-domain implementations. It provides internal factoring methods used by public factorization interfaces elsewhere in the project.

Methods (internal API)
----------------------

- _trial_division(self, f, factors) -> list
  - Purpose: Reconstruct multiplicities of given (candidate) factors by performing trial division of f by each factor.
  - Input:
    - f: the polynomial to factor
    - factors: iterable of (factor, _) pairs (factors, initially without multiplicity)
  - Output: A list of (factor, exponent) tuples, sorted (using _sort_factors).

- _aa_factor_trager(self, f) -> (lc, factors)
  - Purpose: Factor multivariate polynomials over algebraic number fields.
  - Notes: Uses leading coefficient lc, monic version of f, square-free part, normalization, and cofactor calculation. Returns the leading coefficient and a list of irreducible factors with multiplicities after trial division.

- _zz_factor(self, f) -> (content, [(g, k), ...])
  - Purpose: Factor polynomials in Z[X] (not necessarily univariate).
  - Behavior:
    - For univariate polynomials over ZZ, uses primitive decomposition, irreducibility tests, and Zassenhaus/EEZ algorithms with optional cyclotomic factoring.
    - For multivariate polynomials, reduces to primitive, handles square-free parts, and recurses on substructures as needed.
  - Output:
    - content(f): the content of f
    - a list of tuples (factor, exponent), representing the factorization in Z[X] with multiplicities.
  - Notes: References the Gathenâ€“Gathen modern factorization approach. It honors configuration flags such as USE_IRREDUCIBLE_IN_FACTOR and USE_CYCLOTOMIC_FACTOR to tailor factoring strategies:
    - USE_IRREDUCIBLE_IN_FACTOR: attempt irreducible factor checks
    - USE_CYCLOTOMIC_FACTOR: enable cyclotomic factorization as a preprocessing step

- _zz_mignotte_bound(self, f) -> bound
  - Purpose: Compute the Mignotte bound for a multivariate polynomial in Z[X].
  - Returns: A bound used to assist in selecting primes and guiding polynomial factor lifting.

- _zz_zassenhaus(self, f) -> list
  - Purpose: Factor a primitive square-free polynomial in Z[x] using the Zassenhaus algorithm (and related variants like Enhanced Extended Zassenhaus).
  - Highlights:
    - Works under the constraint that the polynomial is univariate and defined over the integers
    - Determines a suitable prime p that makes F square-free in Z_p, lifts factors via Hensel lifting, and combines lifted factors to recover Z[x] factors
  - Returns: A list of irreducible factors (as polynomials over ZZ) that multiply to f, up to unit content.

Notes on usage
---------------
- The _Factor mixin relies on a domain attribute (self.domain) and other polynomial API methods (e.g., is_univariate, primitive, monic, LC, max_norm, degree, sqf_part, sqf_norm, cofactors, compose, eject, inject, and ring management in nested rings). Subclasses must provide these elements to enable factoring.
- The factoring routines are designed to work within the larger factoring framework of the project, including content extraction, primitive decomposition, and coefficient domain management.
- Configuration options (via query) influence the path taken by _zz_factor and related methods, enabling or disabling irreducible checks and cyclotomic factorization as appropriate for performance or accuracy.

Examples (from the implementation context)
------------------------------------------
The codebase includes examples illustrating factor_list-style outputs for univariate ZZ-polynomials, which demonstrate expected factorization results:

- Example:
  >>> _, x = ring('x', ZZ)
  >>> (2*x**4 - 2).factor_list()
  (2, [(x - 1, 1), (x + 1, 1), (x**2 + 1, 1)])

- In a multivariate setting (e.g., ring with x, y over ZZ):
  >>> _, x, y = ring('x y', ZZ)
  >>> (2*x**2 - 2*y**2).factor_list()
  (2, [(x - y, 1), (x + y, 1)])

References
----------
- Gathen, juried text: Modern Computer Algebra (reference for Zassenhaus and related factorization strategies).

Configuration and helper modules
--------------------------------
This implementation relies on:
- query(...) to fetch feature flags (e.g., USE_IRREDUCIBLE_IN_FACTOR, USE_CYCLOTOMIC_FACTOR)
- factorint, isprime, nextprime for integer factorization and primality
- symmetric_residue and related modular factoring utilities
- polyerrors for error handling
- polyutils._sort_factors for consistent ordering of factors

See also
--------
- Public factoring interfaces in the surrounding polynomial package that utilize _Factor as a mixin
- Other factorization strategies and domain-specific factorization utilities in the codebase

References in code
------------------
- The _zz_factor method references the following optional strategies and historical approaches:
  - ZZ Zassenhaus (or EEZ) algorithm for Z[x] factorization
  - Mignotte bound for bounding coefficients during factor lifting
  - Hensel lifting and prime selection for lifting factors from Z_p back to Z
  - Cyclotomic factorization option for special-case simplifications

This file documents the internal factoring machinery that powers the higher-level Factorization APIs in the project.