Model usage
===========

The Model class is the central component of the ORM. Define your application's data models by subclassing Model and declaring fields and metadata. The ORM automatically handles database interactions, relationships, and query construction.

Defining models
----------------

Define a model by subclassing Model and declaring fields using the provided field types. Each field maps to a database column.

Example
 ````python
from tortoise import fields
from tortoise.models import Model

class User(Model):
    id = fields.IntField(pk=True)
    username = fields.CharField(max_length=50, unique=True)
    email = fields.CharField(max_length=255, null=True)
    is_active = fields.BooleanField(default=True)
    joined_at = fields.DatetimeField(auto_now_add=True)

    class Meta:
        table = "users"
````

Field types (common)
--------------------

- IntField, BigIntField
- CharField, TextField
- BooleanField
- FloatField, DecimalField
- DatetimeField, DateField, TimeField
- JSONField, UUIDField
- BinaryField
- ForeignKeyField, OneToOneField, ManyToManyField (for relations)
- relations expose reverse attributes using related_name

Primary keys
------------

- Use pk=True on a field to designate the primary key.
- If no primary key is declared, Tortoise provides an autoincrementing integer id by default (depending on backend behavior).

Meta options
------------

Customize model behavior and mappings with the inner Meta class.

- table: Database table name (string)
- app: Application label (string or None)
- abstract: If True, the model is not mapped to a table
- unique_together: Tuples of field names that must be unique together
- indexes: Tuples of field names to create database indexes on
- ordering: Default ordering for queries (list of strings or (field, Order) tuples)
- _default_ordering / _ordering_validated: Internal controls for default ordering

Example
 ````python
class Article(Model):
    id = fields.IntField(pk=True)
    title = fields.CharField(max_length=200)
    published = fields.BooleanField(default=False)

    class Meta:
        table = "articles"
        ordering = (("published", "DESC"), ("title", "ASC"))
        unique_together = (("title", "published"),)
````

Relationships
-------------

- ForeignKeyField: many-to-one relationship. Use the related_name to access a reverse relation.
- OneToOneField: one-to-one relationship.
- ManyToManyField: many-to-many relationship.

Examples
 ````python
class User(Model):
    id = fields.IntField(pk=True)
    username = fields.CharField(max_length=50)

class Post(Model):
    id = fields.IntField(pk=True)
    author = fields.ForeignKeyField("models.User", related_name="posts")
    co_authors = fields.ManyToManyField("models.User", related_name="coauthored_posts")
````

Accessing related objects
-------------------------

- Forward lookups: fetch a related object via the field (awaitable for async operations).
- Reverse lookups: access the related set via the related_name.

Examples
- Fetch a user and their posts:
  ```
  user = await User.get(id=1)
  posts = await user.posts.all()
  ```

- Create a new post for a user:
  ```
  user = await User.get(id=1)
  post = await Post.create(title="New Story", author=user)
  ```

Comments and documentation
---------------------------

Field-level comments can be added as documentation and collected for docs generation. Use a Python-style comment block preceding a field with a #: directive. The system will extract and substitute the model name where needed.

Example
 ````python
class Product(Model):
    #: The unique product code used for inventory and lookup
    code = fields.CharField(max_length=20, unique=True)

    #: Product name as displayed to customers
    name = fields.CharField(max_length=100)
````

Queries and basic usage
-----------------------

- Create, read, update, delete examples (async):

  ```
  # Create
  user = await User.create(username="alice")

  # Read
  user = await User.get(username="alice")

  # Filter
  active_users = await User.filter(is_active=True).all()

  # Update
  await User.filter(id=1).update(is_active=False)

  # Delete
  await User.filter(id=1).delete()
  ```

- Basic chaining and operators with Q wrappers:
  ```
  from tortoise.queryset import Q
  results = await User.filter(Q(is_active=True) & Q(username__startswith="a")).order_by("joined_at").limit(10)
  ```

Transactions and signals
------------------------

- Use asynchronous transactions to ensure atomic operations:
  ```
  from tortoise.transactions import in_transaction

  async with in_transaction():
      # your db operations here
  ```

- Signals allow reacting to model events (creation, update, deletion). Define handlers and connect them to the desired signals.

Notes
-----

- All operations with the ORM are asynchronous. Use await when performing queries or mutations.
- The framework supports reverse relations and lazy-loading of related objects; use related_name to access the reverse manager.
- Meta options control table mapping, indexing, and default query ordering.

This document covers the essentials for defining and using models with the ORM, including field declarations, metadata, relationships, and common query patterns.