orm.collections — Instrumentation for ORM collections
===============================================

Overview
--------
The collections module provides the machinery used by the ORM to inform about
collection membership changes. It implements an instrumentation decoration
approach that allows arbitrary types (including built-ins) to be used as
entity collections without requiring inheritance from a specific base class.

Two decorator approaches are provided:

- Generic (annotation) decorators that map function arguments and return values
  to collection events. These decorators are used as annotations on methods:

  - collection.adds(...)
  - collection.removes_return(...)
  - etc.

  Example:

  from sqlalchemy.orm import collections

  class MyClass:
      #...

      @collection.adds(1)
      def store(self, item):
          self.data.append(item)

      @collection.removes_return()
      def pop(self):
          return self.data.pop()

- Targeted decorators that wrap appropriate append and remove notifiers around
  mutation methods available on standard Python list, set, and dict interfaces.
  They are hand-tuned for efficiency and may implement adapter-like behavior for
  bulk methods (extend, update, __setslice__, etc.) by emitting a sequence of
  atomic events instead of delegating to the underlying method.

Decorator behavior and instrumentation
--------------------------------------
The targeted decoration aims to avoid duplicating events by recognizing that
certain methods (e.g., append, pop) are already instrumented on common
interfaces such as list. Bulk methods may be reimplemented in terms of atomic
mutation events.

Runtime transformation
----------------------
Collection classes can be specified in relationship(collection_class=) as
types or as a function returning an instance. The collection_class callable is
executed once to produce a specimen, and the type of that specimen is
instrumented. Functions returning built-in types (e.g., lists) are adapted to
instrumented instances.

If extending a known type (e.g., list), additional decorations are generally not
needed, because the underlying methods are already instrumented. Decorating
them could trigger duplicate events, which is undesirable.

Internal architecture
---------------------
Key internal concepts:

- _AdaptedCollectionProtocol: Protocol describing the adapted collection interface
  expected by the instrumentation system. It defines core attributes and
  callable hooks:

  - _sa_adapter: CollectionAdapter
  - _sa_appender: Callable[..., Any]
  - _sa_remover: Callable[..., Any]
  - _sa_iterator: Callable[..., Iterable[Any]]
  - _sa_converter: _CollectionConverterProtocol

- _CollectionConverterProtocol: Protocol for a converter callable that transforms
  a collection into its instrumented form.

- _CollectionFactoryType: Factory type that returns an adapted collection
  instance.

Public API
----------
Note: The module exposes a set of public APIs and a number of internal
support structures. Publicly documented items include:

- collection: Namespace providing decorator helpers for instrumenting entity
  collection classes. It groups:
  - Annotating decorators (appender, remover, iterator, converter,
    internally_instrumented)
  - Recipe decorators (adds, removes_return, etc.)

  Example usage (as shown above) demonstrates annotating and recipe decorators
  used to emit proper collection events.

- collection_adapter: Internal helper bridging collection classes to the ORM’s
  event system.

- keyfunc_mapping, column_keyed_dict, attribute_keyed_dict, MappedCollection,
  KeyFuncDict: Utilities and types used to support keyed and mapped collection
  behaviors.

Usage examples
--------------
Generic decorator example:

  from sqlalchemy.orm import collection

  class MyClass:
      @collection.adds(1)
      def store(self, item):
          self.data.append(item)

      @collection.removes_return()
      def pop(self):
          return self.data.pop()

Instrumented built-ins (example):

  class InstrumentedList(list):
      pass

Relationship integration:

  # In a mapping configuration, specify the collection class
  relationship("Child", collection_class=InstrumentedList)

Notes
-----
- The instrumentation framework is designed to minimize interference with the
  underlying collection implementation while ensuring the ORM is informed of
  mutations.
- Bulk methods may be broken down into atomic events to align with the ORM’s
  change-tracking expectations.
- Some internals are marked as internal (e.g., _AdaptedCollectionProtocol,
  _CollectionConverterProtocol) and are not intended for direct use by application
  code.

See also
--------
- SQLAlchemy ORM core collection instrumentation concepts
- CollectionAdapter and mapped collection utilities

This documentation reflects the API surface and described behavior of the
collections instrumentation module used by the ORM for collection-backed
relationships.