Autowrap
========

Overview
--------

Autowrap provides a common interface for turning code generated by the codegen utilities into executable Python-callable binaries. It supports multiple backends (such as f2py, fwrap, Cython, SWIG, etc.), with current implementations for f2py and Cython. The goal is to offer accessible, high-performance numerical code with a simple oneâ€‘button workflow. A binary callable is returned for numerical evaluation, while a separate mechanism (binary_function) can return a symbolic wrapper suitable for use inside symbolic expressions.

Key concepts
------------

- The wrapper system compiles code into a Python module and exposes a function that can be called with numerical values.
- The binary callable is a Python function (not a symbolic Diofant object). If you need a symbolic representation, use binary_function to obtain a Diofant Function object.
- The wrapper stores metadata about the code generator, compilation flags, and file handling. It then builds, imports, and returns a wrapped function from the generated module.

API overview
------------

Public classes and exceptions

- CodeWrapError
  - Generic error raised during code wrapping (compilation, file handling, etc.).

- CodeWrapper
  - Base class for all code wrappers.
  - Core attributes:
    - generator: the code generator instance to use.
    - filepath: optional directory to place temporary files; if not provided, a temporary directory is used.
    - flags: extra command-line flags to pass to the wrapper tool.
    - quiet: when True, suppresses output from the build process.
  - Core properties:
    - filename: unique module filename for the current wrapper instance.
    - module_name: unique module name for the current wrapper instance.
  - Core methods:
    - wrap_code(routine, helpers=[]): orchestrates code generation, file preparation, compilation, and importing the wrapped module. Returns the wrapped function.
    - _generate_code(main_routine, routines): delegates code generation to the underlying generator and writes the code.
    - _process_files(routine): runs the external build tool and handles errors.

Concrete wrappers

- DummyWrapper
  - A testing wrapper that does not depend on any external backends.
  - _generate_code: writes a simple Python module that returns a string representation of the expression and exposes its arguments and return values for testing.
  - _prepare_files: no-op.
  - _process_files: no-op.
  - _get_wrapped_function: returns the function from the generated module.
  - Use case: fast, backendless testing of the wrapping pipeline.

- CythonCodeWrapper
  - Wrapper that uses Cython as the backend.
  - See the code for the exact setup and build steps (the implementation details are provided in the source).

Backends and dependencies
-------------------------

- The autowrap system tracks doctest dependencies to ensure required tools are available. For example:
  - doctest dependencies: exe = f2py, gfortran, gcc; modules = numpy

Using the wrappers
------------------

- Typical workflow:
  - Create or obtain a code generator for your expression or routine.
  - Instantiate a wrapper (e.g., DummyWrapper for testing or CythonCodeWrapper for production).
  - Call wrap_code with the main routine (and any helper routines) to compile and import the wrapped module.
  - Retrieve and call the wrapped function to evaluate numerically.

Extending
---------

- To add a new backend, subclass CodeWrapper and implement:
  - _generate_code(main_routine, routines): emit backend-specific source files.
  - _prepare_files(routine): prepare any auxiliary files or build configuration.
  - _process_files(routine): invoke the external build tool and handle errors.
  - _get_wrapped_function(mod, name): return the callable from the imported module (default patterns may apply).

Examples
--------

- Quick testing with the DummyWrapper (conceptual):

  - Build a dummy module that exposes a function named after the routine.
  - Import the module and obtain the wrapped function.
  - Call the wrapped function with numeric inputs to verify numerical behavior.

See also
--------

- f2py, gfortran, gcc (external backends and toolchains)
- numpy (numerical arrays and utilities)
- Cython (high-performance Python/C-extension workflow)

Notes
-----

- The autowrap module is designed to hide the details of code generation and binary wrapping behind a simple, unified interface, so users can focus on symbolic expression work while still obtaining fast numerical evaluations.