Camera Geometry
===============

Work with images or data cubes
--------------------------------

The camera geometry describes the layout of pixels in a Cherenkov camera and provides the information needed to work with per-pixel data in images and data cubes. It enables understanding where each pixel lies on the focal plane, how to map between pixel indices and coordinates, and how to combine or reproject data across different cameras or observations.

Key concepts
- Pixel layout: The geometry stores pixel center coordinates (for example, x and y on the focal plane) and, when available, the pixel shape and area. This allows accurate spatial operations on images such as masking, clustering, or footprint-based analyses.
- Pixel indexing: Each pixel has an identifier (pixel_id). The geometry provides mappings between pixel_id and its position in arrays (e.g., index arrays, masks).
- Images vs. data cubes:
  - Image (2D per camera): A single per-event, per-telescope per-camera image with one value per pixel (e.g., charge, photo-electrons).
  - Data cubes (3D): Time-resolved or multi-channel data with an extra axis, commonly shaped as (n_pixels, n_samples) or (n_samples, n_pixels), representing per-pixel values across time, gain groups, or other auxiliary dimensions.

Typical workflows
- Analyzing a single event image:
  - Access per-pixel values using the camera’s pixel indexing.
  - Use the pixel coordinates to plot the image in the correct camera footprint or to overlay with masks, outlines, or regions of interest.
- Working with waveforms or time-resolved data:
  - Represent the data as a 2D or 3D cube (e.g., per-pixel waveform: (n_pixels, n_samples)).
  - Use the geometry to reorder, mask, or integrate waveforms according to pixel positions.
- Reprojection and alignment:
  - Reproject images or cubes to a common geometry for comparison or stacking.
  - The camera geometry provides the necessary coordinate information to interpolate or map data between different camera layouts.
- Calibration and mask operations:
  - Apply pixel masks (e.g., dead or noisy pixels) using the pixel indices from the geometry.
  - Compute per-pixel areas or footprints to weight analyses, simulations, or image cleaning.

Practical tips
- Leverage pixel coordinate arrays (e.g., pix_x, pix_y) to visualize images in the camera’s native footprint.
- Use the mapping between pixel_id and index to efficiently access or mask data in arrays and cubes.
- When combining data from multiple cameras or subarrays, reproject or align images using the shared geometry information to preserve spatial relationships.
- For time-resolved studies, organize data cubes with the axes ordered consistently (e.g., (n_pixels, n_samples) or (n_samples, n_pixels)) to simplify processing and broadcasting in NumPy.

See also
- CameraDescription and CameraReadout for how raw signals are mapped to calibrated per-pixel data.
- OpticsDescription and FocalLengthKind for understanding how camera geometry relates to the telescope’s optical design.
- SubarrayDescription for managing multiple telescopes and their positions on the ground when constructing composite images or data cubes.