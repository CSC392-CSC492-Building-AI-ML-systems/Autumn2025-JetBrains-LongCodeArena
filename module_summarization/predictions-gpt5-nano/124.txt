Header Interface Transition Guide
===============================

Overview
--------

This guide documents the changes introduced to the header interface and how to transition to the new verification and notification-based mechanisms. The transition focuses on:

- A configurable verification framework for header values.
- A structured, multi-level error reporting mechanism.
- A listener-based notifier mixin to propagate header changes.

Key Components
--------------

Verification Framework
^^^^^^^^^^^^^^^^^^^^^^

- Verify-related exceptions and warnings
  - VerifyError: raised for critical verification failures.
  - VerifyWarning: used for non-fatal issues.

- VERIFY_OPTIONS
  A list of supported options controlling behavior:
  - ignore
  - warn
  - exception
  - fix
  - silentfix
  - fix+ignore
  - fix+warn
  - fix+exception
  - silentfix+ignore
  - silentfix+warn
  - silentfix+exception

- _Verify class
  - run_option(self, option="warn", err_text="", fix_text="Fixed.", fix=None, fixable=True) -> (bool, str)
    - Executes verification with the selected option.
    - If the option implies warning or exception, the issue is reported rather than fixed.
    - If fixable and a fix callable is provided, the fix is applied and the message is augmented.
  - verify(self, option="warn")
    - Validates the option against VERIFY_OPTIONS.
    - If option is "ignore", nothing is done.
    - Splits the option into fix and report components when appropriate (e.g., "fix+warn").
    - Controls reporting vs. fixing behavior (including silent modes).
    - Collects and formats errors from self._verify(opt) via errs.iter_lines.
    - Emits warnings or raises VerifyError with a consolidated message.

- _ErrList
  - A nested list structure used to accumulate verification error messages across class levels.
  - __str__(self): returns a string representation by joining top-level messages.
  - iter_lines(self, filter=None, shift=0): iterates nested messages with indentation suitable for hierarchical display.

Example (conceptual)
.. code-block:: python

   # Example usage of the verification framework
   v = _Verify()
   fixable, text = v.run_option(option="fix+warn",
                                err_text="Header key 'NAXIS' has an invalid value.",
                                fix=lambda: fix_header_value(header, 'NAXIS', 0))
   v.verify(option="fix+warn")

Notifier Mixin
--------------

- NotifierMixin
  - A mixin providing services for objects to register listeners for change events.
  - All methods are underscored, intended for internal use to communicate between classes.
  - Listeners are registered with a weak reference to avoid keeping objects alive unintentionally.
  - Use _notify('change_type', *args, **kwargs) to propagate changes; listeners receive calls to their corresponding update methods, if present (e.g., listener._update_change_type(*args, **kwargs)).

- Typical usage (illustrative):
  .. code-block:: python

     class Widget(NotifierMixin):
         state = 1
         def __init__(self, name):
             self.name = name
         def update_state(self):
             self.state += 1

Migration Guidelines
--------------------

- Replace ad-hoc header validation with the verification framework:
  - Use _Verify to perform value checks and control how issues are reported or fixed.
  - Collect and format errors with _ErrList for consistent output.

- Adopt the NotifierMixin pattern for header changes:
  - Register listeners to respond to header updates and propagate changes efficiently.

- Use the VERIFY_OPTIONS to tailor behavior for different contexts (e.g., strict validation in production, lenient checks during development).

- Ensure tests cover both fixable and non-fixable scenarios, and verify that appropriate warnings or exceptions are raised according to the chosen option.

References
----------

- Verification framework and error reporting: _Verify, _ErrList, and VERIFY_OPTIONS.
- Change notification pattern: NotifierMixin and its intended listener mechanism.