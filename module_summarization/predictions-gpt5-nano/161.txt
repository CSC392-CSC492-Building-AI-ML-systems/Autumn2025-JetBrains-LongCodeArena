Internal organization of NumPy arrays
=====================================

Introduction
------------
NumPy arrays (ndarray) are the foundational data structure for numerical
computation in NumPy. An array combines a data buffer with metadata that
describes how to interpret the bytes in memory. This metadata includes
the element type (dtype), the shape of the multi-dimensional array, and
the memory strides that define how to step through the data.

Core data structure
-------------------
An ndarray consists of:
- Data buffer: a pointer to the raw bytes in memory that hold the elements.
- Shape: a tuple of integers describing the size along each axis.
- Strides: a tuple of integers (byte steps) to move from one element to the next
  along each axis.
- dtype: a NumPy dtype object describing the element type, including size,
  kind (integer, floating, complex, etc.), byte order (endianness), and
  any subarray or structured fields.
- ndim and itemsize: the number of dimensions and the size in bytes of a single element.
- Flags: a set of booleans describing memory layout and capabilities
  (e.g., C-contiguous, Fortran-contiguous, writable, aligned).

Memory layout and contiguity
----------------------------
- Contiguity describes whether the data is laid out consecutively in memory.
  Common layouts are C-contiguous (row-major) and Fortran-contiguous
  (column-major). Strides determine how to traverse the buffer for each axis.
- Slicing and views preserve or modify strides without copying data, enabling
  efficient subarrays and broadcasting.

Dtype system and typing
-----------------------
- dtype objects specify element types and layout. They may represent:
  - Primitive scalar types (int, float, complex) with fixed sizes.
  - Endianness (big- or little-endian) for byte-order sensitive types.
  - Subarrays and structured dtypes (fields with named subelements).
- NumPy exposes a typed interface to arrays through a typing system used by the
  codebase and tooling:
  - NDArray: a type alias representing numpy.ndarray.
  - _ArrayLike: a broader category that includes arrays and array-like objects.
  - _ShapeLike: accepted shapes for array creation and operations.
  - DTypeLike, _DTypeLike, _VoidDTypeLike: typing aliases for dtype-related
    inputs.
  - _BoolCodes, _UByteCodes, _UShortCodes, _UIntCCodes, _UIntCodes, etc.:
    internal aliases used for describing and validating dtype components.
- The codebase employs TypeVar bindings to express generic array-related
  types (e.g., _DType bound to dtype[Any]), enabling static type checking
  and better IDE support for array operations and construction.

Python typing and generics
--------------------------
- The internal typing layer uses TypeVar and Generic to describe arrays with
  element types, enabling expressions like NDArray[T] in user code.
- This typing helps catch mismatches early and clarifies function signatures
  that operate on arrays with specific element types.

Performance and hardware integration
------------------------------------
- NumPy internals include CPU feature detection (e.g., __cpu_features__, __cpu_dispatch__)
  to tailor certain operations for available hardware, including SIMD paths.
- While not part of the raw data model, these features influence how array
  computations are executed and optimized at runtime.

Notes
-----
- The internal configuration collected during build (e.g., compiler settings)
  and system information is kept separate from the array data model but can
  affect how arrays are constructed and compiled for performance.
- The separation of data (buffer) and metadata (dtype, shape, strides) is
  central to NumPyâ€™s ability to provide views, broadcasting, and efficient
  in-place operations without copying data.