Memory alignment
================

Overview
--------
Memory alignment is the requirement that data be stored at addresses that are multiples of the data type’s alignment. Proper alignment improves load/store performance and can be essential for certain vectorized instructions.

NumPy and alignment
--------------------
NumPy arrays store their data contiguously according to the array’s dtype. The dtype exposes its alignment in dtype.alignment, which reflects how many bytes the type requires for correctly aligned access.

SIMD and alignment
------------------
NumPy uses SIMD (single-instruction, multiple-data) kernels (e.g., SSE, AVX, NEON) when available. These vectorized kernels perform best when input and output buffers are properly aligned. If memory is not suitably aligned, NumPy may fall back to scalar paths or less optimized code.

Build-time and runtime feature reporting
---------------------------------------
The build/runtime configuration records information about CPU features and available SIMD paths. In the configuration you may find:
- baseline: the CPU features assumed at build time
- found: features detected on the current CPU that can be used for SIMD
- not found: features not available on the current CPU

This information informs which SIMD-optimized kernels NumPy can employ. The runtime configuration is exposed in the SIMD Extensions section of the configuration.

Inspecting the SIMD configuration
-------------------------------
NumPy provides a helper to view the configuration at runtime. It can present the information in a human-readable form or as a dict, depending on the mode chosen.

Practical guidance
------------------
- Prefer data that is aligned to dtype.alignment to maximize SIMD throughput.
- When creating or transforming large arrays for vectorized kernels, ensure allocations maintain proper alignment.
- For structured dtypes, you can request alignment via dtype alignment to ensure proper memory layout for SIMD-friendly accesses.

Notes
-----
Alignment expectations and SIMD support are architecture- and build-dependent. The runtime show/inspect facilities reflect what was built for and what is available on the current CPU.