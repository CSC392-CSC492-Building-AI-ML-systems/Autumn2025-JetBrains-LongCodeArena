Iterables utilities
===================

Documentation for the iterable helpers implemented in the provided code. This module contains utilities for flattening and unflattening nested iterables, grouping adjacent elements, computing multisets, performing postorder traversals of trees, and generating subsets.

Functions
---------

flatten(iterable, levels=None, cls=None)
---------------------------------------

Recursively denest iterable containers.

Parameters
- iterable: The input iterable to flatten.
- levels: If provided, limit the number of nesting levels to flatten. If levels is 0, return the input as-is. If levels is negative, a ValueError is raised.
- cls: If provided, only flatten instances of this class. If None, any sequence-like object is flattened.

Returns
- A flat list containing all non-flattened elements in order.

Notes
- If levels is not None, the function will flatten up to the specified number of levels.
- When cls is provided, only elements of that class are flattened.

Examples
.. code-block:: python

   flatten([1, 2, [3]])
   # [1, 2, 3]

   flatten([1, [2, [3]]], levels=1)
   # [1, 2, [3]]

   class MyOp(Basic):
       pass

   flatten([MyOp(1, MyOp(2, 3))], cls=MyOp)
   # [1, 2, 3]

unflatten(iter, n=2)
--------------------

Group iter into tuples of length n. Raises an error if the length of iter is not a multiple of n.

Parameters
- iter: The input iterable to group.
- n: The size of each produced tuple.

Returns
- A list of n-tuples formed from the input by zipping elements with a stride of n.

Notes
- n must be >= 1.
- If the length of iter is not a multiple of n, a ValueError is raised.

Examples
.. code-block:: python

   unflatten([1, 2, 3, 4], n=2)
   # [(1, 2), (3, 4)]

   unflatten([1, 2, 3], n=2)
   # ValueError: iter length is not a multiple of 2

group(seq, multiple=True)
------------------------

Splits a sequence into a list of lists of equal, adjacent elements.

Parameters
- seq: The input sequence to group.
- multiple: If True, return a list of groups (each group is a list). If False, return a list of tuples (value, length) representing run-length encoding of the groups.

Returns
- If multiple is True: a list of lists, each sublist containing a run of equal consecutive elements.
- If multiple is False: a list of (value, count) pairs representing the run-length of each group.

Notes
- An empty input returns an empty list.
- See also multiset for a frequency-based representation.

Examples
.. code-block:: python

   group([1, 1, 1, 2, 2, 3])
   # [[1, 1, 1], [2, 2], [3]]

   group([1, 1, 3, 2, 2, 1], multiple=False)
   # [(1, 2), (3, 1), (2, 2), (1, 1)]

multiset(seq)
------------

Return the hashable sequence in multiset form with values being the multiplicity of the item in the sequence.

Parameters
- seq: The input sequence.

Returns
- A dict mapping each distinct element to its multiplicity in seq.

Notes
- Uses a defaultdict under the hood to count occurrences.

Examples
.. code-block:: python

   multiset('mississippi')
   # {'m': 1, 'i': 4, 's': 4, 'p': 2}

postorder_traversal(node, keys=None)
------------------------------------

Do a postorder traversal of a tree.

Parameters
- node: The root node of the tree. If the node is a diofant Basic object, its args are traversed in a postorder manner.
- keys: Sorting keys for arguments when traversing Basic objects. If None, arguments are processed in arbitrary order. If a specific key is provided (e.g., True or a key function), it controls the sort.

Returns
- A generator yielding nodes in postorder traversal order.

Notes
- The function relies on the diofant core to identify Basic objects and access their args.

Examples
.. code-block:: python

   # Given a tree structure using diofant's Basic objects
   list(postorder_traversal(w + (x + y)*z, keys=True))

subsets(seq, k=None, repetition=False)
--------------------------------------

Generates all k-subsets (combinations) from an n-element set, seq.

Parameters
- seq: The input sequence from which to generate subsets.
- k: The size of each subset; if None, all subsets of all sizes are generated from shortest to longest.
- repetition: If True, subsets are generated with element repetition allowed; if False, no repetition.

Returns
- A generator of subsets. Each subset is a tuple (or combination) of elements from seq.

Notes
- The number of k-subsets is given by binomial coefficients when k is specified.

Examples
.. code-block:: python

   list(subsets([1, 2], 2))
   # [(1, 2)]

   list(subsets([1, 2]))
   # [(), (1,), (2,), (1, 2)]

   list(subsets([1, 2, 3], 2))
   # [(1, 2), (1, 3), (2, 3)]

