Generate documentation for this code
====================================

.. module:: diofant.utilities.autowrap

This module provides utilities for compiling code generated by Diofant's codegen
module and wrapping the resulting binary for use in Python. It offers a unified
interface to various external backends such as f2py and Cython, allowing users
to easily evaluate complex mathematical expressions with high performance.

The main goal is to provide access to compiled binaries with acceptable
performance through a simple, one-button interface, without requiring users to
learn the details of the underlying wrapping tools.

Usage
-----

The primary function of this module is to convert Diofant expressions into
callable Python functions that execute compiled code. Here's a basic example:

    >>> from diofant.abc import x, y
    >>> expr = ((x - y)**25).expand()
    >>> binary_callable = autowrap(expr)
    >>> binary_callable(1, 2)
    -1.0

The callable returned from `autowrap()` is a binary Python function, not a
Diofant object. If you need to use the compiled function in symbolic
expressions, it's better to use `binary_function()`, which returns a Diofant
Function object. The binary callable is attached as the `_imp_` attribute and
invoked when a numerical evaluation is requested with `evalf()` or `lambdify()`:

    >>> f = binary_function('f', expr)
    >>> 2*f(x, y) + y
    y + 2*f(x, y)
    >>> (2*f(x, y) + y).evalf(2, subs={x: 1, y: 2}, strict=False)
    0.e-190

When to Use This Module
-----------------------

1. **Large Array Computations**: When Python iterations are too slow for large
   arrays and NumPy's advanced indexing operations are insufficient for the
   mathematical expression.

2. **Repeated Evaluations**: For very long expressions that will be called
   repeatedly, the compiled binary should be significantly faster than
   Diofant's `.evalf()`.

3. **Code Generation Testing**: If you're generating code with the codegen
   utility for use in another project, the automatic Python wrappers let you
   test the binaries immediately from within Diofant.

4. **Custom NumPy ufuncs**: To create customized universal functions for use
   with NumPy arrays (see `ufuncify`).

When NOT to Use This Module
---------------------------

1. **Performance-Critical Applications**: If you're really concerned about
   speed or memory optimizations, you'll probably get better results by working
   directly with the wrapper tools and low-level code. However, the files
   generated by this utility may provide a useful starting point and reference
   code. Temporary files will be left intact if you supply the keyword
   `tempdir="path/to/files/"`.

2. **Simple Array Operations**: If the array computation can be handled easily
   by NumPy and you don't need the binaries for another project.

Code Wrapper Classes
--------------------

.. autoclass:: CodeWrapper
   :members:

.. autoclass:: DummyWrapper
   :members:

.. autoclass:: CythonCodeWrapper
   :members:

Exceptions
----------

.. autoexception:: CodeWrapError
   :members:

Dependencies
------------

This module requires external compilers and wrapping tools:

- For Fortran wrapping: f2py and a Fortran compiler (e.g., gfortran)
- For Cython wrapping: Cython and a C compiler (e.g., gcc)
- NumPy is required for array operations

Testing
-------

The module includes a `DummyWrapper` class for testing independent of backends,
which can be useful for development and debugging purposes.