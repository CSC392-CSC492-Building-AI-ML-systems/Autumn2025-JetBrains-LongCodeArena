.. _mcmc:

Markov Chain Monte Carlo Framework
==================================

This module provides a framework for equilibrium sampling from a given thermodynamic state of a biomolecule using a Markov chain Monte Carlo (MCMC) scheme. The framework is designed to be flexible and extensible, allowing users to combine different types of moves and customize the simulation environment.

Supported Moves
---------------

The framework currently supports the following types of MCMC moves:

* **Langevin dynamics** - Assumed to be free of integration error (use at your own risk)
* **Hybrid Monte Carlo (HMC)**
* **Generalized Hybrid Monte Carlo (GHMC)**
* **Monte Carlo barostat moves**

These moves can be combined using the `SequenceMove` and `WeightedMove` classes to create complex sampling strategies.

Architecture
------------

The framework is built around two main components:

1. **MCMCMove**: An abstract base class that defines the interface for all MCMC moves
2. **MCMCSampler**: The main sampler class that orchestrates the MCMC simulation

MCMCMove Abstract Base Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `MCMCMove` class serves as the foundation for all MCMC moves in the framework. To create a new MCMC move, you must implement the `apply` method which takes a thermodynamic state and sampler state as parameters and modifies them according to the move's logic.

MCMCSampler Class
~~~~~~~~~~~~~~~~~

The `MCMCSampler` class manages the overall MCMC simulation. It maintains the current thermodynamic and sampler states and applies the specified moves during each iteration.

Context Management
------------------

By default, MCMC moves use the fastest available OpenMM platform and a shared global `ContextCache` that minimizes the number of OpenMM Context objects created. This optimization reduces computational overhead and improves performance.

You can configure the platform and caching behavior in several ways:

1. **Global configuration**:
   .. code-block:: python
   
       reference_platform = openmm.Platform.getPlatformByName('Reference')
       cache.global_context_cache.platform = reference_platform
       cache.global_context_cache.time_to_live = 10

2. **Local caches**:
   .. code-block:: python
   
       local_cache = cache.ContextCache(capacity=5, time_to_live=50)
       move = GHMCMove(context_cache=local_cache)

3. **No caching**:
   .. code-block:: python
   
       dummy_cache = cache.DummyContextCache(platform=reference_platform)
       move = GHMCMove(context_cache=dummy_cache)

Examples
--------

Basic Usage
~~~~~~~~~~~

.. code-block:: python

    from simtk import unit
    from openmmtools import testsystems, cache
    from openmmtools.states import ThermodynamicState, SamplerState

    # Create the initial state for an alanine dipeptide system in vacuum
    test = testsystems.AlanineDipeptideVacuum()
    thermodynamic_state = ThermodynamicState(system=test.system,
                                             temperature=298*unit.kelvin)
    sampler_state = SamplerState(positions=test.positions)

    # Create an MCMC move and sampler
    ghmc_move = GHMCMove(timestep=1.0*unit.femtosecond, n_steps=50)
    sampler = MCMCSampler(thermodynamic_state, sampler_state, move=ghmc_move)

    # Minimize and run the simulation
    sampler.minimize()
    sampler.run(n_iterations=2)

Combining Moves
~~~~~~~~~~~~~~~

Sequence of moves:
.. code-block:: python

    sequence_move = SequenceMove([ghmc_move, langevin_move])
    sampler = MCMCSampler(thermodynamic_state, sampler_state, move=sequence_move)

Weighted random selection:
.. code-block:: python

    weighted_move = WeightedMove([(ghmc_move, 0.5), (langevin_move, 0.5)])
    sampler = MCMCSampler(thermodynamic_state, sampler_state, move=weighted_move)

References
----------

For more information about Monte Carlo strategies in scientific computing, see:

Jun S. Liu. Monte Carlo Strategies in Scientific Computing. Springer, 2008.