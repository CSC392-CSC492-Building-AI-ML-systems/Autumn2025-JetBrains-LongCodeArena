Parallel Random Number Generation
=================================

NumPy's ``random`` module provides support for parallel random number generation through the use of independent bit generators that can be used in parallel processes or threads without interference. This is essential for applications that require reproducible random number sequences across multiple processes or threads, such as Monte Carlo simulations, parallelized machine learning algorithms, and other high-performance computing tasks.

Overview
--------

The key to parallel random number generation in NumPy is the use of independent bit generators. Each process or thread should use its own instance of a bit generator, initialized with a unique seed or state. This ensures that the random number streams are statistically independent and do not overlap.

NumPy provides several bit generator classes that are suitable for parallel use:

- ``MT19937``: The Mersenne Twister generator
- ``PCG64``: The PCG generator (64-bit)
- ``Philox``: The Philox generator (4x32)
- ``SFC64``: The SFC (Small Fast Counting) generator

Each of these generators can be instantiated with a unique seed or state, making them suitable for parallel applications.

Best Practices
--------------

1. **Use Independent Generators**: Each process or thread should have its own instance of a bit generator. Sharing a single generator between threads or processes can lead to correlation between the random number streams.

2. **Seed Properly**: Use a method that ensures each generator instance gets a unique seed. One common approach is to use a master seed to generate a sequence of unique seeds for each generator.

3. **Use SeedSequence**: NumPy's ``SeedSequence`` class is designed to help with seeding multiple generators. It can generate a sequence of seeds that are guaranteed to be unique and suitable for parallel use.

Example
-------

Here is an example of how to use NumPy's random number generation in a parallel context using ``concurrent.futures``:

.. code-block:: python

    import numpy as np
    from concurrent.futures import ProcessPoolExecutor
    from numpy.random import SeedSequence, PCG64

    def worker(seed_seq):
        # Create a bit generator with the provided seed sequence
        rng = np.random.Generator(PCG64(seed_seq))
        # Generate some random numbers
        return rng.random(1000)

    # Create a master seed sequence
    master_seed = SeedSequence(12345)
    # Spawn child seed sequences for each process
    child_seeds = master_seed.spawn(4)

    # Use ProcessPoolExecutor to run the worker function in parallel
    with ProcessPoolExecutor() as executor:
        results = list(executor.map(worker, child_seeds))

    # Each result contains 1000 random numbers generated independently
    print(len(results))  # 4
    print(len(results[0]))  # 1000

In this example, ``SeedSequence.spawn()`` is used to generate unique seed sequences for each process. Each process then creates its own ``Generator`` instance with a ``PCG64`` bit generator, ensuring that the random number streams are independent.

Thread Safety
-------------

While NumPy's random number generators are not thread-safe when shared between threads, they are safe to use in a parallel environment where each thread has its own generator instance. For threading, ensure that each thread creates and uses its own generator instance.

Legacy Random State
-------------------

The legacy ``numpy.random.RandomState`` is not recommended for new parallel applications. While it can be used in parallel contexts, the newer ``Generator`` and bit generator classes provide better performance and more features for parallel random number generation.

See Also
--------

- :ref:`random`
- :ref:`random-bit-generators`
- :ref:`random-seedsequence`