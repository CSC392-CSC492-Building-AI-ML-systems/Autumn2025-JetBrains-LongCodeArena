Transforms
==========

The ``transforms`` module provides a set of common image transformations that can be chained together using :class:`torchvision.transforms.Compose`. These transformations are commonly used for data augmentation and preprocessing in computer vision tasks.

This module includes both functional and class-based transforms. Functional transforms provide fine-grained control over transformations, while class-based transforms offer convenient ways to apply transformations with predefined parameters.

Functional Transforms
---------------------

The functional transforms are pure functions that apply transformations to images. They support both PIL Images and torch Tensors as input.

Interpolation Modes
^^^^^^^^^^^^^^^^^^^

Several transforms support different interpolation methods through the ``InterpolationMode`` enum:

.. autoclass:: torchvision.transforms.functional.InterpolationMode
   :members:
   :undoc-members:

Available interpolation methods:
  - ``NEAREST``: Nearest neighbor interpolation
  - ``NEAREST_EXACT``: Nearest neighbor interpolation (exact)
  - ``BILINEAR``: Bilinear interpolation
  - ``BICUBIC``: Bicubic interpolation
  - ``BOX``: Box interpolation
  - ``HAMMING``: Hamming interpolation
  - ``LANCZOS``: Lanczos interpolation

Utility Functions
^^^^^^^^^^^^^^^^^

.. autofunction:: torchvision.transforms.functional.get_dimensions

.. autofunction:: torchvision.transforms.functional.get_image_size

.. autofunction:: torchvision.transforms.functional.get_image_num_channels

.. autofunction:: torchvision.transforms.functional.to_tensor

.. autofunction:: torchvision.transforms.functional.pil_to_tensor

Examples
--------

Basic Usage
^^^^^^^^^^^

Converting a PIL Image to Tensor:

.. code-block:: python

    from PIL import Image
    from torchvision.transforms.functional import to_tensor
    
    # Load an image
    img = Image.open('example.jpg')
    
    # Convert to tensor
    tensor_img = to_tensor(img)
    print(tensor_img.shape)  # [C, H, W]

Using Interpolation Modes:

.. code-block:: python

    from PIL import Image
    from torchvision.transforms.functional import InterpolationMode
    
    img = Image.open('example.jpg')
    
    # Use different interpolation methods
    mode_nearest = InterpolationMode.NEAREST
    mode_bilinear = InterpolationMode.BILINEAR

Image Conversion Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

    import numpy as np
    import torch
    from PIL import Image
    from torchvision.transforms.functional import to_tensor, pil_to_tensor, get_image_size
    
    # Create a sample PIL image
    pil_img = Image.new('RGB', (100, 100), color='red')
    
    # Convert to tensor
    tensor_img = to_tensor(pil_img)
    print(f"Tensor shape: {tensor_img.shape}")  # [3, 100, 100]
    print(f"Tensor range: {tensor_img.min()} to {tensor_img.max()}")  # 0.0 to 1.0
    
    # Convert PIL to tensor (preserving data type)
    tensor_preserved = pil_to_tensor(pil_img)
    print(f"Preserved tensor type: {tensor_preserved.dtype}")  # torch.uint8
    
    # Get image properties
    size = get_image_size(pil_img)
    print(f"Image size: {size}")  # [100, 100]
    
    dimensions = get_dimensions(pil_img)
    print(f"Image dimensions: {dimensions}")  # [3, 100, 100]

Working with NumPy Arrays:

.. code-block:: python

    import numpy as np
    from torchvision.transforms.functional import to_tensor
    
    # Create a numpy array image (H, W, C)
    np_img = np.random.randint(0, 255, (64, 64, 3), dtype=np.uint8)
    
    # Convert to tensor
    tensor_img = to_tensor(np_img)
    print(f"Converted shape: {tensor_img.shape}")  # [3, 64, 64]

Notes
-----

- All functional transforms support both PIL Images and torch Tensors as input
- When using Tensors, the expected format is ``[C, H, W]`` (channels, height, width)
- The ``to_tensor`` function normalizes pixel values to the range [0, 1] and converts to float
- The ``pil_to_tensor`` function preserves the original data type of the PIL Image
- Interpolation modes provide control over the quality of resizing operations
- Utility functions like ``get_image_size`` and ``get_dimensions`` work with both PIL and Tensor inputs