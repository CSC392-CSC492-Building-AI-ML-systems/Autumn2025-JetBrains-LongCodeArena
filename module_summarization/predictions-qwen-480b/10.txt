Using Metadata
==============

Metadata in the ftrack API provides a flexible way to store and retrieve additional information associated with entities. This allows you to extend the default schema with custom data that is specific to your pipeline or workflow requirements.

Accessing Metadata
------------------

Metadata is accessed through the ``metadata`` attribute on any ftrack entity. This attribute behaves like a dictionary, allowing you to get and set key-value pairs:

.. code-block:: python

    # Access metadata on an entity
    project = session.query('Project where name is "MyProject"').first()
    
    # Retrieve a metadata value
    custom_setting = project['metadata'].get('custom_setting')
    
    # Set a metadata value
    project['metadata']['custom_setting'] = 'enabled'
    
    # Update multiple metadata values
    project['metadata'].update({
        'render_engine': 'Arnold',
        'frame_rate': '24fps'
    })

Metadata values are automatically serialized to JSON when stored and deserialized when retrieved, allowing you to store complex data structures:

.. code-block:: python

    # Store complex data structures
    project['metadata']['render_settings'] = {
        'resolution': [1920, 1080],
        'samples': 128,
        'output_paths': ['/renders/shot01', '/renders/shot02']
    }

Working with Metadata Operations
--------------------------------

Changes to metadata are tracked as operations within the session and are committed to the server when you call ``session.commit()``:

.. code-block:: python

    # Modify metadata
    task = session.query('Task where name is "Animation"').first()
    task['metadata']['status'] = 'in_progress'
    task['metadata']['artist_notes'] = 'Blocking stage complete'
    
    # Commit changes to server
    session.commit()

You can also work with metadata in batch operations:

.. code-block:: python

    # Update metadata for multiple entities
    assets = session.query('AssetVersion where project.name is "MyProject"').all()
    
    for asset in assets:
        asset['metadata']['review_status'] = 'pending'
        asset['metadata']['review_date'] = datetime.datetime.now().isoformat()
    
    session.commit()

Metadata Schema Considerations
------------------------------

While metadata provides flexibility, consider these best practices:

1. **Use for supplementary data**: Metadata should store additional information that extends entities beyond the core schema, not replace proper schema design.

2. **Naming conventions**: Use consistent key naming (e.g., snake_case) to maintain organized metadata structures.

3. **Performance**: Avoid storing large binary data directly in metadata. Instead, store references to external resources.

4. **Data types**: Since metadata values are JSON-serialized, they will maintain their basic data types (strings, numbers, booleans, lists, dictionaries) but not complex Python objects.

Querying by Metadata
--------------------

While direct querying of metadata values is not supported in ftrack's query language, you can filter entities based on their metadata after retrieval:

.. code-block:: python

    # Retrieve entities and filter by metadata
    all_tasks = session.query('Task').all()
    
    # Filter tasks with specific metadata
    reviewed_tasks = [
        task for task in all_tasks 
        if task['metadata'].get('review_status') == 'approved'
    ]

This approach works well for smaller datasets but consider performance implications when working with large numbers of entities.