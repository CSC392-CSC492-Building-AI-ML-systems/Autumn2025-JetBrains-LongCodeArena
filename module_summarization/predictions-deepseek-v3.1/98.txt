.. _contracts:

Contracts
=========

The ``Contract`` class provides a base for creating and interacting with smart contracts through the Web3 connector. It allows for deployment of new contracts and interaction with existing deployed contracts.

Overview
--------

The Contract class serves as a proxy for smart contract interactions, handling ABI encoding/decoding, event filtering, and transaction management. It is designed to be subclassed with specific contract ABIs generated from compiled Solidity contracts.

Class: Contract
---------------

Base class for Contract proxy classes.

First you need to create your Contract classes using :func:`construct_contract_factory` that takes compiled Solidity contract ABI definitions as input. The created class object will be a subclass of this base class.

After you have your Contract proxy class created you can interact with smart contracts:

* Create a Contract proxy object for an existing deployed smart contract by its address using :meth:`__init__`
* Deploy a new smart contract using :py:meth:`Contract.deploy`

Properties
~~~~~~~~~~

.. py:attribute:: web3

    Web3 instance reference (set during class construction)

.. py:attribute:: address

    Contract address as 0x-prefixed hex string (instance level)

.. py:attribute:: abi

    Contract ABI definition

.. py:attribute:: code

    Contract bytecode

.. py:attribute:: code_runtime

    Contract runtime bytecode

.. py:attribute:: source

    Contract source code

Methods
~~~~~~~

.. py:method:: __init__(abi=None, address=None, code=None, code_runtime=None, source=None)

    Create a new smart contract proxy object.

    :param address: Contract address as 0x hex string
    :param abi: Override class level definition
    :param code: Override class level definition
    :param code_runtime: Override class level definition
    :param source: Override class level definition

.. py:method:: deploy(transaction=None, args=None, kwargs=None)

    Deploys the contract on a blockchain.

    Example:

    .. code-block:: python

        >>> MyContract.deploy(
            transaction={
                'from': web3.eth.accounts[1],
                'value': 12345,
            },
            args=('DGD', 18),
        )
        '0x5c504ed432cb51138bcf09aa5e8a410dd4a1e204ef84bfed1be16dfba1b22060'

    :param transaction: Transaction parameters for the deployment transaction as a dict
    :param args: The contract constructor arguments as positional arguments
    :param kwargs: The contract constructor arguments as keyword arguments
    :return: hexadecimal transaction hash of the deployment transaction

.. py:method:: encodeABI(fn_name, args=None, kwargs=None, data=None)

    Encodes the arguments using the Ethereum ABI for the contract function that matches the given name and arguments.

    :param fn_name: Name of the function to encode
    :param args: Function arguments as positional arguments
    :param kwargs: Function arguments as keyword arguments
    :param data: Defaults to function selector
    :return: ABI-encoded function call data

.. py:method:: on(event_name, filter_params=None, *callbacks)

    Register a callback to be triggered on the appropriate events.

    :param event_name: Name of the event to listen for
    :param filter_params: Filter parameters for event filtering
    :param callbacks: Callback functions to be triggered

Dependencies
------------

The Contract class relies on several utility modules for ABI handling, encoding, and Web3 integration:

* ``eth_abi`` for ABI encoding/decoding
* Various ``web3.utils`` modules for encoding, formatting, and functional utilities
* Event and filter utilities for handling contract events

Note: This is a base class and should be subclassed with specific contract ABIs for full functionality.