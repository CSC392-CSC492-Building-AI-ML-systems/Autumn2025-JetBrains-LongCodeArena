`iterables` Module
==================

The `iterables` module provides a collection of utility functions for working with iterables and sequences in various ways, including flattening nested structures, grouping elements, traversing trees, and generating subsets.

Functions
---------

### `flatten(iterable, levels=None, cls=None)`

Recursively denest iterable containers.

**Parameters:**
- `iterable`: The input iterable to flatten.
- `levels` (optional): If specified, only flattens up to the given number of nesting levels. Must be a non-negative integer.
- `cls` (optional): If specified, only flattens instances of the given class.

**Returns:**
A flattened list of elements.

**Examples:**
```python
>>> flatten([1, 2, 3])
[1, 2, 3]
>>> flatten([1, 2, [3]])
[1, 2, 3]
>>> flatten([1, [2, 3], [4, 5]])
[1, 2, 3, 4, 5]
>>> flatten([1.0, 2, (1, None)])
[1.0, 2, 1, None]
>>> ls = [[(-2, -1), (1, 2)], [(0, 0)]]
>>> flatten(ls, levels=1)
[(-2, -1), (1, 2), (0, 0)]
```

**Notes:**
Adapted from an external source. If `cls` is provided, it will only flatten instances of that class.

---

### `unflatten(iter, n=2)`

Groups the input iterable into tuples of length `n`. Raises an error if the length of the iterable is not a multiple of `n`.

**Parameters:**
- `iter`: The input iterable to group.
- `n`: The length of each tuple (default is 2).

**Returns:**
A list of tuples, each of length `n`.

**Raises:**
- `ValueError`: If the length of `iter` is not a multiple of `n` or if `n` is less than 1.

---

### `group(seq, multiple=True)`

Splits a sequence into groups of equal, adjacent elements.

**Parameters:**
- `seq`: The input sequence to group.
- `multiple` (optional): If `True` (default), returns lists of grouped elements. If `False`, returns tuples of (element, count).

**Returns:**
A list of groups (either as lists or tuples, depending on `multiple`).

**Examples:**
```python
>>> group([1, 1, 1, 2, 2, 3])
[[1, 1, 1], [2, 2], [3]]
>>> group([1, 1, 1, 2, 2, 3], multiple=False)
[(1, 3), (2, 2), (3, 1)]
```

**See Also:**
`multiset`

---

### `multiset(seq)`

Returns the multiset form of a hashable sequence, with keys as elements and values as multiplicities.

**Parameters:**
- `seq`: The input sequence.

**Returns:**
A dictionary where keys are unique elements from `seq` and values are their counts.

**Examples:**
```python
>>> multiset('mississippi')
{'i': 4, 'm': 1, 'p': 2, 's': 4}
```

**See Also:**
`group`

---

### `postorder_traversal(node, keys=None)`

Performs a postorder traversal of a tree (e.g., a Diofant expression tree).

**Parameters:**
- `node`: The root node of the tree to traverse (e.g., a Diofant expression).
- `keys` (optional): Sort key(s) for ordering the arguments of Basic objects. If `None`, processed arbitrarily. If `True`, uses default sorting.

**Yields:**
Subtrees of the input node in postorder.

**Examples:**
```python
>>> from diofant.abc import w
>>> list(postorder_traversal(w + (x + y)*z, keys=True))
[w, z, x, y, x + y, z*(x + y), w + z*(x + y)]
```

**Notes:**
Useful for traversing expression trees in a depth-first manner.

---

### `subsets(seq, k=None, repetition=False)`

Generates all k-subsets (combinations) from an n-element set.

**Parameters:**
- `seq`: The input sequence (n-element set).
- `k` (optional): The size of the subsets. If `None`, returns all subsets from shortest to longest.
- `repetition` (optional): If `True`, allows repetition (combinations with repetition). Not fully implemented in the provided code.

**Returns:**
A generator yielding tuples representing the subsets.

**Examples:**
```python
>>> list(subsets([1, 2], 2))
[(1, 2)]
>>> list(subsets([1, 2]))
[(), (1,), (2,), (1, 2)]
>>> list(subsets([1, 2, 3], 2))
[(1, 2), (1, 3), (2, 3)]
```

**Notes:**
The number of k-subsets without repetition is given by the binomial coefficient C(n, k). The total number of subsets is 2^n.