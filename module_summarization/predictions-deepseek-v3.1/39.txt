.. _models:

Models
======

The Model class is the core component of Tortoise ORM, providing an interface for defining database schema and interacting with data. This document covers the key aspects of model usage.

Model Definition
----------------

Models are defined as Python classes that inherit from the base ``Model`` class. The model's structure is defined using field classes that map to database column types.

Basic Example:
.. code-block:: python

    from tortoise.models import Model
    from tortoise import fields
    
    class User(Model):
        id = fields.IntField(pk=True)
        name = fields.CharField(max_length=255)
        email = fields.CharField(max_length=255, unique=True)
        created_at = fields.DatetimeField(auto_now_add=True)

Meta Class Options
------------------

The inner ``Meta`` class provides configuration options for the model:

- ``abstract``: Boolean indicating if the model is abstract (cannot be instantiated)
- ``table``: Custom table name (defaults to snake_case of class name)
- ``app``: Application namespace for the model
- ``ordering``: Default ordering for queries
- ``unique_together``: Tuple of field combinations that must be unique
- ``indexes``: Tuple of field combinations to index

Field Types
-----------

Tortoise supports various field types including:

- Data fields: ``IntField``, ``CharField``, ``BooleanField``, ``DatetimeField``, etc.
- Relational fields: ``ForeignKeyField``, ``OneToOneField``, ``ManyToManyField``
- Special fields: ``JSONField``, ``BinaryField``

Relationships
-------------

The ORM supports all standard relationship types:

- **Foreign Keys**: Many-to-one relationships
- **One-to-One**: Exclusive relationships between models  
- **Many-to-Many**: Complex relationships through join tables
- **Reverse Relations**: Access related objects from the "many" side

Querying
--------

Models provide a queryset interface for data retrieval:

.. code-block:: python

    # Basic filtering
    users = await User.filter(name__startswith="John")
    
    # Complex queries
    active_users = await User.filter(
        Q(is_active=True) & Q(created_at__gte=datetime.now() - timedelta(days=30))
    )
    
    # Aggregations
    count = await User.all().count()

Signals
-------

Models support signal handlers for lifecycle events:

- ``pre_save``, ``post_save``
- ``pre_delete``, ``post_delete``
- ``pre_update``, ``post_update``

Transactions
------------

The model supports database transactions through context managers and decorators:

.. code-block:: python

    async with in_transaction() as connection:
        user = await User.create(name="John", using_db=connection)
        await user.save(using_db=connection)

Advanced Features
-----------------

- **Bulk operations**: Create, update, or delete multiple records efficiently
- **Field validation**: Automatic validation based on field constraints
- **Query optimization**: Select related, prefetch related, and only/defer fields
- **Custom functions**: Use database functions in queries
- **Table comments**: Document your schema with field-level comments using ``#:`` format

The Model class provides a comprehensive ORM solution with support for complex data modeling, efficient querying, and database-agnostic operations.