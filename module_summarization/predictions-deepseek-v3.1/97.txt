How Mitogen Works
==================

Mitogen is a Python library for writing distributed programs. It enables seamless execution of code across multiple machines, containers, or processes by abstracting away the complexities of inter-process communication, serialization, and module distribution. This document provides a high-level overview of how Mitogen operates.

Core Concepts
-------------

**Contexts and Messages**
Mitogen operates using the concept of "contexts," which represent individual execution environments (e.g., a remote machine, a local subprocess, or a container). Communication between contexts is handled through messages. Each message contains a type, source, destination, and serialized data.

**Message Types**
Mitogen defines several core message types to manage distributed operations:

- ``GET_MODULE``: Requests a module to be loaded and transmitted to a context.
- ``CALL_FUNCTION``: Invokes a function in a remote context.
- ``FORWARD_LOG``: Forwards log messages for centralized logging.
- ``ADD_ROUTE`` / ``DEL_ROUTE``: Manages routing paths between contexts.
- ``ALLOCATE_ID``: Assigns unique identifiers for resources.
- ``SHUTDOWN``: Signals a context to terminate.
- ``LOAD_MODULE`` / ``FORWARD_MODULE``: Handles module distribution and loading.
- ``CALL_SERVICE`` / ``STUB_CALL_SERVICE``: Used for service invocations and stubs.

**Serialization and Codec**
Mitogen uses Python's ``pickle`` (or ``cPickle`` where available) for serializing objects. To avoid encoding-related deadlocks, it employs a dedicated Latin-1 codec for string operations. The library ensures compatibility across Python versions (2.4 through 3.x) by handling type and module differences dynamically.

**Bootstrap and Module Distribution**
A key part of Mitogen is its bootstrap mechanism. When a new context (or "slave") is created, a minimal version of Mitogen's core is transmitted to initialize the environment. This bootstrap code handles further module loading, message reception, and function calls. Modules are transmitted on-demand using the ``GET_MODULE`` and ``FORWARD_MODULE`` messages, ensuring only necessary code is sent to each context.

**I/O and Buffering**
Mitogen uses non-blocking I/O and a broker pattern to manage communication channels efficiently. The default buffer size for reads and writes is set to 128 KiB, balancing performance and resource usage. This size minimizes system calls while avoiding excessive memory allocation.

**Error Handling and Disconnection**
The special value ``IS_DEAD`` (999) is used in the ``reply_to`` field of messages to indicate disconnection or routing failure. This triggers a ``ChannelError`` and allows the system to handle failures gracefully.

Workflow Example
----------------

1. **Initialization**: A master context creates a connection to a slave (e.g., via SSH, subprocess, or Docker).
2. **Bootstrap**: The master sends the minimal Mitogen core to the slave, which initializes and becomes operational.
3. **Module Loading**: When a function call requires a module not present on the slave, a ``GET_MODULE`` message is sent to fetch it.
4. **Function Execution**: The master sends a ``CALL_FUNCTION`` message to the slave, which executes the function and returns the result.
5. **Routing**: Messages are routed between contexts using dynamically managed routes, allowing complex topologies (e.g., cascading contexts).
6. **Teardown**: On shutdown, a ``SHUTDOWN`` message is sent to all contexts, ensuring clean termination.

Compatibility and Performance
-----------------------------

Mitogen supports Python 2.4 through 3.x, handling differences in types, exceptions, and modules dynamically. It optimizes performance by:

- Using efficient serialization and compression (e.g., ``zlib``).
- Minimizing context switches through large buffer sizes.
- Reducing network traffic via on-demand module loading.
- Employing non-blocking I/O and multiplexing (e.g., ``select``).

This design makes Mitogen suitable for high-performance distributed tasks, such as automation, orchestration, and parallel computation.