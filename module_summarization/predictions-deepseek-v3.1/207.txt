Decision Trees
==============

The Decision Tree implementation in this library provides a flexible and efficient framework for both classification and regression tasks. It is built using Cython for performance and supports various impurity criteria to evaluate the quality of splits.

Criterion Class
---------------

The core component for evaluating splits is the abstract `Criterion` class, which defines the interface for impurity criteria.

### Methods

#### `init`
Initializes the criterion with necessary data buffers and parameters.

**Parameters:**
- `y`: Target values as a 2D memoryview
- `sample_weight`: Sample weights as a memoryview
- `weighted_n_samples`: Total weighted sample count
- `sample_indices`: Array of sample indices to consider
- `start`: Starting index for the current node
- `end`: Ending index for the current node

#### `init_missing`
Handles initialization when missing values are present in the data.

**Parameters:**
- `n_missing`: Number of missing values for a specific feature

#### `reset`
Resets the criterion to its initial state at position `start`.

#### `reverse_reset`
Resets the criterion at position `end`.

#### `update`
Updates statistics by moving samples from the right child to the left child.

**Parameters:**
- `new_pos`: New position index for the split

#### `node_impurity`
Calculates the impurity of the current node. Lower values indicate better purity.

#### `children_impurity`
Calculates the impurity values for both left and right children.

**Parameters:**
- `impurity_left`: Pointer to store left child impurity
- `impurity_right`: Pointer to store right child impurity

#### `node_value`
Computes and stores the value of the current node.

**Parameters:**
- `dest`: Memory address to store the node value

#### `clip_node_value`
Clips the node value between specified bounds (for monotonic constraints).

#### `middle_value`
Computes the middle value of a split for monotonicity constraints.

#### `proxy_impurity_improvement`
Computes a proxy value for impurity improvement to speed up split search.

#### `impurity_improvement`
Computes the actual impurity improvement after a split.

**Parameters:**
- `impurity_parent`: Parent node impurity before split
- `impurity_left`: Left child impurity
- `impurity_right`: Right child impurity

Implementation Details
----------------------

The implementation uses:
- Memory-efficient Cython memoryviews for data handling
- Optimized C-level mathematical operations
- Support for weighted samples and missing values
- Monotonic constraint enforcement through value clipping

The decision tree algorithm works by recursively partitioning the feature space using the criterion to evaluate potential splits, selecting those that maximize impurity improvement at each node.