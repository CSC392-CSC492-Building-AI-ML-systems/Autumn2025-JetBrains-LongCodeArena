File Objects
============

Overview
--------
File objects in h5py represent HDF5 file identifiers and are implemented through the ``ObjectID`` base class. These objects manage low-level HDF5 identifiers, ensuring proper resource management, thread safety, and prevention of identifier reuse issues, especially in multithreaded environments or when interacting with other HDF5 libraries.

Thread Safety and Locking
-------------------------
Access to low-level HDF5 API routines is serialized using a global recursive lock (``phil``) to prevent race conditions. This ensures only one thread can execute any low-level routine at a time. The lock is managed internally but can be accessed from other modules if needed.

A decorator ``with_phil`` is provided to wrap functions that require locking:

.. code-block:: python

    @with_phil
    def example_function(args):
        # Code executed with lock held
        pass

Note: While h5py is thread-safe, it is not designed to be used simultaneously with other HDF5 libraries (e.g., PyTables or NetCDF4) in the same process due to potential identifier conflicts.

Identifier Management and Registry
----------------------------------
HDF5 identifiers may be reused immediately after closure, leading to potential "zombie" identifiers. To mitigate this, h5py maintains a registry of all live ``ObjectID`` instances. The registry tracks objects and invalidates identifiers when nonlocal closure events occur (e.g., when a file is closed with ``H5F_CLOSE_STRONG``, which also closes dependent objects).

Key functions for registry management:

- ``nonlocal_close()``: Scans the registry and sets stale identifiers to 0 to prevent reuse.
- ``print_reg()``: Prints statistics about the registry (for debugging).

ObjectID Class
--------------
The ``ObjectID`` class is the base for all HDF5 identifier objects, including files. It provides core functionality for identifier handling.

**Attributes:**

- ``id`` (readonly): The underlying HDF5 identifier (``hid_t``).
- ``locked``: If set to 1, the object cannot be closed (default is 0).
- ``fileno``: Returns a tuple ``(fileno[0], fileno[1])`` representing the file number.
- ``valid``: Returns ``True`` if the HDF5 identifier is valid.

**Methods:**

- ``__cinit__(id_)``: Initializes the object with an HDF5 identifier and registers it.
- ``__dealloc__()``: Decrements the reference count of the HDF5 identifier and unregisters the object (if not locked).

**Example Usage:**

.. code-block:: python

    cdef ObjectID obj = ObjectID(hdf5_id)
    print(obj.valid)  # Check if the identifier is valid
    print(obj.fileno) # Retrieve file number information

Debugging
---------
Debugging support is available via the ``DEBUG_ID`` compile-time flag. When enabled, registration and deregistration of identifiers are printed, aiding in tracking object lifecycle issues.

Notes
-----
- The registry uses weak references to avoid memory leaks.
- Objects marked as ``locked`` are excluded from automatic closure operations.
- Manual invocation of ``nonlocal_close()`` is necessary in certain scenarios (e.g., when closing a file with strong consistency).

See the high-level ``File`` class and related modules for user-friendly file handling interfaces.