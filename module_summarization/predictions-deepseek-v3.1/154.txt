Connecting Steps Together
=========================

The ``mflowgen`` framework provides a flexible mechanism for connecting steps together in a build flow. This document describes how to establish connections between steps using the provided API.

Edge Class
----------

The ``Edge`` class represents a connection between two steps:

.. code-block:: python

  class Edge:
    def __init__(s, src, dst):
      s.src = src
      s.dst = dst
    
    def get_src(s):
      return s.src
    
    def get_dst(s):
      return s.dst

Step Connection API
-------------------

The ``Step`` class provides several methods for creating connections between steps:

Input and Output Handles
~~~~~~~~~~~~~~~~~~~~~~~~

Use these methods to get handles that can be connected using the Graph's ``.connect()`` method:

.. code-block:: python

  # Get input handle for a specific file
  step.get_input_handle(f)
  
  # Get output handle for a specific file  
  step.get_output_handle(f)
  
  # Syntactic sugar equivalents
  step.i(name)  # Input handle
  step.o(name)  # Output handle

Example usage:

.. code-block:: python

  # Connect step1's output to step2's input
  g.connect(step1.o('data.out'), step2.i('data.in'))

Bulk Handle Access
~~~~~~~~~~~~~~~~~~

Get all input or output handles at once:

.. code-block:: python

  # Get all input handles
  step.all_input_handles()
  
  # Get all output handles
  step.all_output_handles()

This is useful for connecting multiple ports between steps programmatically.

Connection Validation
--------------------

The framework performs validation when creating connections:

- Input handles can only be created for steps that have defined inputs
- Output handles can only be created for steps that have defined outputs
- The specific file/port must exist in the step's configuration
- Invalid connections will raise assertions with descriptive error messages

Example Workflow
----------------

A typical connection pattern:

.. code-block:: python

  # Create steps
  step1 = Step('step1_path')
  step2 = Step('step2_path')
  
  # Add steps to graph
  g.add_step(step1)
  g.add_step(step2)
  
  # Connect specific ports
  g.connect(step1.o('output_file'), step2.i('input_file'))
  
  # Or connect all matching ports automatically
  for out_handle in step1.all_output_handles():
      for in_handle in step2.all_input_handles():
          if out_handle[2] == in_handle[2]:  # Match by filename
              g.connect(out_handle, in_handle)

The connection system ensures that data flows correctly between steps in the build pipeline, with proper validation to catch configuration errors early.