```rst
Array Best Practices
===================

This document outlines best practices for working with arrays in Dask, particularly when dealing with masked arrays and NumPy compatibility.

Dispatch System
---------------

Dask array uses a dispatch system for various array operations to enable backend-agnostic computations. The following dispatches are available:

- ``concatenate_lookup`` - For array concatenation operations
- ``tensordot_lookup`` - For tensor dot products
- ``einsum_lookup`` - For Einstein summation operations
- ``empty_lookup`` - For creating empty arrays
- ``divide_lookup`` - For division operations
- ``percentile_lookup`` - For percentile calculations
- ``numel_lookup`` - For counting array elements
- ``nannumel_lookup`` - For counting non-NaN array elements
- ``to_numpy_dispatch`` - For converting to NumPy arrays
- ``to_cupy_dispatch`` - For converting to CuPy arrays

Masked Array Operations
-----------------------

Dask provides comprehensive support for masked arrays with functions that mirror NumPy's ``numpy.ma`` module:

Basic Masking Functions
~~~~~~~~~~~~~~~~~~~~~~~

- ``masked_greater``, ``masked_greater_equal``, ``masked_less``, ``masked_less_equal``, 
  ``masked_not_equal`` - Element-wise comparison masking operations
- ``masked_equal`` - Masks elements equal to a scalar value (does not support array values)
- ``masked_invalid`` - Masks invalid values (NaN, inf)
- ``masked_inside``, ``masked_outside`` - Masks values inside/outside a given range

Advanced Masking Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~

- ``masked_where`` - Masks elements where condition is True (requires consistent shapes)
- ``masked_values`` - Masks values approximately equal to a given value (scalar only)
- ``fix_invalid`` - Replaces invalid values with fill_value
- ``filled`` - Returns array with masked values replaced by fill_value
- ``getdata`` - Returns the data part of masked array
- ``getmaskarray`` - Returns the mask part of masked array

Best Practices
--------------

1. **Use asanyarray() for Input Conversion**: Always convert inputs using ``asanyarray()`` 
   to ensure proper Dask array handling while preserving array subclasses.

2. **Shape Consistency**: Ensure consistent shapes when using operations like ``masked_where`` 
   where the condition array must match the input array shape.

3. **Scalar Values Only**: Some functions like ``masked_equal`` and ``masked_values`` only 
   support scalar values for the comparison parameter, not array values.

4. **Blockwise Operations**: Many masked array operations use ``blockwise`` or ``map_blocks`` 
   for efficient parallel computation across array chunks.

5. **Type Preservation**: Operations maintain the original array dtype unless explicitly 
   modified by the operation.

6. **Backend Compatibility**: Use the dispatch system when working with different array 
   backends to ensure cross-compatibility.

Example Usage
-------------

.. code-block:: python

    import dask.array as da
    import dask.array.ma as dma
    
    # Create a dask array
    x = da.random.random((1000, 1000), chunks=(100, 100))
    
    # Mask values greater than 0.5
    masked = dma.masked_greater(x, 0.5)
    
    # Get the data without masked values
    clean_data = dma.filled(masked, fill_value=0.0)

Note: These functions are derived from NumPy's masked array module and maintain similar 
behavior while providing distributed computation capabilities.
```