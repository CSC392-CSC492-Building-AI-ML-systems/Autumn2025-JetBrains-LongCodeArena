Markov chain Monte Carlo Framework
==================================

The Markov chain Monte Carlo (MCMC) framework provides tools for equilibrium sampling from thermodynamic states of biomolecules using various MCMC schemes.

Overview
--------

This module implements a flexible framework for MCMC sampling with support for:

- Langevin dynamics (use with caution regarding integration error)
- Hybrid Monte Carlo (HMC)
- Generalized hybrid Monte Carlo (GHMC)
- Monte Carlo barostat moves

Moves can be combined using the ``SequenceMove`` and ``WeightedMove`` classes to create complex sampling protocols.

Core Components
---------------

MCMCMove
~~~~~~~~

Abstract base class defining the interface for all MCMC moves. To create a custom move, implement the ``apply()`` method which modifies the thermodynamic and/or sampler state.

MCMCSampler
~~~~~~~~~~~

The main sampler class that coordinates MCMC sampling. It maintains:

- Current thermodynamic state
- Current sampler state (positions, velocities)
- A collection of moves to attempt

The sampler can be configured to use different move selection strategies:
- Sequential execution of moves (using list/tuple)
- Weighted random selection of moves (using dictionary)

Context Caching
---------------

The framework employs intelligent context caching to optimize performance:

- Uses fastest available OpenMM platform by default
- Global context cache can be configured for platform selection and TTL
- Local context caches can be created for specific move sequences
- Dummy cache available for no-caching scenarios

Examples
--------

Basic usage with GHMC move:

.. code-block:: python

   from simtk import unit
   from openmmtools import testsystems, cache
   from openmmtools.states import ThermodynamicState, SamplerState
   
   test = testsystems.AlanineDipeptideVacuum()
   thermodynamic_state = ThermodynamicState(system=test.system,
                                            temperature=298*unit.kelvin)
   sampler_state = SamplerState(positions=test.positions)
   
   ghmc_move = GHMCMove(timestep=1.0*unit.femtosecond, n_steps=50)
   sampler = MCMCSampler(thermodynamic_state, sampler_state, move=ghmc_move)

Combining moves:

.. code-block:: python

   # Sequential moves
   sequence_move = SequenceMove([ghmc_move, langevin_move])
   
   # Weighted random selection
   weighted_move = WeightedMove([(ghmc_move, 0.5), (langevin_move, 0.5)])

Configuring context caching:

.. code-block:: python

   # Global cache configuration
   reference_platform = openmm.Platform.getPlatformByName('Reference')
   cache.global_context_cache.platform = reference_platform
   cache.global_context_cache.time_to_live = 10
   
   # Local cache
   local_cache = cache.ContextCache(capacity=5, time_to_live=50)
   sequence_move = SequenceMove([HMCMove(), LangevinDynamicsMove()],
                                context_cache=local_cache)

Running sampling:

.. code-block:: python

   sampler.minimize()
   sampler.run(n_iterations=100)

References
----------

Jun S. Liu. Monte Carlo Strategies in Scientific Computing. Springer, 2008.