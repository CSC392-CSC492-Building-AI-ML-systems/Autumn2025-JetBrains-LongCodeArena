Parallel Random Number Generation
================================

NumPy's random module provides support for generating random numbers in parallel
computing environments using independent streams. This is achieved through
several mechanisms that ensure statistical independence and reproducibility.

Bit Generators and Seed Sequences
---------------------------------

The core of parallel random number generation relies on:

1. **BitGenerator classes**: Implementations like PCG64, Philox, MT19937, and SFC64
   that can be instantiated with different seeds to produce independent streams

2. **SeedSequence**: A robust method for generating initial states for multiple
   independent BitGenerators from a single master seed

Example of parallel generation with multiple independent streams:

```python
from numpy.random import Generator, PCG64, SeedSequence

# Create independent streams from a single seed
seed_seq = SeedSequence(12345)
bit_generators = [PCG64(s) for s in seed_seq.spawn(4)]
generators = [Generator(bg) for bg in bit_generators]

# Each generator produces independent streams
results = [gen.random(1000) for gen in generators]
```

Parallel Architectures Support
------------------------------

The random module includes several optimized components for parallel generation:

- **C-distributions library**: Pre-compiled static library (npyrandom) containing
  efficient implementations of random distribution functions
- **Multiple BitGenerator backends**: MT19937, Philox, PCG64, and SFC64 with
  optimized C implementations
- **Bounded integer generation**: Specialized functions for efficient integer
  random number generation within ranges

The module is built with Meson build system and includes:

- Cython extensions for each BitGenerator type
- Legacy support through the mtrand module
- Comprehensive test suites with verification data sets
- Examples for extending functionality with CFFI, Cython, and Numba

Reproducibility and Thread Safety
---------------------------------

For parallel applications:

- Each thread/process should use its own Generator instance
- SeedSequence.spawn() guarantees independent streams from a common seed
- All BitGenerators are thread-safe for concurrent generation
- State can be saved/restored for exact reproducibility

The module includes extensive test data sets for verifying the correctness
of each BitGenerator implementation across different parallel scenarios.