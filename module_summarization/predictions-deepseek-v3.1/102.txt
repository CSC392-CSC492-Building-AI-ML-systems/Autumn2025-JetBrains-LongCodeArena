autowrap
=======

The ``autowrap`` module provides functionality for compiling codegen output and wrapping the resulting binary for use in Python. It offers a common interface for different external backends such as f2py, Cython, and others (currently only f2py and Cython are implemented). The primary goal is to provide access to compiled binaries with acceptable performance through a simple user interface.

Overview
--------

The module enables users to convert symbolic expressions into high-performance binary callables. For example:

.. code-block:: python

    >>> expr = ((x - y)**25).expand()
    >>> binary_callable = autowrap(expr)
    >>> binary_callable(1, 2)
    -1.0

The returned callable is a binary Python function. To use the compiled function within symbolic expressions, the ``binary_function`` utility can be used, which returns a Diofant Function object with the binary callable attached as the ``_imp_`` attribute.

.. code-block:: python

    >>> f = binary_function('f', expr)
    >>> 2*f(x, y) + y
    y + 2*f(x, y)
    >>> (2*f(x, y) + y).evalf(2, subs={x: 1, y: 2}, strict=False)
    0.e-190

Use Cases
---------

- **Large array computations**: When Python iterations are too slow and NumPy's advanced indexing is insufficient.
- **Repeated evaluations**: For long expressions called frequently, compiled binaries are significantly faster than Diofant's ``evalf()``.
- **Immediate testing**: When generating code with the codegen utility for use in other projects, autowrap allows immediate testing from within Diofant.
- **Custom ufuncs**: For creating customized ufuncs for use with NumPy arrays (see ``ufuncify``).

When Not to Use
---------------

- **Optimization concerns**: For maximum speed or memory optimization, working directly with wrapper tools and low-level code may yield better results.
- **Simple array computations**: If the computation can be easily handled by NumPy and the binary is not needed elsewhere.

Classes
-------

CodeWrapper
~~~~~~~~~~~

Base class for code wrappers.

**Properties**:

- ``filename``: Returns the base filename with a module counter.
- ``module_name``: Returns the base module name with a module counter.
- ``include_header``: Boolean indicating if a header should be included.
- ``include_empty``: Boolean indicating if empty includes should be allowed.

**Methods**:

- ``__init__(generator, filepath=None, flags=[], verbose=False)``: Initializes the wrapper with a code generator, optional file path, flags, and verbosity setting.
- ``wrap_code(routine, helpers=[])``: Generates and compiles the code, returning the wrapped function.
- ``_generate_code(main_routine, routines)``: Generates the code using the provided routines.
- ``_process_files(routine)``: Processes the generated files using the backend command.

DummyWrapper
~~~~~~~~~~~~

A dummy wrapper used for testing independent of backends. It generates a Python module that returns a string representation of the expression and argument metadata.

**Methods**:

- ``_generate_code(main_routine, routines)``: Writes a dummy Python module.
- ``_get_wrapped_function(mod, name)``: Retrieves the function from the module.

CythonCodeWrapper
~~~~~~~~~~~~~~~~~

Wrapper that uses Cython (incomplete in the provided code).

**Note**: The provided code snippet ends abruptly; this wrapper is intended for Cython-based compilation but is not fully shown.

Exceptions
----------

CodeWrapError
~~~~~~~~~~~~~

Generic exception raised for errors during code wrapping.

Dependencies
------------

The module depends on:

- External tools: f2py, gfortran, gcc
- Python modules: numpy

These are required for doctests and full functionality.

Temporary Files
---------------

By default, temporary files are cleaned up after compilation. To preserve them, specify a ``tempdir`` path when initializing the wrapper.

See Also
--------

- ``binary_function``: For creating symbolic functions from compiled binaries.
- ``ufuncify``: For creating NumPy ufuncs.
- Diofant's codegen utilities: For generating low-level code.