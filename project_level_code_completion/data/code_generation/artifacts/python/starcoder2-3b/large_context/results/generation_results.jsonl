{"original_prediction": "    if next(raw_path.glob(f'_iblrig_{label}Camera.frameData*.bin'), None):\n       ", "prediction_line": "    if next(raw_path.glob(f'_iblrig_{label}Camera.frameData*.bin'), None):", "ground_truth": "    label = assert_valid_label(label)", "line_class": "commited", "zero_context": true}
{"original_prediction": "        settings = json.load(f)\n   ", "prediction_line": "        settings = json.load(f)", "ground_truth": "        settings = json.load(f)", "line_class": "common", "zero_context": true}
{"original_prediction": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC1Low\", [np.nan])\n               ", "prediction_line": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC1Low\", [np.nan])", "ground_truth": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC1Low\", [np.nan])", "line_class": "common", "zero_context": true}
{"original_prediction": "        data.drop(data.index[:drop_first], inplace=True)\n   ", "prediction_line": "        data.drop(data.index[:drop_first], inplace=True)", "ground_truth": "        data.drop(data.loc[:drop_first].index, inplace=True)", "line_class": "common", "zero_context": true}
{"original_prediction": "    \"\"\"\n    Save a boolean value to a file.\n\n   ", "prediction_line": "    \"\"\"", "ground_truth": "    if isinstance(save, bool):", "line_class": "common", "zero_context": true}
{"original_prediction": "        return save\n    elif isinstance(save, str):\n       ", "prediction_line": "        return save", "ground_truth": "        out = save", "line_class": "common", "zero_context": true}
{"original_prediction": "    elif isinstance(save, str):\n       ", "prediction_line": "    elif isinstance(save, str):", "ground_truth": "    elif isinstance(save, list):", "line_class": "common", "zero_context": true}
{"original_prediction": "        out = [x in dataset_type for x in save]\n   ", "prediction_line": "        out = [x in dataset_type for x in save]", "ground_truth": "        out = (dataset_type in save) or (Path(dataset_type).stem in save)", "line_class": "common", "zero_context": true}
{"original_prediction": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC2High\", [np.nan])\n               ", "prediction_line": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC2High\", [np.nan])", "ground_truth": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC2High\", [np.nan])", "line_class": "common", "zero_context": true}
{"original_prediction": "    # if there are any missing values, fill them with the last known value\n   ", "prediction_line": "    # if there are any missing values, fill them with the last known value", "ground_truth": "    data.drop(data.loc[data.bns_ts.apply(len) != 33].index, inplace=True)", "line_class": "common", "zero_context": true}
{"original_prediction": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC2Low\", [np.nan])\n               ", "prediction_line": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC2Low\", [np.nan])", "ground_truth": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC2Low\", [np.nan])", "line_class": "common", "zero_context": true}
{"original_prediction": " if tr['BNC1_polarity'] == 1 else [x, 0]\n                   ", "prediction_line": " if tr['BNC1_polarity'] == 1 else [x, 0]", "ground_truth": "                    for x in tr[\"behavior_data\"][\"Events timestamps\"].get(\"BNC1High\", [np.nan])", "line_class": "common", "zero_context": true}
{"original_prediction": "        return _load_encoder_positions_file_lt5(path)", "prediction_line": "        return _load_encoder_positions_file_lt5(path)", "ground_truth": "        return _load_encoder_positions_file_lt5(path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        data = [trial_times_to_times(i) for i in data]\n   ", "prediction_line": "        data = [trial_times_to_times(i) for i in data]", "ground_truth": "        data = [trial_times_to_times(t) for t in data]", "line_class": "infile", "zero_context": true}
{"original_prediction": "        df = load_camera_frame_data(session_path, label=label, raw=raw)\n       ", "prediction_line": "        df = load_camera_frame_data(session_path, label=label, raw=raw)", "ground_truth": "        df = load_camera_frame_data(session_path, camera=label)", "line_class": "infile", "zero_context": true}
{"original_prediction": "    return _groom_wheel_data_lt5(data, label='_iblrig_encoderEvents.raw.ssv', path=file_path)", "prediction_line": "    return _groom_wheel_data_lt5(data, label='_iblrig_encoderEvents.raw.ssv', path=file_path)", "ground_truth": "    return _groom_wheel_data_lt5(data, label='_iblrig_encoderEvents.raw.ssv', path=file_path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        return _load_encoder_events_file_le4(path)", "prediction_line": "        return _load_encoder_events_file_le4(path)", "ground_truth": "        return _load_encoder_events_file_lt5(path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        # New bin file format\n       ", "prediction_line": "        # New bin file format", "ground_truth": "        df = load_camera_frame_data(session_path, camera=camera)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        df = load_camera_frame_data(session_path, camera=label)\n       ", "prediction_line": "        df = load_camera_frame_data(session_path, camera=label)", "ground_truth": "        df = load_camera_frame_data(session_path, camera=label, raw=False)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        settings = load_settings(session_path)\n   ", "prediction_line": "        settings = load_settings(session_path)", "ground_truth": "        settings = load_settings(session_path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "    data.columns = ['re_ts','re_pos', 'bns_ts']\n   ", "prediction_line": "    data.columns = ['re_ts','re_pos', 'bns_ts']", "ground_truth": "    return _groom_wheel_data_lt5(data, label='_iblrig_encoderPositions.raw.ssv', path=file_path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "    if count is None:\n       ", "prediction_line": "    if count is None:", "ground_truth": "    gpio = load_camera_gpio(session_path, label, as_dicts=not raw)", "line_class": "infile", "zero_context": true}
{"original_prediction": "    return _groom_wheel_data_ge5(data, label='_iblrig_encoderEvents.raw.ssv', path=file_path)", "prediction_line": "    return _groom_wheel_data_ge5(data, label='_iblrig_encoderEvents.raw.ssv', path=file_path)", "ground_truth": "    return _groom_wheel_data_ge5(data, label='_iblrig_encoderEvents.raw.ssv', path=file_path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        converted_events[k] = convert(v)\n\n   ", "prediction_line": "        converted_events[k] = convert(v)", "ground_truth": "        converted_events.update({k: [convert(i) for i in v]})", "line_class": "infile", "zero_context": true}
{"original_prediction": "        data = load_data(session_path)\n   ", "prediction_line": "        data = load_data(session_path)", "ground_truth": "        data = load_data(session_path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        converted_states.update({k: [convert(i) for i in v]})\n   ", "prediction_line": "        converted_states.update({k: [convert(i) for i in v]})", "ground_truth": "        converted_states.update({k: [[convert(i) for i in x] for x in v]})", "line_class": "infile", "zero_context": true}
{"original_prediction": "        # new format\n        data = pd.read_csv(path, sep=' ', header=None, error_bad_lines=False)\n       ", "prediction_line": "        # new format", "ground_truth": "        return _load_encoder_events_file_ge5(path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "    return _groom_wheel_data_ge5(data, label='_iblrig_encoderPositions.raw.ssv', path=file_path)", "prediction_line": "    return _groom_wheel_data_ge5(data, label='_iblrig_encoderPositions.raw.ssv', path=file_path)", "ground_truth": "    return _groom_wheel_data_ge5(data, label='_iblrig_encoderPositions.raw.ssv', path=file_path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "        return _load_encoder_positions_file_ge5(path)\n   ", "prediction_line": "        return _load_encoder_positions_file_ge5(path)", "ground_truth": "        return _load_encoder_positions_file_ge5(path)", "line_class": "infile", "zero_context": true}
{"original_prediction": "[description]\n\n    :param session_path: Absolute path of session folder\n   ", "prediction_line": "[description]", "ground_truth": "    Assumes that a folder called \"raw_behavior_data\" exists in folder.", "line_class": "non_informative", "zero_context": true}
{"original_prediction": " _ibl_trials.humidity_percent\n\n   ", "prediction_line": " _ibl_trials.humidity_percent", "ground_truth": "    _ibl_trials.relativeHumidity", "line_class": "non_informative", "zero_context": true}
{"original_prediction": ":param session_path: Absolute path of session folder", "prediction_line": ":param session_path: Absolute path of session folder", "ground_truth": "    Bpod timestamps are in microseconds (Âµs)", "line_class": "non_informative", "zero_context": true}
{"original_prediction": "    data = _clean_wheel_dataframe(data, label, path)\n   ", "prediction_line": "    data = _clean_wheel_dataframe(data, label, path)", "ground_truth": "    data = _clean_wheel_dataframe(data, label, path)", "line_class": "non_informative", "zero_context": true}
{"original_prediction": "\t:param session_path: Absolute path of session folder", "prediction_line": "\t:param session_path: Absolute path of session folder", "ground_truth": "    The raw binary file contains uint32 values (saved as doubles) where the first 4 bits", "line_class": "non_informative", "zero_context": true}
{"original_prediction": "        cdt = np.abs(dt0[i0] - dt1[isearch])\n       ", "prediction_line": "        cdt = np.abs(dt0[i0] - dt1[isearch])", "ground_truth": "        dec = np.abs(dt0[i0] - dt1[isearch]) < diff_threshold", "line_class": "random", "zero_context": true}
{"original_prediction": "            return\n        if as_dicts:\n           ", "prediction_line": "            return", "ground_truth": "            return [None] * 4 if as_dicts else None", "line_class": "random", "zero_context": true}
{"original_prediction": "    \"\"\"\n    Sync two lists of timestamps with a drift threshold.\n\n   ", "prediction_line": "    \"\"\"", "ground_truth": "    \"\"\"", "line_class": "random", "zero_context": true}
{"original_prediction": "/ibllib/io/extractors.pyimport logging", "prediction_line": "/ibllib/io/extractors.pyimport logging", "ground_truth": "    BNC1_fronts = BNC1_fronts[1:, :]", "line_class": "random", "zero_context": true}
